{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"\"Clean Code\" - FDIBA - Winter Semester 2022 Liebe Studenten, in den kommenden Wochen werden wir zusammen erarbeiten was es bedeutet \"Clean Code\" zu schreiben. Wir werden hierbei analysieren was genau es bedeutet \"Clean Code\" zu produzieren und welche Voraussetzungen wir hierf\u00fcr erf\u00fcllen m\u00fcssen. Diese Dokumentation hierbei wird eine \"living documentation\" sein. Das bedeutet, sie wird kontinuierlich erweitert und auf agile Art und Weise nach und nach verbessert. Um nicht st\u00e4ndig das Rad neu zu erfinden werden wir viele existierenden Quelle nutzen und verlinken.","title":"Home"},{"location":"#clean-code-fdiba-winter-semester-2022","text":"Liebe Studenten, in den kommenden Wochen werden wir zusammen erarbeiten was es bedeutet \"Clean Code\" zu schreiben. Wir werden hierbei analysieren was genau es bedeutet \"Clean Code\" zu produzieren und welche Voraussetzungen wir hierf\u00fcr erf\u00fcllen m\u00fcssen. Diese Dokumentation hierbei wird eine \"living documentation\" sein. Das bedeutet, sie wird kontinuierlich erweitert und auf agile Art und Weise nach und nach verbessert. Um nicht st\u00e4ndig das Rad neu zu erfinden werden wir viele existierenden Quelle nutzen und verlinken.","title":"\"Clean Code\" - FDIBA - Winter Semester 2022"},{"location":"about/","text":"\u00dcber uns Klaus Riedel - der Agile Transformer Im Bereich agile Transformation gibt es wohl nichts, was Klaus nicht schon gesehen hat. \u00dcber 10 Jahre agile Transformationen in Organisationen wie Deutsche Bahn, Lufthansa, Microsoft, Bosch, Conrad Electronics, Bank of Scotland, Deutsche Bank und einige mehr lassen agile Transformationen leicht aussehen. Seit etwas \u00fcber 10 Jahren ist er als Mitgr\u00fcnder und Partner der Unternehmens Blubito als CEO t\u00e4tig und \u00fcbernimmt hierbei rund um die Organisation, Sales und Marketing. Klaus unterrichtet \u201eAgiles Projektmanagement\u201c sowie \"Clean Code\" an der TU Sofia, ist Autor des Blubito Blogs f\u00fcr agile Softwareentwicklung und des runScrum Blogs \u00fcber agiles Projektmanagement und betreut mehrere Teams als Product Owner. Jan Br\u00fcggmann - der Tech Guru Jan begann mit 14 Jahren Software zu entwickeln und hat in den ca. 25 Jahren seitdem eigentlich auch nie etwas anderes getan oder gelernt. Seine professionelle Karriere began mit Anfang 20 als IT-Berater f\u00fcr diverse deutsche Unternehmen, von Airlines bis hin zu Banken und der Immobilienwirtschaft. Seit etwas \u00fcber 10 Jahren ist er als Mitgr\u00fcnder und Partner der Unternehmens Blubito als CTO t\u00e4tig und \u00fcbernimmt hierbei alles um Technik, Ausbildung und Recruiting. Jan unterrichtet \"Clean Code\" an der TU Sofia und unterst\u00fctzt viele Kollegen als auch Kunden bei der L\u00f6sung diverser technischen Probleme. G\u00e4ste Sp\u00e4ter mehr...","title":"\u00dcber uns"},{"location":"about/#uber-uns","text":"","title":"\u00dcber uns"},{"location":"about/#klaus-riedel-der-agile-transformer","text":"Im Bereich agile Transformation gibt es wohl nichts, was Klaus nicht schon gesehen hat. \u00dcber 10 Jahre agile Transformationen in Organisationen wie Deutsche Bahn, Lufthansa, Microsoft, Bosch, Conrad Electronics, Bank of Scotland, Deutsche Bank und einige mehr lassen agile Transformationen leicht aussehen. Seit etwas \u00fcber 10 Jahren ist er als Mitgr\u00fcnder und Partner der Unternehmens Blubito als CEO t\u00e4tig und \u00fcbernimmt hierbei rund um die Organisation, Sales und Marketing. Klaus unterrichtet \u201eAgiles Projektmanagement\u201c sowie \"Clean Code\" an der TU Sofia, ist Autor des Blubito Blogs f\u00fcr agile Softwareentwicklung und des runScrum Blogs \u00fcber agiles Projektmanagement und betreut mehrere Teams als Product Owner.","title":"Klaus Riedel - der Agile Transformer"},{"location":"about/#jan-bruggmann-der-tech-guru","text":"Jan begann mit 14 Jahren Software zu entwickeln und hat in den ca. 25 Jahren seitdem eigentlich auch nie etwas anderes getan oder gelernt. Seine professionelle Karriere began mit Anfang 20 als IT-Berater f\u00fcr diverse deutsche Unternehmen, von Airlines bis hin zu Banken und der Immobilienwirtschaft. Seit etwas \u00fcber 10 Jahren ist er als Mitgr\u00fcnder und Partner der Unternehmens Blubito als CTO t\u00e4tig und \u00fcbernimmt hierbei alles um Technik, Ausbildung und Recruiting. Jan unterrichtet \"Clean Code\" an der TU Sofia und unterst\u00fctzt viele Kollegen als auch Kunden bei der L\u00f6sung diverser technischen Probleme.","title":"Jan Br\u00fcggmann - der Tech Guru"},{"location":"about/#gaste","text":"Sp\u00e4ter mehr...","title":"G\u00e4ste"},{"location":"module-1/comments/","text":"Das Problem mit den Kommentaren im Code... Kommentare im Code werden von verschiedenen Personen und Organisatione sehr unterschiedlich betrachtet und es gibt keine wirklich 100% einheitliche L\u00f6sung wie man mit Kommentaren im Code umgehen soll. Viele Organisationen erwarten von ihren Entwicklern, dass der gesamte Code kommentiert ist und die Kommentare selbst die Funktionalit\u00e4t als auch die Beziehungen des Codes selbst klar beschreiben. Dies ist vor allem in Organisationen der Fall in denen Richtlinien vorrangig von Personen etabliert werden, die selbst nur wenig Erfahrung mit dem Schreiben von Software haben. Dem gegen\u00fcber stehen die Puristen, welche die Meinung vertreten Kommentare sind im besten Fall nutzlos, im schlimmsten Fall sogar st\u00f6rend und verschlechtern die Verst\u00e4ndlichkeit von Code. Kommentare aus der Sicht des Clean Code Aus der Perspektive des \"Clean Code\" sollten Kommentare m\u00f6glichst selten genutzt werden. Kommentare sollten vor allem dann eingesetzt werden, wenn im Code etwas passiert was nicht durch den Code selbst erkl\u00e4rt werden kann - dies bezieht sich also vor allem auf die Fragen wie \"WARUM tut der Code das, was er hier tut?\" Kommentare die den Zweck haben zu erkl\u00e4ren WAS der Code selbst tut sind in fast allen F\u00e4llen eher ein Zeichen daf\u00fcr, dass der Code selbst zu kompliziert ist und \u00fcberarbeitet werden sollte. Mit besseren Namen und Vereinfachung des Codes selbst, k\u00f6nnen fast alle solcher Kommentare \u00fcberfl\u00fcssig gemacht werden. In Ausnahmef\u00e4llen k\u00f6nnen Kommentare n\u00fctzlich sein um Code zu erkl\u00e4ren, der sehr schwierig zu verstehen ist aber leider nicht weiter vereinfacht werden kann. Dies ist oft der Fall bei Dinge die Regul\u00e4ren Ausdr\u00fccken (RegEx) Die Gefahr der Kommentar Jeder Kommentar der geschrieben wird, muss stets geupdated werden wenn sich die Funktion auf die er sich bezieht \u00e4ndert. Dies ist nur ein kleines Problem bei wenigen Kommentaren die sich vorrangig um das \"WARUM\" k\u00fcmmern - kann jedoch zu einem sehr gro\u00dfen Problem werden wenn diese Regel nicht eingehalten wird. Jeder Entwickler kommt in seiner Karriere einmal an den Punkt dass er auf ein Problem st\u00f6sst dass er partout nicht l\u00f6sen kann, trotz viel Zeit und Arbeit - nur um dann Tage sp\u00e4ter zu bemerken dass die Kommentare die den Code beschrieben haben den er nutzt, nicht mehr mit der eigentlichen Implementation \u00fcbereinstimmen. Irgendwann wurde vergessen bei einer \u00c4nderung die Kommentare mit zu aktualisieren. Beispiele f\u00fcr gute Kommentare // Matches a Dutch zipcode, eg, '1974 XA' or '4844RA' Pattern DUTCH_ZIPCODE = Pattern.compile(\"[1-9][0-9]{3} ?[A-Z]{2}\"); int resultCode = ...; boolean isSucess = resultCode == 200; boolean isTemporaryError = resultCode == 503 || resultCode == 504; // Sometime we receive a temporary error. // However, in all cases which were researched, results were successfully stored. // Because of this we will return true in that case. return (isSucess || isTemporaryError); Anti-Patterns Danke, Captain Obvious // numeric session-id int sessionId = 0; // expiry date Date expiry = new Date(); // numeric session-id int sessionTimeoutInSeconds = 3600; // resets session-id to 99; function reset() { sessionId = 99; } Erkl\u00e4rt unklaren Code // timeout in seconds int timeout = 5; // <---- nicht gut int timeoutInSeconds = 5; // <---- besser // if during work hours if (currentTime.hours >= 9 && currentTime.hours <= 17) // <---- nicht gut if (isDuringWorkingHours(currentTime)) // <---- besser Auskommentierter Code Entwickler neigen vor allem am Anfang ihrer Karriere dazu Code auszukommentieren aus Angst ihn zu verlieren und dann sp\u00e4ter noch eimal zu brauchen. Dieses \"Feature\" ist gut gemeint, f\u00fchrt aber vor allem zu aufgebl\u00e4htem und schwer lesbaren Code - und wird so gut wie nie wirklich gebraucht. Zudem ist das Ziel selbst schon vom Source Control System erf\u00fcllt, denn hier kann auch gel\u00f6schter Code notfalls wieder hergestellt werden. Quellen https://www.baeldung.com/cs/clean-code-comments https://medium.com/codex/clean-code-comments-833e11a706dc","title":"Kommentare"},{"location":"module-1/comments/#das-problem-mit-den-kommentaren-im-code","text":"Kommentare im Code werden von verschiedenen Personen und Organisatione sehr unterschiedlich betrachtet und es gibt keine wirklich 100% einheitliche L\u00f6sung wie man mit Kommentaren im Code umgehen soll. Viele Organisationen erwarten von ihren Entwicklern, dass der gesamte Code kommentiert ist und die Kommentare selbst die Funktionalit\u00e4t als auch die Beziehungen des Codes selbst klar beschreiben. Dies ist vor allem in Organisationen der Fall in denen Richtlinien vorrangig von Personen etabliert werden, die selbst nur wenig Erfahrung mit dem Schreiben von Software haben. Dem gegen\u00fcber stehen die Puristen, welche die Meinung vertreten Kommentare sind im besten Fall nutzlos, im schlimmsten Fall sogar st\u00f6rend und verschlechtern die Verst\u00e4ndlichkeit von Code.","title":"Das Problem mit den Kommentaren im Code..."},{"location":"module-1/comments/#kommentare-aus-der-sicht-des-clean-code","text":"Aus der Perspektive des \"Clean Code\" sollten Kommentare m\u00f6glichst selten genutzt werden. Kommentare sollten vor allem dann eingesetzt werden, wenn im Code etwas passiert was nicht durch den Code selbst erkl\u00e4rt werden kann - dies bezieht sich also vor allem auf die Fragen wie \"WARUM tut der Code das, was er hier tut?\" Kommentare die den Zweck haben zu erkl\u00e4ren WAS der Code selbst tut sind in fast allen F\u00e4llen eher ein Zeichen daf\u00fcr, dass der Code selbst zu kompliziert ist und \u00fcberarbeitet werden sollte. Mit besseren Namen und Vereinfachung des Codes selbst, k\u00f6nnen fast alle solcher Kommentare \u00fcberfl\u00fcssig gemacht werden. In Ausnahmef\u00e4llen k\u00f6nnen Kommentare n\u00fctzlich sein um Code zu erkl\u00e4ren, der sehr schwierig zu verstehen ist aber leider nicht weiter vereinfacht werden kann. Dies ist oft der Fall bei Dinge die Regul\u00e4ren Ausdr\u00fccken (RegEx)","title":"Kommentare aus der Sicht des Clean Code"},{"location":"module-1/comments/#die-gefahr-der-kommentar","text":"Jeder Kommentar der geschrieben wird, muss stets geupdated werden wenn sich die Funktion auf die er sich bezieht \u00e4ndert. Dies ist nur ein kleines Problem bei wenigen Kommentaren die sich vorrangig um das \"WARUM\" k\u00fcmmern - kann jedoch zu einem sehr gro\u00dfen Problem werden wenn diese Regel nicht eingehalten wird. Jeder Entwickler kommt in seiner Karriere einmal an den Punkt dass er auf ein Problem st\u00f6sst dass er partout nicht l\u00f6sen kann, trotz viel Zeit und Arbeit - nur um dann Tage sp\u00e4ter zu bemerken dass die Kommentare die den Code beschrieben haben den er nutzt, nicht mehr mit der eigentlichen Implementation \u00fcbereinstimmen. Irgendwann wurde vergessen bei einer \u00c4nderung die Kommentare mit zu aktualisieren.","title":"Die Gefahr der Kommentar"},{"location":"module-1/comments/#beispiele-fur-gute-kommentare","text":"// Matches a Dutch zipcode, eg, '1974 XA' or '4844RA' Pattern DUTCH_ZIPCODE = Pattern.compile(\"[1-9][0-9]{3} ?[A-Z]{2}\"); int resultCode = ...; boolean isSucess = resultCode == 200; boolean isTemporaryError = resultCode == 503 || resultCode == 504; // Sometime we receive a temporary error. // However, in all cases which were researched, results were successfully stored. // Because of this we will return true in that case. return (isSucess || isTemporaryError);","title":"Beispiele f\u00fcr gute Kommentare"},{"location":"module-1/comments/#anti-patterns","text":"","title":"Anti-Patterns"},{"location":"module-1/comments/#danke-captain-obvious","text":"// numeric session-id int sessionId = 0; // expiry date Date expiry = new Date(); // numeric session-id int sessionTimeoutInSeconds = 3600; // resets session-id to 99; function reset() { sessionId = 99; }","title":"Danke, Captain Obvious"},{"location":"module-1/comments/#erklart-unklaren-code","text":"// timeout in seconds int timeout = 5; // <---- nicht gut int timeoutInSeconds = 5; // <---- besser // if during work hours if (currentTime.hours >= 9 && currentTime.hours <= 17) // <---- nicht gut if (isDuringWorkingHours(currentTime)) // <---- besser","title":"Erkl\u00e4rt unklaren Code"},{"location":"module-1/comments/#auskommentierter-code","text":"Entwickler neigen vor allem am Anfang ihrer Karriere dazu Code auszukommentieren aus Angst ihn zu verlieren und dann sp\u00e4ter noch eimal zu brauchen. Dieses \"Feature\" ist gut gemeint, f\u00fchrt aber vor allem zu aufgebl\u00e4htem und schwer lesbaren Code - und wird so gut wie nie wirklich gebraucht. Zudem ist das Ziel selbst schon vom Source Control System erf\u00fcllt, denn hier kann auch gel\u00f6schter Code notfalls wieder hergestellt werden.","title":"Auskommentierter Code"},{"location":"module-1/comments/#quellen","text":"https://www.baeldung.com/cs/clean-code-comments https://medium.com/codex/clean-code-comments-833e11a706dc","title":"Quellen"},{"location":"module-1/debugging/","text":"Was ist Debugging? Debugging beschreibt die T\u00e4tigkeit ein Computerprogramm von einem technischen- oder inhaltlichen Fehler zu befreien. W\u00e4hrend das Debuggen selbst eigentlich keinen direkten Bezug zu Clean Code hat, so beeinflussen sich beide doch massiv. Je \"sauberer\" der Code ist, desto eher besteht die Chance dass wir einen Bug noch w\u00e4hrend der Entwicklung entdecken. Zudem tr\u00e4gt gut strukturierter Code ungemein dazu bei, dass wir im Falle eines Problems in der Lage sind schnell die Ursache des Problems zu identifizieren und eine L\u00f6sung zu implementieren. Hierbei k\u00f6nnen uns mehrere Dinge von Nutzen sein: Logging Logging beschreibt die Ausgabe von zus\u00e4tzlichen Informationen die nicht f\u00fcr den Endnutzer bestimmt sind. Log-Statements werden hierbei in der Regel in die Console ausgegeben oder zur sp\u00e4teren Analyse an ein externes System gesendet wie beispielsweise eine Datei auf der Festplatte oder ein zentrales Logging-Tool in der Cloud. Hierbei sind folgende Punkte wichtig: Log Statements sollten hierbei die Informationen beinhalten, die sp\u00e4ter zur L\u00f6sung von Problemen tats\u00e4chlich n\u00fctzlich sind. \"Ein Fehler ist aufgetreten!\" hilft niemandem. \"Zeile 50 der Buchungs-Datei bookings-2022.csv konnte nicht vollst\u00e4ndig gelesen werden\" gibt einem Entwickler aber einen guten ersten Ansatz f\u00fcr die Fehlersuche. Die Menge an geschriebenen Log-Statements sollte \u00fcber sogenannte \"Log Levels\" anpassbar sein - denn w\u00e4hrend wir w\u00e4hrend der Entwicklung oft m\u00f6glichst viel Informationen auch von absolut erfolgreichen Events sehen wollen, so ist dies im produktiven Betrieb oft zu verwirrend. Hier wollen wir wom\u00f6glich nur \u00fcber kritische Fehler informiert werden. Logs d\u00fcrfen auf keinen Fall pers\u00f6nliche oder sicherheitskritische Informationen beinhalten - dies gilt vor allem f\u00fcr Dinge wie Kreditkarten-Nummern etc. Debugger Tools Debugger Tools sind Dinge mit denen ein Entwickler in der Lage ist eine Applikation w\u00e4hrend ihrer Ausf\u00fchrung zu pausieren und den internen Zustand der Applikation auszuwerten oder sogar zu ver\u00e4ndern. Der Punkt an dem die Applikation pausieren soll wird in der Regel \u00fcber sogenannte \"Breakpoints\" im Code definiert. Definiere ich beispielsweise einen Breakpoint innerhalb meiner doSomething() Funktion, so wird meine Applikation bei Erreichen von genau dieser Codezeile stoppen und ich kann damit beginnen die Werte von Variablen zu betrachten oder zu ver\u00e4ndern. Je nach Programmiersprache und -Umgebung kommen als Debugger-Tools verschiedene Applikationen zum Einsatz. F\u00fcr Java-Applikationen beispielsweise ist es in der Regel die IDE wie IntelliJ oder Eclipse welche die Debugger-Tools zur Verf\u00fcgung stellt, wodurch ein Entwickler seine gewohnte Umgebung gar nicht erst verlassen muss. F\u00fcr web-basierte Applikationen auf Basis von JavaScript, welche in der Regel im Browser ausgef\u00fchrt werden, bieten alle modernen Browser wie Chrome, Firefox und Safari ihre eigenen Entwickler-Tools mit Debugging Funktionalit\u00e4ten. Eclipse Debugger View","title":"Debugging"},{"location":"module-1/debugging/#was-ist-debugging","text":"Debugging beschreibt die T\u00e4tigkeit ein Computerprogramm von einem technischen- oder inhaltlichen Fehler zu befreien. W\u00e4hrend das Debuggen selbst eigentlich keinen direkten Bezug zu Clean Code hat, so beeinflussen sich beide doch massiv. Je \"sauberer\" der Code ist, desto eher besteht die Chance dass wir einen Bug noch w\u00e4hrend der Entwicklung entdecken. Zudem tr\u00e4gt gut strukturierter Code ungemein dazu bei, dass wir im Falle eines Problems in der Lage sind schnell die Ursache des Problems zu identifizieren und eine L\u00f6sung zu implementieren. Hierbei k\u00f6nnen uns mehrere Dinge von Nutzen sein:","title":"Was ist Debugging?"},{"location":"module-1/debugging/#logging","text":"Logging beschreibt die Ausgabe von zus\u00e4tzlichen Informationen die nicht f\u00fcr den Endnutzer bestimmt sind. Log-Statements werden hierbei in der Regel in die Console ausgegeben oder zur sp\u00e4teren Analyse an ein externes System gesendet wie beispielsweise eine Datei auf der Festplatte oder ein zentrales Logging-Tool in der Cloud. Hierbei sind folgende Punkte wichtig: Log Statements sollten hierbei die Informationen beinhalten, die sp\u00e4ter zur L\u00f6sung von Problemen tats\u00e4chlich n\u00fctzlich sind. \"Ein Fehler ist aufgetreten!\" hilft niemandem. \"Zeile 50 der Buchungs-Datei bookings-2022.csv konnte nicht vollst\u00e4ndig gelesen werden\" gibt einem Entwickler aber einen guten ersten Ansatz f\u00fcr die Fehlersuche. Die Menge an geschriebenen Log-Statements sollte \u00fcber sogenannte \"Log Levels\" anpassbar sein - denn w\u00e4hrend wir w\u00e4hrend der Entwicklung oft m\u00f6glichst viel Informationen auch von absolut erfolgreichen Events sehen wollen, so ist dies im produktiven Betrieb oft zu verwirrend. Hier wollen wir wom\u00f6glich nur \u00fcber kritische Fehler informiert werden. Logs d\u00fcrfen auf keinen Fall pers\u00f6nliche oder sicherheitskritische Informationen beinhalten - dies gilt vor allem f\u00fcr Dinge wie Kreditkarten-Nummern etc.","title":"Logging"},{"location":"module-1/debugging/#debugger-tools","text":"Debugger Tools sind Dinge mit denen ein Entwickler in der Lage ist eine Applikation w\u00e4hrend ihrer Ausf\u00fchrung zu pausieren und den internen Zustand der Applikation auszuwerten oder sogar zu ver\u00e4ndern. Der Punkt an dem die Applikation pausieren soll wird in der Regel \u00fcber sogenannte \"Breakpoints\" im Code definiert. Definiere ich beispielsweise einen Breakpoint innerhalb meiner doSomething() Funktion, so wird meine Applikation bei Erreichen von genau dieser Codezeile stoppen und ich kann damit beginnen die Werte von Variablen zu betrachten oder zu ver\u00e4ndern. Je nach Programmiersprache und -Umgebung kommen als Debugger-Tools verschiedene Applikationen zum Einsatz. F\u00fcr Java-Applikationen beispielsweise ist es in der Regel die IDE wie IntelliJ oder Eclipse welche die Debugger-Tools zur Verf\u00fcgung stellt, wodurch ein Entwickler seine gewohnte Umgebung gar nicht erst verlassen muss. F\u00fcr web-basierte Applikationen auf Basis von JavaScript, welche in der Regel im Browser ausgef\u00fchrt werden, bieten alle modernen Browser wie Chrome, Firefox und Safari ihre eigenen Entwickler-Tools mit Debugging Funktionalit\u00e4ten.","title":"Debugger Tools"},{"location":"module-1/debugging/#eclipse-debugger-view","text":"","title":"Eclipse Debugger View"},{"location":"module-1/exercise/","text":"Aufgabe zum Modul 1 Story","title":"Aufgabe zum Modul 1"},{"location":"module-1/exercise/#aufgabe-zum-modul-1","text":"","title":"Aufgabe zum Modul 1"},{"location":"module-1/exercise/#story","text":"","title":"Story"},{"location":"module-1/git/","text":"Was ist Source Control? Source Control beschreibt die Versionierung von Source Code, also das Speichern aller Code-Dateien zu einem bestimmten Zeitpunkt. Das Source Control System hat hierbei die Aufgabe sicherzustellen, dass ein Nutzer auch sp\u00e4ter zu einer fr\u00fcheren Version seines Source Codes zur\u00fcckkehren kann - etwa um zu Vergleichen was sich ge\u00e4ndert hat oder um komplett auf eine fr\u00fchere Version zur\u00fcckzukehren. Was hat Source Control mit Clean Code zu tun? Ohne Source Control ist es sehr schwierig Source Code \u00fcber eine lange Zeit sauber und wartbar zu halten. Entwickler verlieren die \u00dcbersicht dar\u00fcber wann, von wem welche \u00c4nderung gemacht worden ist, was vor allem dann zu Problemen f\u00fchrt wenn mehrere Entwickler am gleichen Projekt arbeiten. Beim Austausch von Code zwischen Entwicklern wird es sehr schwierig nachzuvollziehen welche Datei ge\u00e4ndert worden ist und ob sich hieraus vielleicht Probleme ergeben, weil der neue Code von Entwickler A nicht zum neuen Code von Entwickler B passt. Ein Source Control System hilft dabei einen Code sauber und kompatibel zu behalten - auch wenn es weiterhin an den Entwicklern liegt, dies alles sicherzustellen. Was ist Git? Git ist das Source Control System das sich als de facto Standard in der gesamten IT Welt durchgesetzt hat. Es ist hierbei ein sogenanntes Distributed Source Control System, d.h. jeder Client (meistens Entwickler-Computer) h\u00e4lt die gesamte Historie und den gesamten Source Code des Projekts. Jedes \"Commit\" vom Code und jeder \"Push\" zu einem anderen Client \u00fcbertr\u00e4gt hierbei widerum die gesamten letzten \u00c4nderungen, nicht nur den finalen/aktuellen Stand. Commit, Push...? Die folgenden Begriffe beschreiben die Haupt-Funktionalit\u00e4ten von Git (sowieso eigentlich auch jedes anderen Source Control Systems). Eine kurze offizielle Einf\u00fchrung zu Git findet ihr hier Eine detailliertere Referenz zu Git befindet sich hier Repository Ein Git Repository ist eine Menge an Dateien die in Git verwaltet werden. Ein Repository besteht hierbei aus den Dateien selbst, mehreren Branches (d.h. parallelen Versionen) sowie der Historie/den \u00c4nderungen \u00fcber die Zeit. Clone Das Clonen eines Projekts ist das erste \"Downloaden\" eines Git Repositories auf die lokale Workstation, in der Regel vom zentralen Repository. Pull Ein Git Pull ist das \"Downloaden\" von allen \u00c4nderungen die im zentralen Repository seit dem letzten Git Pull passiert sind. Branch Branches beschreiben parallele Bearbeitungs-St\u00e4nde innerhalb eines Git Repositories. Ein Beispiel hierbei w\u00e4re ein Projekt mit 2 Entwicklern. Jeder Entwickler arbeitet an unterschiedlichen Features - aber sie m\u00fcssen beide gleichzeitig die gleichen Dateien ver\u00e4ndern. Um also nicht st\u00e4ndig Probleme mit den \u00c4nderungen des jeweils anderen Enwicklers zu bekommen startet jeder der Entwickler einen sogenannten \"Branch\". Solange er auf diesem Branch arbeitet, kann er jederzeit alle Dateien \u00e4ndern aber der jeweils andere Entwickler sieht keine dieser \u00c4nderungen. Erst wenn sein Branch zur\u00fcck in den Haupt-Branch \"gemerged\" wird, werden seine \u00c4nderungen f\u00fcr alle anderen sichtbar. Beim Branching entstehen sehr oft \"Merge Conflicts\", d.h. Probleme die daraus entstehen dass die gleiche Dateien in verschiedenen Branches ver\u00e4ndert worden sind. Um dies zu reparieren muss in der Regel ein Entwickler beide Code-Versionen vergleichen und diese Zusammenf\u00fchren. Je l\u00e4nger kein Merge stattgefunden hat, desto schwieriger wird das Mergen - es ist daher extrem wichtig so fr\u00fch wie m\u00f6glich einen Merge durchzuf\u00fchren und einen Branch wieder zu l\u00f6schen. Zudem sollten regelm\u00e4ssig die letzten \u00c4nderungen vom Haupt-Branch \u00fcbernommen werden. Commit Ein Commit ist das Abspeichern von einem Code-Stand zu einem bestimmten Zeitpunkt. Ein Commit beinhaltet normalerweise 1..n Dateien zusammen mit einer Commit Message, welche die \u00c4nderung beschreibt. Es ist bei einem Commit wichtig mit allen Entwicklern eine gemeinsame Konvention zu etablieren, wie Commit-Messages verfasst werden sollen. In der Regel beinhalten Commit-Messages daher oft die ID des Work Items zu dem diese \u00c4nderung geh\u00f6rt zusammen mit einer kurzen Beschreibung der eigentlichen \u00c4nderung. git commit -m \"bug/123 Fixed validation logic for german zip codes\" Add/Stage Beim \"Adden\" einer Datei nehmen wir sie in die Versionierung durch Git in diesem Repository mit auf. Bevor eine Datei geaddet wurde, werden ihre verschiedenen Versionsst\u00e4nde von Git ignoriert und nicht mit gespeichert. Beim Stagen markieren wir eine \u00c4nderung an einer Datei so, dass wir sie beim n\u00e4chsten Commit mit \"committen\" wollen. Wenn eine \u00c4nderung nicht \"gestaged\" wurde, dann wird sie in der Regel bei einem Commit ignoriert. Es k\u00f6nnen nur \u00c4nderung von bereits \"geaddeten\" Dateien gestaged werden. Push Ein Push \u00fcbertr\u00e4gt lokale \u00c4nderung (durch Commits) an ein anderes Git System, ein sogenanntes \"Remote\". Dies k\u00f6nnten theoretisch auch andere Entwickler Computer sein, in der Praxis hat sich aber etabliert dies an ein zentrales Repository zu senden, zu dem jeder Entwickler Zugriff hat. In den meisten F\u00e4llen wird dies ein System wie Github, Gitlab, Azure DevOps etc. sein. git push origin master .gitignore File Das .gitignore File in einem Projekt beschreibt die Dateien, die nicht mit in das Repository commited werden sollen. Dies sind in der Regel vor allem Dateien die immer wieder automatisch generiert werde (Builds) Secrets enthalten (z.B. Passw\u00f6rter, Secrets) Ein einfaches Beispiel git init git add . git commit -am \"First commit\" git remote add origin git@github.com:your_github_user/myapplication.git -- Change/write README.md and .gitignore files git pull origin main -- Send the entire application to Github git push origin main","title":"Git"},{"location":"module-1/git/#was-ist-source-control","text":"Source Control beschreibt die Versionierung von Source Code, also das Speichern aller Code-Dateien zu einem bestimmten Zeitpunkt. Das Source Control System hat hierbei die Aufgabe sicherzustellen, dass ein Nutzer auch sp\u00e4ter zu einer fr\u00fcheren Version seines Source Codes zur\u00fcckkehren kann - etwa um zu Vergleichen was sich ge\u00e4ndert hat oder um komplett auf eine fr\u00fchere Version zur\u00fcckzukehren.","title":"Was ist Source Control?"},{"location":"module-1/git/#was-hat-source-control-mit-clean-code-zu-tun","text":"Ohne Source Control ist es sehr schwierig Source Code \u00fcber eine lange Zeit sauber und wartbar zu halten. Entwickler verlieren die \u00dcbersicht dar\u00fcber wann, von wem welche \u00c4nderung gemacht worden ist, was vor allem dann zu Problemen f\u00fchrt wenn mehrere Entwickler am gleichen Projekt arbeiten. Beim Austausch von Code zwischen Entwicklern wird es sehr schwierig nachzuvollziehen welche Datei ge\u00e4ndert worden ist und ob sich hieraus vielleicht Probleme ergeben, weil der neue Code von Entwickler A nicht zum neuen Code von Entwickler B passt. Ein Source Control System hilft dabei einen Code sauber und kompatibel zu behalten - auch wenn es weiterhin an den Entwicklern liegt, dies alles sicherzustellen.","title":"Was hat Source Control mit Clean Code zu tun?"},{"location":"module-1/git/#was-ist-git","text":"Git ist das Source Control System das sich als de facto Standard in der gesamten IT Welt durchgesetzt hat. Es ist hierbei ein sogenanntes Distributed Source Control System, d.h. jeder Client (meistens Entwickler-Computer) h\u00e4lt die gesamte Historie und den gesamten Source Code des Projekts. Jedes \"Commit\" vom Code und jeder \"Push\" zu einem anderen Client \u00fcbertr\u00e4gt hierbei widerum die gesamten letzten \u00c4nderungen, nicht nur den finalen/aktuellen Stand.","title":"Was ist Git?"},{"location":"module-1/git/#commit-push","text":"Die folgenden Begriffe beschreiben die Haupt-Funktionalit\u00e4ten von Git (sowieso eigentlich auch jedes anderen Source Control Systems). Eine kurze offizielle Einf\u00fchrung zu Git findet ihr hier Eine detailliertere Referenz zu Git befindet sich hier","title":"Commit, Push...?"},{"location":"module-1/git/#repository","text":"Ein Git Repository ist eine Menge an Dateien die in Git verwaltet werden. Ein Repository besteht hierbei aus den Dateien selbst, mehreren Branches (d.h. parallelen Versionen) sowie der Historie/den \u00c4nderungen \u00fcber die Zeit.","title":"Repository"},{"location":"module-1/git/#clone","text":"Das Clonen eines Projekts ist das erste \"Downloaden\" eines Git Repositories auf die lokale Workstation, in der Regel vom zentralen Repository.","title":"Clone"},{"location":"module-1/git/#pull","text":"Ein Git Pull ist das \"Downloaden\" von allen \u00c4nderungen die im zentralen Repository seit dem letzten Git Pull passiert sind.","title":"Pull"},{"location":"module-1/git/#branch","text":"Branches beschreiben parallele Bearbeitungs-St\u00e4nde innerhalb eines Git Repositories. Ein Beispiel hierbei w\u00e4re ein Projekt mit 2 Entwicklern. Jeder Entwickler arbeitet an unterschiedlichen Features - aber sie m\u00fcssen beide gleichzeitig die gleichen Dateien ver\u00e4ndern. Um also nicht st\u00e4ndig Probleme mit den \u00c4nderungen des jeweils anderen Enwicklers zu bekommen startet jeder der Entwickler einen sogenannten \"Branch\". Solange er auf diesem Branch arbeitet, kann er jederzeit alle Dateien \u00e4ndern aber der jeweils andere Entwickler sieht keine dieser \u00c4nderungen. Erst wenn sein Branch zur\u00fcck in den Haupt-Branch \"gemerged\" wird, werden seine \u00c4nderungen f\u00fcr alle anderen sichtbar. Beim Branching entstehen sehr oft \"Merge Conflicts\", d.h. Probleme die daraus entstehen dass die gleiche Dateien in verschiedenen Branches ver\u00e4ndert worden sind. Um dies zu reparieren muss in der Regel ein Entwickler beide Code-Versionen vergleichen und diese Zusammenf\u00fchren. Je l\u00e4nger kein Merge stattgefunden hat, desto schwieriger wird das Mergen - es ist daher extrem wichtig so fr\u00fch wie m\u00f6glich einen Merge durchzuf\u00fchren und einen Branch wieder zu l\u00f6schen. Zudem sollten regelm\u00e4ssig die letzten \u00c4nderungen vom Haupt-Branch \u00fcbernommen werden.","title":"Branch"},{"location":"module-1/git/#commit","text":"Ein Commit ist das Abspeichern von einem Code-Stand zu einem bestimmten Zeitpunkt. Ein Commit beinhaltet normalerweise 1..n Dateien zusammen mit einer Commit Message, welche die \u00c4nderung beschreibt. Es ist bei einem Commit wichtig mit allen Entwicklern eine gemeinsame Konvention zu etablieren, wie Commit-Messages verfasst werden sollen. In der Regel beinhalten Commit-Messages daher oft die ID des Work Items zu dem diese \u00c4nderung geh\u00f6rt zusammen mit einer kurzen Beschreibung der eigentlichen \u00c4nderung. git commit -m \"bug/123 Fixed validation logic for german zip codes\"","title":"Commit"},{"location":"module-1/git/#addstage","text":"Beim \"Adden\" einer Datei nehmen wir sie in die Versionierung durch Git in diesem Repository mit auf. Bevor eine Datei geaddet wurde, werden ihre verschiedenen Versionsst\u00e4nde von Git ignoriert und nicht mit gespeichert. Beim Stagen markieren wir eine \u00c4nderung an einer Datei so, dass wir sie beim n\u00e4chsten Commit mit \"committen\" wollen. Wenn eine \u00c4nderung nicht \"gestaged\" wurde, dann wird sie in der Regel bei einem Commit ignoriert. Es k\u00f6nnen nur \u00c4nderung von bereits \"geaddeten\" Dateien gestaged werden.","title":"Add/Stage"},{"location":"module-1/git/#push","text":"Ein Push \u00fcbertr\u00e4gt lokale \u00c4nderung (durch Commits) an ein anderes Git System, ein sogenanntes \"Remote\". Dies k\u00f6nnten theoretisch auch andere Entwickler Computer sein, in der Praxis hat sich aber etabliert dies an ein zentrales Repository zu senden, zu dem jeder Entwickler Zugriff hat. In den meisten F\u00e4llen wird dies ein System wie Github, Gitlab, Azure DevOps etc. sein. git push origin master","title":"Push"},{"location":"module-1/git/#gitignore-file","text":"Das .gitignore File in einem Projekt beschreibt die Dateien, die nicht mit in das Repository commited werden sollen. Dies sind in der Regel vor allem Dateien die immer wieder automatisch generiert werde (Builds) Secrets enthalten (z.B. Passw\u00f6rter, Secrets)","title":".gitignore File"},{"location":"module-1/git/#ein-einfaches-beispiel","text":"git init git add . git commit -am \"First commit\" git remote add origin git@github.com:your_github_user/myapplication.git -- Change/write README.md and .gitignore files git pull origin main -- Send the entire application to Github git push origin main","title":"Ein einfaches Beispiel"},{"location":"module-1/introduction/","text":"Einleitung \"Any fool can write code that a computer can understand. Good programmers write code that humans can understand.\" \u2013 Martin Fowler Clean Code beschreibt die Art und Weise Code so zu schreiben, dass dieser nicht nur seine eigentliche Funktionalit\u00e4t erf\u00fcllt, sondern gleichzeitig auch lesbar, wartbar und erweiterbar ist. Die gesamte Disziplin des \"Clean Code\" basiert hierbar auf dem ebenfalls \"Clean Code\" genannten Buch von Robert Martin (\"Uncle Bob\") - welches eines der wichtigsten B\u00fccher der gesamten IT-Geschichte darstellt und heute noch genauso aktuell ist wie damals. Hinter Abk\u00fcrzunge wie SOLID, KISS und DRY verbergen sich wichtige Konzepte die bis heute sehr wichtig sind f\u00fcr jeden Entwickler - und eben diese wollen wir gemeinsam erkl\u00e4ren. Gemeinsam verfolgen wir das Ziel des Clean Code: Die Steigerung der Code-Qualit\u00e4t welche in der Praxis vorrangig durch empirische Metriken w\u00e4hrend eines Code Reviews gemessen werden kann:","title":"Einf\u00fchrung"},{"location":"module-1/introduction/#einleitung","text":"\"Any fool can write code that a computer can understand. Good programmers write code that humans can understand.\" \u2013 Martin Fowler Clean Code beschreibt die Art und Weise Code so zu schreiben, dass dieser nicht nur seine eigentliche Funktionalit\u00e4t erf\u00fcllt, sondern gleichzeitig auch lesbar, wartbar und erweiterbar ist. Die gesamte Disziplin des \"Clean Code\" basiert hierbar auf dem ebenfalls \"Clean Code\" genannten Buch von Robert Martin (\"Uncle Bob\") - welches eines der wichtigsten B\u00fccher der gesamten IT-Geschichte darstellt und heute noch genauso aktuell ist wie damals. Hinter Abk\u00fcrzunge wie SOLID, KISS und DRY verbergen sich wichtige Konzepte die bis heute sehr wichtig sind f\u00fcr jeden Entwickler - und eben diese wollen wir gemeinsam erkl\u00e4ren. Gemeinsam verfolgen wir das Ziel des Clean Code: Die Steigerung der Code-Qualit\u00e4t welche in der Praxis vorrangig durch empirische Metriken w\u00e4hrend eines Code Reviews gemessen werden kann:","title":"Einleitung"},{"location":"module-1/naming/","text":"Warum Namen wichtig sind Das Ausw\u00e4hlen von Namen f\u00fcr Funktionen, Klassen und Variablen wirkt auf den ersten Blick unwichtig, ist in der Praxis jedoch eines der wichtigsten Momente im Entwicklungsprozess. He who shall be named Indem wir Funktionen, Klassen und Variablen ihre Namen geben, erreichen wir zwei wichtige Dinge: Wir definieren ihre Aufgabe und wir begrenzen ihren Scope Wir geben dem Leser vom Code Informationen \u00fcber das was er gerade liest Beim Vergeben von Namen m\u00fcssen wir also darauf achten, dass schon durch die Namen klar wird worum es sich handelt. Als Leitfaden k\u00f6nnen wir stets dar\u00fcber nachdenken ob ein Leser unseres Codes die Funktionalit\u00e4t von einem Objekt verstehen w\u00fcrde OHNE sich zus\u00e4tzliche Kommentare durchlesen zu m\u00fcssen. Folgende Regeln sollten f\u00fcr Namen im \"Clean Code\" Style erf\u00fcllt sein: Der Name ist lesbar & aussprechbar ( dysUntRetrmnt VS daysUntilRetirement ) Die Intention/Absicht ist klar( int mc VS int monthlyCosts ) Klassen und Objekte haben ein Nomen oder Nomen-Phrase als Namen (User, ErrorLogger) Methoden und Funktionen haben Verben oder Verb-Phrasen als Namen ( retrieveUserFromDatabase() ) TypInformationen sind nicht notwendig (firstNameString VS firstName)","title":"Namen"},{"location":"module-1/naming/#warum-namen-wichtig-sind","text":"Das Ausw\u00e4hlen von Namen f\u00fcr Funktionen, Klassen und Variablen wirkt auf den ersten Blick unwichtig, ist in der Praxis jedoch eines der wichtigsten Momente im Entwicklungsprozess.","title":"Warum Namen wichtig sind"},{"location":"module-1/naming/#he-who-shall-be-named","text":"Indem wir Funktionen, Klassen und Variablen ihre Namen geben, erreichen wir zwei wichtige Dinge: Wir definieren ihre Aufgabe und wir begrenzen ihren Scope Wir geben dem Leser vom Code Informationen \u00fcber das was er gerade liest Beim Vergeben von Namen m\u00fcssen wir also darauf achten, dass schon durch die Namen klar wird worum es sich handelt. Als Leitfaden k\u00f6nnen wir stets dar\u00fcber nachdenken ob ein Leser unseres Codes die Funktionalit\u00e4t von einem Objekt verstehen w\u00fcrde OHNE sich zus\u00e4tzliche Kommentare durchlesen zu m\u00fcssen. Folgende Regeln sollten f\u00fcr Namen im \"Clean Code\" Style erf\u00fcllt sein: Der Name ist lesbar & aussprechbar ( dysUntRetrmnt VS daysUntilRetirement ) Die Intention/Absicht ist klar( int mc VS int monthlyCosts ) Klassen und Objekte haben ein Nomen oder Nomen-Phrase als Namen (User, ErrorLogger) Methoden und Funktionen haben Verben oder Verb-Phrasen als Namen ( retrieveUserFromDatabase() ) TypInformationen sind nicht notwendig (firstNameString VS firstName)","title":"He who shall be named"},{"location":"module-1/return-early/","text":"Komplexer Code public String returnStuff(SomeObject argument1, SomeObject argument2) { if (argument1.isValid()) { if (argument2.isValid()) { SomeObject otherVal1 = doSomeStuff(argument1, argument2) if (otherVal1.isValid()) { SomeObject otherVal2 = doAnotherStuff(otherVal1) if (otherVal2.isValid()) { return \"Stuff\"; } else { throw new Exception(); } } else { throw new Exception(); } } else { throw new Exception(); } } else { throw new Exception(); } } Vereinfachter Code mit Return Early Pattern public String returnStuff(SomeObject argument1, SomeObject argument2){ if (!argument1.isValid()) { throw new Exception(); } if (!argument2.isValid()) { throw new Exception(); } SomeObject otherVal1 = doSomeStuff(argument1, argument2); if (!otherVal1.isValid()) { throw new Exception(); } SomeObject otherVal2 = doAnotherStuff(otherVal1); if (!otherVal2.isValid()) { throw new Exception(); } return \"Stuff\"; } https://medium.com/swlh/return-early-pattern-3d18a41bba8","title":"Return early"},{"location":"module-1/structure/","text":"Wie sieht guter Code aus? Der Code ist nicht zu gro\u00df Funktionen und Klassen sollten m\u00f6glichst klein gehalten werden, damit sie einfacher zu lesen sind und damit sie nicht zu viel auf einmal tun. Der Code folgt den Konventionen Jede Programmiersprache und/oder jede Organisation folgt in der Regel einer Konvention wie Code strukturiert und aufgebaut sein sollte. Code der diesen Konventionen folgt ist einfacher zu lesen und schneller zu verstehen von Entwicklern die diese Konvention schon gew\u00f6hnt sind. Zudem sind in den Konventionen oft \"Tricks\" versteckt, welche unter bestimmten Umst\u00e4nden Fehler verhindern k\u00f6nnen. Google beispielsweise ver\u00f6ffentlicht sehr gute Styleguides: Google Java Styleguide Google Python Styleguide Der Code Enth\u00e4lt keine/kaum Duplikate Duplikate / der gleiche Code mehrfach in der Applikation f\u00fchrt oft zu Problemen, da sich der Entwickler immer daran erinnern muss dass er eine \u00c4nderung an einer Stelle auch an allen anderen Stellen nachholen muss. Dies wird bei wachsender Code-Gr\u00f6\u00dfe zu einem immer schwierigeren Problem Der Code beinhaltet Whitespaces f\u00fcr die Lesbarkeit Dicht aneinander geschriebener Code ohne jegliche Leerzeilen etc. ist f\u00fcr Menschen sehr schwer zu lesen. Gelegentliche Leerzeilen und Leerzeichen helfen. Der Code ist hierbei stehts konsistent! Der Code ist richtig einger\u00fcckt Richtiges Einr\u00fccken vom Code steigert die Lesbarkeit ungemein - und w\u00e4hrend es in Programmiersprachen wie Java \"nur\" der Lesbarkeit dient, wirkt sich das Einr\u00fccken vom Code in Sprachen wie Python sogar auf die gesamte Funktionalit\u00e4t aus! ... aber nicht zu oft einger\u00fcckt Ist ein Code sehr oft einger\u00fcckt, weil es viele IF Bedingungen gibt o\u00c4, so ist dies nicht nur schwierig zu lesen sondern auch mental sehr schwierig nachzuvollziehen. Eine Technik die sich in der Praxis gut bew\u00e4hrt hat um komplexe IF Szenarios zu vereinfachen ist das \"return early pattern\" Return Early Pattern Der Code beinhaltet keine Magic Numbers Magic Numbers beschreiben Zahlen oder Werte im Code, die f\u00fcr einen Leser nicht direkt offensichtlich sind. Magic Numbers sollten mit der Hilfe von Konstanten oder \u00e4hnlichen Konstrukten weiter erkl\u00e4rt werden if(age >= 20) { executeCode(); } Besser: public static final int LEGAL_DRINKING_AGE_IN_JAPAN = 20; (...) if( age >= LEGAL_DRINKING_AGE_IN_JAPAN) { executeCode(); } Der Code kapselt komplexe Logik Komplexe Logik (z.B. gro\u00dfe IF Abfragen) k\u00f6nnen sehr schwierig zu lesen und zu verstehen sein, wodurch sie auch den Code um sie herum beeinflussen kann und schwieriger zu supporten macht. Um dies etwas zu verbessern sollte komplexe Logik via \"Zwischen-Variablen\" oder am besten gleich in dedizierte Funktionen gekapselt werden. Nicht gut: if ( employee.age > 55 && employee.yearsEmplyed > 10 && employee.isRetired ) { // do something } Besser: bool eligibleForPension = employee.age > minRetirementAge && employee.yearEmployed > minPensionEmploymentYears && emplyee.isRetired ; Noch besser: private boolean isEligbleForPension(Employee employee) { return employee.age > minRetirementAge && employee.yearEmployed > minPensionEmploymentYears && emplyee.isRetired; } (...) if( isEligbleForPension(employee) ) { // do something }","title":"Code-Struktur"},{"location":"module-1/structure/#wie-sieht-guter-code-aus","text":"","title":"Wie sieht guter Code aus?"},{"location":"module-1/structure/#der-code-ist-nicht-zu-gro","text":"Funktionen und Klassen sollten m\u00f6glichst klein gehalten werden, damit sie einfacher zu lesen sind und damit sie nicht zu viel auf einmal tun.","title":"Der Code ist nicht zu gro\u00df"},{"location":"module-1/structure/#der-code-folgt-den-konventionen","text":"Jede Programmiersprache und/oder jede Organisation folgt in der Regel einer Konvention wie Code strukturiert und aufgebaut sein sollte. Code der diesen Konventionen folgt ist einfacher zu lesen und schneller zu verstehen von Entwicklern die diese Konvention schon gew\u00f6hnt sind. Zudem sind in den Konventionen oft \"Tricks\" versteckt, welche unter bestimmten Umst\u00e4nden Fehler verhindern k\u00f6nnen. Google beispielsweise ver\u00f6ffentlicht sehr gute Styleguides: Google Java Styleguide Google Python Styleguide","title":"Der Code folgt den Konventionen"},{"location":"module-1/structure/#der-code-enthalt-keinekaum-duplikate","text":"Duplikate / der gleiche Code mehrfach in der Applikation f\u00fchrt oft zu Problemen, da sich der Entwickler immer daran erinnern muss dass er eine \u00c4nderung an einer Stelle auch an allen anderen Stellen nachholen muss. Dies wird bei wachsender Code-Gr\u00f6\u00dfe zu einem immer schwierigeren Problem","title":"Der Code Enth\u00e4lt keine/kaum Duplikate"},{"location":"module-1/structure/#der-code-beinhaltet-whitespaces-fur-die-lesbarkeit","text":"Dicht aneinander geschriebener Code ohne jegliche Leerzeilen etc. ist f\u00fcr Menschen sehr schwer zu lesen. Gelegentliche Leerzeilen und Leerzeichen helfen. Der Code ist hierbei stehts konsistent!","title":"Der Code beinhaltet Whitespaces f\u00fcr die Lesbarkeit"},{"location":"module-1/structure/#der-code-ist-richtig-eingeruckt","text":"Richtiges Einr\u00fccken vom Code steigert die Lesbarkeit ungemein - und w\u00e4hrend es in Programmiersprachen wie Java \"nur\" der Lesbarkeit dient, wirkt sich das Einr\u00fccken vom Code in Sprachen wie Python sogar auf die gesamte Funktionalit\u00e4t aus!","title":"Der Code ist richtig einger\u00fcckt"},{"location":"module-1/structure/#aber-nicht-zu-oft-eingeruckt","text":"Ist ein Code sehr oft einger\u00fcckt, weil es viele IF Bedingungen gibt o\u00c4, so ist dies nicht nur schwierig zu lesen sondern auch mental sehr schwierig nachzuvollziehen. Eine Technik die sich in der Praxis gut bew\u00e4hrt hat um komplexe IF Szenarios zu vereinfachen ist das \"return early pattern\" Return Early Pattern","title":"... aber nicht zu oft einger\u00fcckt"},{"location":"module-1/structure/#der-code-beinhaltet-keine-magic-numbers","text":"Magic Numbers beschreiben Zahlen oder Werte im Code, die f\u00fcr einen Leser nicht direkt offensichtlich sind. Magic Numbers sollten mit der Hilfe von Konstanten oder \u00e4hnlichen Konstrukten weiter erkl\u00e4rt werden if(age >= 20) { executeCode(); } Besser: public static final int LEGAL_DRINKING_AGE_IN_JAPAN = 20; (...) if( age >= LEGAL_DRINKING_AGE_IN_JAPAN) { executeCode(); }","title":"Der Code beinhaltet keine Magic Numbers"},{"location":"module-1/structure/#der-code-kapselt-komplexe-logik","text":"Komplexe Logik (z.B. gro\u00dfe IF Abfragen) k\u00f6nnen sehr schwierig zu lesen und zu verstehen sein, wodurch sie auch den Code um sie herum beeinflussen kann und schwieriger zu supporten macht. Um dies etwas zu verbessern sollte komplexe Logik via \"Zwischen-Variablen\" oder am besten gleich in dedizierte Funktionen gekapselt werden. Nicht gut: if ( employee.age > 55 && employee.yearsEmplyed > 10 && employee.isRetired ) { // do something } Besser: bool eligibleForPension = employee.age > minRetirementAge && employee.yearEmployed > minPensionEmploymentYears && emplyee.isRetired ; Noch besser: private boolean isEligbleForPension(Employee employee) { return employee.age > minRetirementAge && employee.yearEmployed > minPensionEmploymentYears && emplyee.isRetired; } (...) if( isEligbleForPension(employee) ) { // do something }","title":"Der Code kapselt komplexe Logik"},{"location":"module-2/automated-formatters/","text":"","title":"Automated formatters"},{"location":"module-2/dependency-injection/","text":"","title":"Dependency injection"},{"location":"module-2/do-one-thing-well/","text":"","title":"Do one thing well"},{"location":"module-2/exception-handling/","text":"","title":"Exception handling"},{"location":"module-2/magic-numbers/","text":"","title":"Magic numbers"},{"location":"module-2/refactoring/","text":"","title":"Refactoring"},{"location":"module-2/testability/","text":"","title":"Testability"}]}