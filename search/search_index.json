{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"\"Clean Code\" - FDIBA - Winter Semester 2022 Liebe Studenten, in den kommenden Wochen werden wir zusammen erarbeiten was es bedeutet \"Clean Code\" zu schreiben. Wir werden hierbei analysieren was genau es bedeutet \"Clean Code\" zu produzieren und welche Voraussetzungen wir hierf\u00fcr erf\u00fcllen m\u00fcssen. Diese Dokumentation hierbei wird eine \"living documentation\" sein. Das bedeutet, sie wird kontinuierlich erweitert und auf agile Art und Weise nach und nach verbessert. Um nicht st\u00e4ndig das Rad neu zu erfinden werden wir viele existierenden Quelle nutzen und verlinken.","title":"Home"},{"location":"#clean-code-fdiba-winter-semester-2022","text":"Liebe Studenten, in den kommenden Wochen werden wir zusammen erarbeiten was es bedeutet \"Clean Code\" zu schreiben. Wir werden hierbei analysieren was genau es bedeutet \"Clean Code\" zu produzieren und welche Voraussetzungen wir hierf\u00fcr erf\u00fcllen m\u00fcssen. Diese Dokumentation hierbei wird eine \"living documentation\" sein. Das bedeutet, sie wird kontinuierlich erweitert und auf agile Art und Weise nach und nach verbessert. Um nicht st\u00e4ndig das Rad neu zu erfinden werden wir viele existierenden Quelle nutzen und verlinken.","title":"\"Clean Code\" - FDIBA - Winter Semester 2022"},{"location":"about/","text":"\u00dcber uns Klaus Riedel - der Agile Transformer Im Bereich agile Transformation gibt es wohl nichts, was Klaus nicht schon gesehen hat. \u00dcber 10 Jahre agile Transformationen in Organisationen wie Deutsche Bahn, Lufthansa, Microsoft, Bosch, Conrad Electronics, Bank of Scotland, Deutsche Bank und einige mehr lassen agile Transformationen leicht aussehen. Seit etwas \u00fcber 10 Jahren ist er als Mitgr\u00fcnder und Partner der Unternehmens Blubito als CEO t\u00e4tig und \u00fcbernimmt hierbei rund um die Organisation, Sales und Marketing. Klaus unterrichtet \u201eAgiles Projektmanagement\u201c sowie \"Clean Code\" an der TU Sofia, ist Autor des Blubito Blogs f\u00fcr agile Softwareentwicklung und des runScrum Blogs \u00fcber agiles Projektmanagement und betreut mehrere Teams als Product Owner. Jan Br\u00fcggmann - der Tech Guru Jan begann mit 14 Jahren Software zu entwickeln und hat in den ca. 25 Jahren seitdem eigentlich auch nie etwas anderes getan oder gelernt. Seine professionelle Karriere began mit Anfang 20 als IT-Berater f\u00fcr diverse deutsche Unternehmen, von Airlines bis hin zu Banken und der Immobilienwirtschaft. Seit etwas \u00fcber 10 Jahren ist er als Mitgr\u00fcnder und Partner der Unternehmens Blubito als CTO t\u00e4tig und \u00fcbernimmt hierbei alles um Technik, Ausbildung und Recruiting. Jan unterrichtet \"Clean Code\" an der TU Sofia und unterst\u00fctzt viele Kollegen als auch Kunden bei der L\u00f6sung diverser technischen Probleme. G\u00e4ste Sp\u00e4ter mehr...","title":"\u00dcber uns"},{"location":"about/#uber-uns","text":"","title":"\u00dcber uns"},{"location":"about/#klaus-riedel-der-agile-transformer","text":"Im Bereich agile Transformation gibt es wohl nichts, was Klaus nicht schon gesehen hat. \u00dcber 10 Jahre agile Transformationen in Organisationen wie Deutsche Bahn, Lufthansa, Microsoft, Bosch, Conrad Electronics, Bank of Scotland, Deutsche Bank und einige mehr lassen agile Transformationen leicht aussehen. Seit etwas \u00fcber 10 Jahren ist er als Mitgr\u00fcnder und Partner der Unternehmens Blubito als CEO t\u00e4tig und \u00fcbernimmt hierbei rund um die Organisation, Sales und Marketing. Klaus unterrichtet \u201eAgiles Projektmanagement\u201c sowie \"Clean Code\" an der TU Sofia, ist Autor des Blubito Blogs f\u00fcr agile Softwareentwicklung und des runScrum Blogs \u00fcber agiles Projektmanagement und betreut mehrere Teams als Product Owner.","title":"Klaus Riedel - der Agile Transformer"},{"location":"about/#jan-bruggmann-der-tech-guru","text":"Jan begann mit 14 Jahren Software zu entwickeln und hat in den ca. 25 Jahren seitdem eigentlich auch nie etwas anderes getan oder gelernt. Seine professionelle Karriere began mit Anfang 20 als IT-Berater f\u00fcr diverse deutsche Unternehmen, von Airlines bis hin zu Banken und der Immobilienwirtschaft. Seit etwas \u00fcber 10 Jahren ist er als Mitgr\u00fcnder und Partner der Unternehmens Blubito als CTO t\u00e4tig und \u00fcbernimmt hierbei alles um Technik, Ausbildung und Recruiting. Jan unterrichtet \"Clean Code\" an der TU Sofia und unterst\u00fctzt viele Kollegen als auch Kunden bei der L\u00f6sung diverser technischen Probleme.","title":"Jan Br\u00fcggmann - der Tech Guru"},{"location":"about/#gaste","text":"Sp\u00e4ter mehr...","title":"G\u00e4ste"},{"location":"module-1/comments/","text":"Das Problem mit den Kommentaren im Code... Kommentare im Code werden von verschiedenen Personen und Organisatione sehr unterschiedlich betrachtet und es gibt keine wirklich 100% einheitliche L\u00f6sung wie man mit Kommentaren im Code umgehen soll. Viele Organisationen erwarten von ihren Entwicklern, dass der gesamte Code kommentiert ist und die Kommentare selbst die Funktionalit\u00e4t als auch die Beziehungen des Codes selbst klar beschreiben. Dies ist vor allem in Organisationen der Fall in denen Richtlinien vorrangig von Personen etabliert werden, die selbst nur wenig Erfahrung mit dem Schreiben von Software haben. Dem gegen\u00fcber stehen die Puristen, welche die Meinung vertreten Kommentare sind im besten Fall nutzlos, im schlimmsten Fall sogar st\u00f6rend und verschlechtern die Verst\u00e4ndlichkeit von Code. Kommentare aus der Sicht des Clean Code Aus der Perspektive des \"Clean Code\" sollten Kommentare m\u00f6glichst selten genutzt werden. Kommentare sollten vor allem dann eingesetzt werden, wenn im Code etwas passiert was nicht durch den Code selbst erkl\u00e4rt werden kann - dies bezieht sich also vor allem auf die Fragen wie \"WARUM tut der Code das, was er hier tut?\" Kommentare die den Zweck haben zu erkl\u00e4ren WAS der Code selbst tut sind in fast allen F\u00e4llen eher ein Zeichen daf\u00fcr, dass der Code selbst zu kompliziert ist und \u00fcberarbeitet werden sollte. Mit besseren Namen und Vereinfachung des Codes selbst, k\u00f6nnen fast alle solcher Kommentare \u00fcberfl\u00fcssig gemacht werden. In Ausnahmef\u00e4llen k\u00f6nnen Kommentare n\u00fctzlich sein um Code zu erkl\u00e4ren, der sehr schwierig zu verstehen ist aber leider nicht weiter vereinfacht werden kann. Dies ist oft der Fall bei Dinge die Regul\u00e4ren Ausdr\u00fccken (RegEx) Die Gefahr der Kommentar Jeder Kommentar der geschrieben wird, muss stets geupdated werden wenn sich die Funktion auf die er sich bezieht \u00e4ndert. Dies ist nur ein kleines Problem bei wenigen Kommentaren die sich vorrangig um das \"WARUM\" k\u00fcmmern - kann jedoch zu einem sehr gro\u00dfen Problem werden wenn diese Regel nicht eingehalten wird. Jeder Entwickler kommt in seiner Karriere einmal an den Punkt dass er auf ein Problem st\u00f6sst dass er partout nicht l\u00f6sen kann, trotz viel Zeit und Arbeit - nur um dann Tage sp\u00e4ter zu bemerken dass die Kommentare die den Code beschrieben haben den er nutzt, nicht mehr mit der eigentlichen Implementation \u00fcbereinstimmen. Irgendwann wurde vergessen bei einer \u00c4nderung die Kommentare mit zu aktualisieren. Beispiele f\u00fcr gute Kommentare // Matches a Dutch zipcode, eg, '1974 XA' or '4844RA' Pattern DUTCH_ZIPCODE = Pattern.compile(\"[1-9][0-9]{3} ?[A-Z]{2}\"); int resultCode = ...; boolean isSucess = resultCode == 200; boolean isTemporaryError = resultCode == 503 || resultCode == 504; // Sometime we receive a temporary error. // However, in all cases which were researched, results were successfully stored. // Because of this we will return true in that case. return (isSucess || isTemporaryError); Anti-Patterns Danke, Captain Obvious // numeric session-id int sessionId = 0; // expiry date Date expiry = new Date(); // numeric session-id int sessionTimeoutInSeconds = 3600; // resets session-id to 99; function reset() { sessionId = 99; } Erkl\u00e4rt unklaren Code // timeout in seconds int timeout = 5; // <---- nicht gut int timeoutInSeconds = 5; // <---- besser // if during work hours if (currentTime.hours >= 9 && currentTime.hours <= 17) // <---- nicht gut if (isDuringWorkingHours(currentTime)) // <---- besser Auskommentierter Code Entwickler neigen vor allem am Anfang ihrer Karriere dazu Code auszukommentieren aus Angst ihn zu verlieren und dann sp\u00e4ter noch eimal zu brauchen. Dieses \"Feature\" ist gut gemeint, f\u00fchrt aber vor allem zu aufgebl\u00e4htem und schwer lesbaren Code - und wird so gut wie nie wirklich gebraucht. Zudem ist das Ziel selbst schon vom Source Control System erf\u00fcllt, denn hier kann auch gel\u00f6schter Code notfalls wieder hergestellt werden. Quellen https://www.baeldung.com/cs/clean-code-comments https://medium.com/codex/clean-code-comments-833e11a706dc","title":"Kommentare"},{"location":"module-1/comments/#das-problem-mit-den-kommentaren-im-code","text":"Kommentare im Code werden von verschiedenen Personen und Organisatione sehr unterschiedlich betrachtet und es gibt keine wirklich 100% einheitliche L\u00f6sung wie man mit Kommentaren im Code umgehen soll. Viele Organisationen erwarten von ihren Entwicklern, dass der gesamte Code kommentiert ist und die Kommentare selbst die Funktionalit\u00e4t als auch die Beziehungen des Codes selbst klar beschreiben. Dies ist vor allem in Organisationen der Fall in denen Richtlinien vorrangig von Personen etabliert werden, die selbst nur wenig Erfahrung mit dem Schreiben von Software haben. Dem gegen\u00fcber stehen die Puristen, welche die Meinung vertreten Kommentare sind im besten Fall nutzlos, im schlimmsten Fall sogar st\u00f6rend und verschlechtern die Verst\u00e4ndlichkeit von Code.","title":"Das Problem mit den Kommentaren im Code..."},{"location":"module-1/comments/#kommentare-aus-der-sicht-des-clean-code","text":"Aus der Perspektive des \"Clean Code\" sollten Kommentare m\u00f6glichst selten genutzt werden. Kommentare sollten vor allem dann eingesetzt werden, wenn im Code etwas passiert was nicht durch den Code selbst erkl\u00e4rt werden kann - dies bezieht sich also vor allem auf die Fragen wie \"WARUM tut der Code das, was er hier tut?\" Kommentare die den Zweck haben zu erkl\u00e4ren WAS der Code selbst tut sind in fast allen F\u00e4llen eher ein Zeichen daf\u00fcr, dass der Code selbst zu kompliziert ist und \u00fcberarbeitet werden sollte. Mit besseren Namen und Vereinfachung des Codes selbst, k\u00f6nnen fast alle solcher Kommentare \u00fcberfl\u00fcssig gemacht werden. In Ausnahmef\u00e4llen k\u00f6nnen Kommentare n\u00fctzlich sein um Code zu erkl\u00e4ren, der sehr schwierig zu verstehen ist aber leider nicht weiter vereinfacht werden kann. Dies ist oft der Fall bei Dinge die Regul\u00e4ren Ausdr\u00fccken (RegEx)","title":"Kommentare aus der Sicht des Clean Code"},{"location":"module-1/comments/#die-gefahr-der-kommentar","text":"Jeder Kommentar der geschrieben wird, muss stets geupdated werden wenn sich die Funktion auf die er sich bezieht \u00e4ndert. Dies ist nur ein kleines Problem bei wenigen Kommentaren die sich vorrangig um das \"WARUM\" k\u00fcmmern - kann jedoch zu einem sehr gro\u00dfen Problem werden wenn diese Regel nicht eingehalten wird. Jeder Entwickler kommt in seiner Karriere einmal an den Punkt dass er auf ein Problem st\u00f6sst dass er partout nicht l\u00f6sen kann, trotz viel Zeit und Arbeit - nur um dann Tage sp\u00e4ter zu bemerken dass die Kommentare die den Code beschrieben haben den er nutzt, nicht mehr mit der eigentlichen Implementation \u00fcbereinstimmen. Irgendwann wurde vergessen bei einer \u00c4nderung die Kommentare mit zu aktualisieren.","title":"Die Gefahr der Kommentar"},{"location":"module-1/comments/#beispiele-fur-gute-kommentare","text":"// Matches a Dutch zipcode, eg, '1974 XA' or '4844RA' Pattern DUTCH_ZIPCODE = Pattern.compile(\"[1-9][0-9]{3} ?[A-Z]{2}\"); int resultCode = ...; boolean isSucess = resultCode == 200; boolean isTemporaryError = resultCode == 503 || resultCode == 504; // Sometime we receive a temporary error. // However, in all cases which were researched, results were successfully stored. // Because of this we will return true in that case. return (isSucess || isTemporaryError);","title":"Beispiele f\u00fcr gute Kommentare"},{"location":"module-1/comments/#anti-patterns","text":"","title":"Anti-Patterns"},{"location":"module-1/comments/#danke-captain-obvious","text":"// numeric session-id int sessionId = 0; // expiry date Date expiry = new Date(); // numeric session-id int sessionTimeoutInSeconds = 3600; // resets session-id to 99; function reset() { sessionId = 99; }","title":"Danke, Captain Obvious"},{"location":"module-1/comments/#erklart-unklaren-code","text":"// timeout in seconds int timeout = 5; // <---- nicht gut int timeoutInSeconds = 5; // <---- besser // if during work hours if (currentTime.hours >= 9 && currentTime.hours <= 17) // <---- nicht gut if (isDuringWorkingHours(currentTime)) // <---- besser","title":"Erkl\u00e4rt unklaren Code"},{"location":"module-1/comments/#auskommentierter-code","text":"Entwickler neigen vor allem am Anfang ihrer Karriere dazu Code auszukommentieren aus Angst ihn zu verlieren und dann sp\u00e4ter noch eimal zu brauchen. Dieses \"Feature\" ist gut gemeint, f\u00fchrt aber vor allem zu aufgebl\u00e4htem und schwer lesbaren Code - und wird so gut wie nie wirklich gebraucht. Zudem ist das Ziel selbst schon vom Source Control System erf\u00fcllt, denn hier kann auch gel\u00f6schter Code notfalls wieder hergestellt werden.","title":"Auskommentierter Code"},{"location":"module-1/comments/#quellen","text":"https://www.baeldung.com/cs/clean-code-comments https://medium.com/codex/clean-code-comments-833e11a706dc","title":"Quellen"},{"location":"module-1/debugging/","text":"Was ist Debugging? Debugging beschreibt die T\u00e4tigkeit ein Computerprogramm von einem technischen- oder inhaltlichen Fehler zu befreien. W\u00e4hrend das Debuggen selbst eigentlich keinen direkten Bezug zu Clean Code hat, so beeinflussen sich beide doch massiv. Je \"sauberer\" der Code ist, desto eher besteht die Chance dass wir einen Bug noch w\u00e4hrend der Entwicklung entdecken. Zudem tr\u00e4gt gut strukturierter Code ungemein dazu bei, dass wir im Falle eines Problems in der Lage sind schnell die Ursache des Problems zu identifizieren und eine L\u00f6sung zu implementieren. Hierbei k\u00f6nnen uns mehrere Dinge von Nutzen sein: Logging Logging beschreibt die Ausgabe von zus\u00e4tzlichen Informationen die nicht f\u00fcr den Endnutzer bestimmt sind. Log-Statements werden hierbei in der Regel in die Console ausgegeben oder zur sp\u00e4teren Analyse an ein externes System gesendet wie beispielsweise eine Datei auf der Festplatte oder ein zentrales Logging-Tool in der Cloud. Hierbei sind folgende Punkte wichtig: Log Statements sollten hierbei die Informationen beinhalten, die sp\u00e4ter zur L\u00f6sung von Problemen tats\u00e4chlich n\u00fctzlich sind. \"Ein Fehler ist aufgetreten!\" hilft niemandem. \"Zeile 50 der Buchungs-Datei bookings-2022.csv konnte nicht vollst\u00e4ndig gelesen werden\" gibt einem Entwickler aber einen guten ersten Ansatz f\u00fcr die Fehlersuche. Die Menge an geschriebenen Log-Statements sollte \u00fcber sogenannte \"Log Levels\" anpassbar sein - denn w\u00e4hrend wir w\u00e4hrend der Entwicklung oft m\u00f6glichst viel Informationen auch von absolut erfolgreichen Events sehen wollen, so ist dies im produktiven Betrieb oft zu verwirrend. Hier wollen wir wom\u00f6glich nur \u00fcber kritische Fehler informiert werden. Logs d\u00fcrfen auf keinen Fall pers\u00f6nliche oder sicherheitskritische Informationen beinhalten - dies gilt vor allem f\u00fcr Dinge wie Kreditkarten-Nummern etc. Debugger Tools Debugger Tools sind Dinge mit denen ein Entwickler in der Lage ist eine Applikation w\u00e4hrend ihrer Ausf\u00fchrung zu pausieren und den internen Zustand der Applikation auszuwerten oder sogar zu ver\u00e4ndern. Der Punkt an dem die Applikation pausieren soll wird in der Regel \u00fcber sogenannte \"Breakpoints\" im Code definiert. Definiere ich beispielsweise einen Breakpoint innerhalb meiner doSomething() Funktion, so wird meine Applikation bei Erreichen von genau dieser Codezeile stoppen und ich kann damit beginnen die Werte von Variablen zu betrachten oder zu ver\u00e4ndern. Je nach Programmiersprache und -Umgebung kommen als Debugger-Tools verschiedene Applikationen zum Einsatz. F\u00fcr Java-Applikationen beispielsweise ist es in der Regel die IDE wie IntelliJ oder Eclipse welche die Debugger-Tools zur Verf\u00fcgung stellt, wodurch ein Entwickler seine gewohnte Umgebung gar nicht erst verlassen muss. F\u00fcr web-basierte Applikationen auf Basis von JavaScript, welche in der Regel im Browser ausgef\u00fchrt werden, bieten alle modernen Browser wie Chrome, Firefox und Safari ihre eigenen Entwickler-Tools mit Debugging Funktionalit\u00e4ten. Eclipse Debugger View","title":"Debugging"},{"location":"module-1/debugging/#was-ist-debugging","text":"Debugging beschreibt die T\u00e4tigkeit ein Computerprogramm von einem technischen- oder inhaltlichen Fehler zu befreien. W\u00e4hrend das Debuggen selbst eigentlich keinen direkten Bezug zu Clean Code hat, so beeinflussen sich beide doch massiv. Je \"sauberer\" der Code ist, desto eher besteht die Chance dass wir einen Bug noch w\u00e4hrend der Entwicklung entdecken. Zudem tr\u00e4gt gut strukturierter Code ungemein dazu bei, dass wir im Falle eines Problems in der Lage sind schnell die Ursache des Problems zu identifizieren und eine L\u00f6sung zu implementieren. Hierbei k\u00f6nnen uns mehrere Dinge von Nutzen sein:","title":"Was ist Debugging?"},{"location":"module-1/debugging/#logging","text":"Logging beschreibt die Ausgabe von zus\u00e4tzlichen Informationen die nicht f\u00fcr den Endnutzer bestimmt sind. Log-Statements werden hierbei in der Regel in die Console ausgegeben oder zur sp\u00e4teren Analyse an ein externes System gesendet wie beispielsweise eine Datei auf der Festplatte oder ein zentrales Logging-Tool in der Cloud. Hierbei sind folgende Punkte wichtig: Log Statements sollten hierbei die Informationen beinhalten, die sp\u00e4ter zur L\u00f6sung von Problemen tats\u00e4chlich n\u00fctzlich sind. \"Ein Fehler ist aufgetreten!\" hilft niemandem. \"Zeile 50 der Buchungs-Datei bookings-2022.csv konnte nicht vollst\u00e4ndig gelesen werden\" gibt einem Entwickler aber einen guten ersten Ansatz f\u00fcr die Fehlersuche. Die Menge an geschriebenen Log-Statements sollte \u00fcber sogenannte \"Log Levels\" anpassbar sein - denn w\u00e4hrend wir w\u00e4hrend der Entwicklung oft m\u00f6glichst viel Informationen auch von absolut erfolgreichen Events sehen wollen, so ist dies im produktiven Betrieb oft zu verwirrend. Hier wollen wir wom\u00f6glich nur \u00fcber kritische Fehler informiert werden. Logs d\u00fcrfen auf keinen Fall pers\u00f6nliche oder sicherheitskritische Informationen beinhalten - dies gilt vor allem f\u00fcr Dinge wie Kreditkarten-Nummern etc.","title":"Logging"},{"location":"module-1/debugging/#debugger-tools","text":"Debugger Tools sind Dinge mit denen ein Entwickler in der Lage ist eine Applikation w\u00e4hrend ihrer Ausf\u00fchrung zu pausieren und den internen Zustand der Applikation auszuwerten oder sogar zu ver\u00e4ndern. Der Punkt an dem die Applikation pausieren soll wird in der Regel \u00fcber sogenannte \"Breakpoints\" im Code definiert. Definiere ich beispielsweise einen Breakpoint innerhalb meiner doSomething() Funktion, so wird meine Applikation bei Erreichen von genau dieser Codezeile stoppen und ich kann damit beginnen die Werte von Variablen zu betrachten oder zu ver\u00e4ndern. Je nach Programmiersprache und -Umgebung kommen als Debugger-Tools verschiedene Applikationen zum Einsatz. F\u00fcr Java-Applikationen beispielsweise ist es in der Regel die IDE wie IntelliJ oder Eclipse welche die Debugger-Tools zur Verf\u00fcgung stellt, wodurch ein Entwickler seine gewohnte Umgebung gar nicht erst verlassen muss. F\u00fcr web-basierte Applikationen auf Basis von JavaScript, welche in der Regel im Browser ausgef\u00fchrt werden, bieten alle modernen Browser wie Chrome, Firefox und Safari ihre eigenen Entwickler-Tools mit Debugging Funktionalit\u00e4ten.","title":"Debugger Tools"},{"location":"module-1/debugging/#eclipse-debugger-view","text":"","title":"Eclipse Debugger View"},{"location":"module-1/exercise/","text":"Aufgabe zum Modul 1 Aufgabe Git installieren Github Repository erstellen Euer Repository von Github clonen Erstellt einen neuen Branch in eurem Repository Erstellt ein neues Java Projekt in diesem Branch (\"Feature Branch\") Die Applikation sollte folgende Funktionalit\u00e4t erf\u00fcllen Es k\u00f6nnen 1 oder mehrere Zahlen \u00fcber die Kommandozeile eingegeben werden Nachdem 1 oder mehrere Zahlen eingegeben wurden, kann uns die App den Durchschnitt dieser Zahlen nennen Falsche Eingaben werden abgefangen und mit einer guten Fehlermeldung abgelehnt Der Code ist \"clean\" entsprechend der Clean Code Definitionen Erstellt einen Merge Request von eurem Feature Branch in den Main Branch","title":"Aufgaben"},{"location":"module-1/exercise/#aufgabe-zum-modul-1","text":"","title":"Aufgabe zum Modul 1"},{"location":"module-1/exercise/#aufgabe","text":"Git installieren Github Repository erstellen Euer Repository von Github clonen Erstellt einen neuen Branch in eurem Repository Erstellt ein neues Java Projekt in diesem Branch (\"Feature Branch\") Die Applikation sollte folgende Funktionalit\u00e4t erf\u00fcllen Es k\u00f6nnen 1 oder mehrere Zahlen \u00fcber die Kommandozeile eingegeben werden Nachdem 1 oder mehrere Zahlen eingegeben wurden, kann uns die App den Durchschnitt dieser Zahlen nennen Falsche Eingaben werden abgefangen und mit einer guten Fehlermeldung abgelehnt Der Code ist \"clean\" entsprechend der Clean Code Definitionen Erstellt einen Merge Request von eurem Feature Branch in den Main Branch","title":"Aufgabe"},{"location":"module-1/git/","text":"Was ist Source Control? Source Control beschreibt die Versionierung von Source Code, also das Speichern aller Code-Dateien zu einem bestimmten Zeitpunkt. Das Source Control System hat hierbei die Aufgabe sicherzustellen, dass ein Nutzer auch sp\u00e4ter zu einer fr\u00fcheren Version seines Source Codes zur\u00fcckkehren kann - etwa um zu Vergleichen was sich ge\u00e4ndert hat oder um komplett auf eine fr\u00fchere Version zur\u00fcckzukehren. Was hat Source Control mit Clean Code zu tun? Ohne Source Control ist es sehr schwierig Source Code \u00fcber eine lange Zeit sauber und wartbar zu halten. Entwickler verlieren die \u00dcbersicht dar\u00fcber wann, von wem welche \u00c4nderung gemacht worden ist, was vor allem dann zu Problemen f\u00fchrt wenn mehrere Entwickler am gleichen Projekt arbeiten. Beim Austausch von Code zwischen Entwicklern wird es sehr schwierig nachzuvollziehen welche Datei ge\u00e4ndert worden ist und ob sich hieraus vielleicht Probleme ergeben, weil der neue Code von Entwickler A nicht zum neuen Code von Entwickler B passt. Ein Source Control System hilft dabei einen Code sauber und kompatibel zu behalten - auch wenn es weiterhin an den Entwicklern liegt, dies alles sicherzustellen. Was ist Git? Git ist das Source Control System das sich als de facto Standard in der gesamten IT Welt durchgesetzt hat. Es ist hierbei ein sogenanntes Distributed Source Control System, d.h. jeder Client (meistens Entwickler-Computer) h\u00e4lt die gesamte Historie und den gesamten Source Code des Projekts. Jedes \"Commit\" vom Code und jeder \"Push\" zu einem anderen Client \u00fcbertr\u00e4gt hierbei widerum die gesamten letzten \u00c4nderungen, nicht nur den finalen/aktuellen Stand. Commit, Push...? Die folgenden Begriffe beschreiben die Haupt-Funktionalit\u00e4ten von Git (sowieso eigentlich auch jedes anderen Source Control Systems). Eine kurze offizielle Einf\u00fchrung zu Git findet ihr hier Eine detailliertere Referenz zu Git befindet sich hier Repository Ein Git Repository ist eine Menge an Dateien die in Git verwaltet werden. Ein Repository besteht hierbei aus den Dateien selbst, mehreren Branches (d.h. parallelen Versionen) sowie der Historie/den \u00c4nderungen \u00fcber die Zeit. Clone Das Clonen eines Projekts ist das erste \"Downloaden\" eines Git Repositories auf die lokale Workstation, in der Regel vom zentralen Repository. Pull Ein Git Pull ist das \"Downloaden\" von allen \u00c4nderungen die im zentralen Repository seit dem letzten Git Pull passiert sind. Branch Branches beschreiben parallele Bearbeitungs-St\u00e4nde innerhalb eines Git Repositories. Ein Beispiel hierbei w\u00e4re ein Projekt mit 2 Entwicklern. Jeder Entwickler arbeitet an unterschiedlichen Features - aber sie m\u00fcssen beide gleichzeitig die gleichen Dateien ver\u00e4ndern. Um also nicht st\u00e4ndig Probleme mit den \u00c4nderungen des jeweils anderen Enwicklers zu bekommen startet jeder der Entwickler einen sogenannten \"Branch\". Solange er auf diesem Branch arbeitet, kann er jederzeit alle Dateien \u00e4ndern aber der jeweils andere Entwickler sieht keine dieser \u00c4nderungen. Erst wenn sein Branch zur\u00fcck in den Haupt-Branch \"gemerged\" wird, werden seine \u00c4nderungen f\u00fcr alle anderen sichtbar. Beim Branching entstehen sehr oft \"Merge Conflicts\", d.h. Probleme die daraus entstehen dass die gleiche Dateien in verschiedenen Branches ver\u00e4ndert worden sind. Um dies zu reparieren muss in der Regel ein Entwickler beide Code-Versionen vergleichen und diese Zusammenf\u00fchren. Je l\u00e4nger kein Merge stattgefunden hat, desto schwieriger wird das Mergen - es ist daher extrem wichtig so fr\u00fch wie m\u00f6glich einen Merge durchzuf\u00fchren und einen Branch wieder zu l\u00f6schen. Zudem sollten regelm\u00e4ssig die letzten \u00c4nderungen vom Haupt-Branch \u00fcbernommen werden. Commit Ein Commit ist das Abspeichern von einem Code-Stand zu einem bestimmten Zeitpunkt. Ein Commit beinhaltet normalerweise 1..n Dateien zusammen mit einer Commit Message, welche die \u00c4nderung beschreibt. Es ist bei einem Commit wichtig mit allen Entwicklern eine gemeinsame Konvention zu etablieren, wie Commit-Messages verfasst werden sollen. In der Regel beinhalten Commit-Messages daher oft die ID des Work Items zu dem diese \u00c4nderung geh\u00f6rt zusammen mit einer kurzen Beschreibung der eigentlichen \u00c4nderung. git commit -m \"bug/123 Fixed validation logic for german zip codes\" Add/Stage Beim \"Adden\" einer Datei nehmen wir sie in die Versionierung durch Git in diesem Repository mit auf. Bevor eine Datei geaddet wurde, werden ihre verschiedenen Versionsst\u00e4nde von Git ignoriert und nicht mit gespeichert. Beim Stagen markieren wir eine \u00c4nderung an einer Datei so, dass wir sie beim n\u00e4chsten Commit mit \"committen\" wollen. Wenn eine \u00c4nderung nicht \"gestaged\" wurde, dann wird sie in der Regel bei einem Commit ignoriert. Es k\u00f6nnen nur \u00c4nderung von bereits \"geaddeten\" Dateien gestaged werden. Push Ein Push \u00fcbertr\u00e4gt lokale \u00c4nderung (durch Commits) an ein anderes Git System, ein sogenanntes \"Remote\". Dies k\u00f6nnten theoretisch auch andere Entwickler Computer sein, in der Praxis hat sich aber etabliert dies an ein zentrales Repository zu senden, zu dem jeder Entwickler Zugriff hat. In den meisten F\u00e4llen wird dies ein System wie Github, Gitlab, Azure DevOps etc. sein. git push origin master .gitignore File Das .gitignore File in einem Projekt beschreibt die Dateien, die nicht mit in das Repository commited werden sollen. Dies sind in der Regel vor allem Dateien die immer wieder automatisch generiert werde (Builds) Secrets enthalten (z.B. Passw\u00f6rter, Secrets) Ein einfaches Beispiel git init git add . git commit -am \"First commit\" git remote add origin git@github.com:your_github_user/myapplication.git -- Change/write README.md and .gitignore files git pull origin main -- Send the entire application to Github git push origin main","title":"Git"},{"location":"module-1/git/#was-ist-source-control","text":"Source Control beschreibt die Versionierung von Source Code, also das Speichern aller Code-Dateien zu einem bestimmten Zeitpunkt. Das Source Control System hat hierbei die Aufgabe sicherzustellen, dass ein Nutzer auch sp\u00e4ter zu einer fr\u00fcheren Version seines Source Codes zur\u00fcckkehren kann - etwa um zu Vergleichen was sich ge\u00e4ndert hat oder um komplett auf eine fr\u00fchere Version zur\u00fcckzukehren.","title":"Was ist Source Control?"},{"location":"module-1/git/#was-hat-source-control-mit-clean-code-zu-tun","text":"Ohne Source Control ist es sehr schwierig Source Code \u00fcber eine lange Zeit sauber und wartbar zu halten. Entwickler verlieren die \u00dcbersicht dar\u00fcber wann, von wem welche \u00c4nderung gemacht worden ist, was vor allem dann zu Problemen f\u00fchrt wenn mehrere Entwickler am gleichen Projekt arbeiten. Beim Austausch von Code zwischen Entwicklern wird es sehr schwierig nachzuvollziehen welche Datei ge\u00e4ndert worden ist und ob sich hieraus vielleicht Probleme ergeben, weil der neue Code von Entwickler A nicht zum neuen Code von Entwickler B passt. Ein Source Control System hilft dabei einen Code sauber und kompatibel zu behalten - auch wenn es weiterhin an den Entwicklern liegt, dies alles sicherzustellen.","title":"Was hat Source Control mit Clean Code zu tun?"},{"location":"module-1/git/#was-ist-git","text":"Git ist das Source Control System das sich als de facto Standard in der gesamten IT Welt durchgesetzt hat. Es ist hierbei ein sogenanntes Distributed Source Control System, d.h. jeder Client (meistens Entwickler-Computer) h\u00e4lt die gesamte Historie und den gesamten Source Code des Projekts. Jedes \"Commit\" vom Code und jeder \"Push\" zu einem anderen Client \u00fcbertr\u00e4gt hierbei widerum die gesamten letzten \u00c4nderungen, nicht nur den finalen/aktuellen Stand.","title":"Was ist Git?"},{"location":"module-1/git/#commit-push","text":"Die folgenden Begriffe beschreiben die Haupt-Funktionalit\u00e4ten von Git (sowieso eigentlich auch jedes anderen Source Control Systems). Eine kurze offizielle Einf\u00fchrung zu Git findet ihr hier Eine detailliertere Referenz zu Git befindet sich hier","title":"Commit, Push...?"},{"location":"module-1/git/#repository","text":"Ein Git Repository ist eine Menge an Dateien die in Git verwaltet werden. Ein Repository besteht hierbei aus den Dateien selbst, mehreren Branches (d.h. parallelen Versionen) sowie der Historie/den \u00c4nderungen \u00fcber die Zeit.","title":"Repository"},{"location":"module-1/git/#clone","text":"Das Clonen eines Projekts ist das erste \"Downloaden\" eines Git Repositories auf die lokale Workstation, in der Regel vom zentralen Repository.","title":"Clone"},{"location":"module-1/git/#pull","text":"Ein Git Pull ist das \"Downloaden\" von allen \u00c4nderungen die im zentralen Repository seit dem letzten Git Pull passiert sind.","title":"Pull"},{"location":"module-1/git/#branch","text":"Branches beschreiben parallele Bearbeitungs-St\u00e4nde innerhalb eines Git Repositories. Ein Beispiel hierbei w\u00e4re ein Projekt mit 2 Entwicklern. Jeder Entwickler arbeitet an unterschiedlichen Features - aber sie m\u00fcssen beide gleichzeitig die gleichen Dateien ver\u00e4ndern. Um also nicht st\u00e4ndig Probleme mit den \u00c4nderungen des jeweils anderen Enwicklers zu bekommen startet jeder der Entwickler einen sogenannten \"Branch\". Solange er auf diesem Branch arbeitet, kann er jederzeit alle Dateien \u00e4ndern aber der jeweils andere Entwickler sieht keine dieser \u00c4nderungen. Erst wenn sein Branch zur\u00fcck in den Haupt-Branch \"gemerged\" wird, werden seine \u00c4nderungen f\u00fcr alle anderen sichtbar. Beim Branching entstehen sehr oft \"Merge Conflicts\", d.h. Probleme die daraus entstehen dass die gleiche Dateien in verschiedenen Branches ver\u00e4ndert worden sind. Um dies zu reparieren muss in der Regel ein Entwickler beide Code-Versionen vergleichen und diese Zusammenf\u00fchren. Je l\u00e4nger kein Merge stattgefunden hat, desto schwieriger wird das Mergen - es ist daher extrem wichtig so fr\u00fch wie m\u00f6glich einen Merge durchzuf\u00fchren und einen Branch wieder zu l\u00f6schen. Zudem sollten regelm\u00e4ssig die letzten \u00c4nderungen vom Haupt-Branch \u00fcbernommen werden.","title":"Branch"},{"location":"module-1/git/#commit","text":"Ein Commit ist das Abspeichern von einem Code-Stand zu einem bestimmten Zeitpunkt. Ein Commit beinhaltet normalerweise 1..n Dateien zusammen mit einer Commit Message, welche die \u00c4nderung beschreibt. Es ist bei einem Commit wichtig mit allen Entwicklern eine gemeinsame Konvention zu etablieren, wie Commit-Messages verfasst werden sollen. In der Regel beinhalten Commit-Messages daher oft die ID des Work Items zu dem diese \u00c4nderung geh\u00f6rt zusammen mit einer kurzen Beschreibung der eigentlichen \u00c4nderung. git commit -m \"bug/123 Fixed validation logic for german zip codes\"","title":"Commit"},{"location":"module-1/git/#addstage","text":"Beim \"Adden\" einer Datei nehmen wir sie in die Versionierung durch Git in diesem Repository mit auf. Bevor eine Datei geaddet wurde, werden ihre verschiedenen Versionsst\u00e4nde von Git ignoriert und nicht mit gespeichert. Beim Stagen markieren wir eine \u00c4nderung an einer Datei so, dass wir sie beim n\u00e4chsten Commit mit \"committen\" wollen. Wenn eine \u00c4nderung nicht \"gestaged\" wurde, dann wird sie in der Regel bei einem Commit ignoriert. Es k\u00f6nnen nur \u00c4nderung von bereits \"geaddeten\" Dateien gestaged werden.","title":"Add/Stage"},{"location":"module-1/git/#push","text":"Ein Push \u00fcbertr\u00e4gt lokale \u00c4nderung (durch Commits) an ein anderes Git System, ein sogenanntes \"Remote\". Dies k\u00f6nnten theoretisch auch andere Entwickler Computer sein, in der Praxis hat sich aber etabliert dies an ein zentrales Repository zu senden, zu dem jeder Entwickler Zugriff hat. In den meisten F\u00e4llen wird dies ein System wie Github, Gitlab, Azure DevOps etc. sein. git push origin master","title":"Push"},{"location":"module-1/git/#gitignore-file","text":"Das .gitignore File in einem Projekt beschreibt die Dateien, die nicht mit in das Repository commited werden sollen. Dies sind in der Regel vor allem Dateien die immer wieder automatisch generiert werde (Builds) Secrets enthalten (z.B. Passw\u00f6rter, Secrets)","title":".gitignore File"},{"location":"module-1/git/#ein-einfaches-beispiel","text":"git init git add . git commit -am \"First commit\" git remote add origin git@github.com:your_github_user/myapplication.git -- Change/write README.md and .gitignore files git pull origin main -- Send the entire application to Github git push origin main","title":"Ein einfaches Beispiel"},{"location":"module-1/introduction/","text":"Einleitung \"Any fool can write code that a computer can understand. Good programmers write code that humans can understand.\" \u2013 Martin Fowler Clean Code beschreibt die Art und Weise Code so zu schreiben, dass dieser nicht nur seine eigentliche Funktionalit\u00e4t erf\u00fcllt, sondern gleichzeitig auch lesbar, wartbar und erweiterbar ist. Die gesamte Disziplin des \"Clean Code\" basiert hierbar auf dem ebenfalls \"Clean Code\" genannten Buch von Robert Martin (\"Uncle Bob\") - welches eines der wichtigsten B\u00fccher der gesamten IT-Geschichte darstellt und heute noch genauso aktuell ist wie damals. Hinter Abk\u00fcrzunge wie SOLID, KISS und DRY verbergen sich wichtige Konzepte die bis heute sehr wichtig sind f\u00fcr jeden Entwickler - und eben diese wollen wir gemeinsam erkl\u00e4ren. Die wichtigsten Ziele des Clean Code sind hierbei, dass wir \u00fcber einen langen Zeitraum und mit steigender Komplexit\u00e4t sicherstellen k\u00f6nnen, dass unser Code: leicht lesbar und verst\u00e4ndlich ist korrekt ist einfach ver\u00e4ndert werden kann Gemeinsam verfolgen wir das Ziel des Clean Code: Die Steigerung der Code-Qualit\u00e4t welche in der Praxis vorrangig durch empirische Metriken w\u00e4hrend eines Code Reviews gemessen werden kann:","title":"Einf\u00fchrung"},{"location":"module-1/introduction/#einleitung","text":"\"Any fool can write code that a computer can understand. Good programmers write code that humans can understand.\" \u2013 Martin Fowler Clean Code beschreibt die Art und Weise Code so zu schreiben, dass dieser nicht nur seine eigentliche Funktionalit\u00e4t erf\u00fcllt, sondern gleichzeitig auch lesbar, wartbar und erweiterbar ist. Die gesamte Disziplin des \"Clean Code\" basiert hierbar auf dem ebenfalls \"Clean Code\" genannten Buch von Robert Martin (\"Uncle Bob\") - welches eines der wichtigsten B\u00fccher der gesamten IT-Geschichte darstellt und heute noch genauso aktuell ist wie damals. Hinter Abk\u00fcrzunge wie SOLID, KISS und DRY verbergen sich wichtige Konzepte die bis heute sehr wichtig sind f\u00fcr jeden Entwickler - und eben diese wollen wir gemeinsam erkl\u00e4ren. Die wichtigsten Ziele des Clean Code sind hierbei, dass wir \u00fcber einen langen Zeitraum und mit steigender Komplexit\u00e4t sicherstellen k\u00f6nnen, dass unser Code: leicht lesbar und verst\u00e4ndlich ist korrekt ist einfach ver\u00e4ndert werden kann Gemeinsam verfolgen wir das Ziel des Clean Code: Die Steigerung der Code-Qualit\u00e4t welche in der Praxis vorrangig durch empirische Metriken w\u00e4hrend eines Code Reviews gemessen werden kann:","title":"Einleitung"},{"location":"module-1/naming/","text":"Warum Namen wichtig sind Das Ausw\u00e4hlen von Namen f\u00fcr Funktionen, Klassen und Variablen wirkt auf den ersten Blick unwichtig, ist in der Praxis jedoch eines der wichtigsten Momente im Entwicklungsprozess. He who shall be named Indem wir Funktionen, Klassen und Variablen ihre Namen geben, erreichen wir zwei wichtige Dinge: Wir definieren ihre Aufgabe und wir begrenzen ihren Scope Wir geben dem Leser vom Code Informationen \u00fcber das was er gerade liest Beim Vergeben von Namen m\u00fcssen wir also darauf achten, dass schon durch die Namen klar wird worum es sich handelt. Als Leitfaden k\u00f6nnen wir stets dar\u00fcber nachdenken ob ein Leser unseres Codes die Funktionalit\u00e4t von einem Objekt verstehen w\u00fcrde OHNE sich zus\u00e4tzliche Kommentare durchlesen zu m\u00fcssen. Folgende Regeln sollten f\u00fcr Namen im \"Clean Code\" Style erf\u00fcllt sein: Der Name ist lesbar & aussprechbar ( dysUntRetrmnt VS daysUntilRetirement ) Die Intention/Absicht ist klar( int mc VS int monthlyCosts ) Klassen und Objekte haben ein Nomen oder Nomen-Phrase als Namen (User, ErrorLogger) Methoden und Funktionen haben Verben oder Verb-Phrasen als Namen ( retrieveUserFromDatabase() ) TypInformationen sind nicht notwendig (firstNameString VS firstName)","title":"Namen"},{"location":"module-1/naming/#warum-namen-wichtig-sind","text":"Das Ausw\u00e4hlen von Namen f\u00fcr Funktionen, Klassen und Variablen wirkt auf den ersten Blick unwichtig, ist in der Praxis jedoch eines der wichtigsten Momente im Entwicklungsprozess.","title":"Warum Namen wichtig sind"},{"location":"module-1/naming/#he-who-shall-be-named","text":"Indem wir Funktionen, Klassen und Variablen ihre Namen geben, erreichen wir zwei wichtige Dinge: Wir definieren ihre Aufgabe und wir begrenzen ihren Scope Wir geben dem Leser vom Code Informationen \u00fcber das was er gerade liest Beim Vergeben von Namen m\u00fcssen wir also darauf achten, dass schon durch die Namen klar wird worum es sich handelt. Als Leitfaden k\u00f6nnen wir stets dar\u00fcber nachdenken ob ein Leser unseres Codes die Funktionalit\u00e4t von einem Objekt verstehen w\u00fcrde OHNE sich zus\u00e4tzliche Kommentare durchlesen zu m\u00fcssen. Folgende Regeln sollten f\u00fcr Namen im \"Clean Code\" Style erf\u00fcllt sein: Der Name ist lesbar & aussprechbar ( dysUntRetrmnt VS daysUntilRetirement ) Die Intention/Absicht ist klar( int mc VS int monthlyCosts ) Klassen und Objekte haben ein Nomen oder Nomen-Phrase als Namen (User, ErrorLogger) Methoden und Funktionen haben Verben oder Verb-Phrasen als Namen ( retrieveUserFromDatabase() ) TypInformationen sind nicht notwendig (firstNameString VS firstName)","title":"He who shall be named"},{"location":"module-1/structure/","text":"Wie sieht guter Code aus? Der Code ist nicht zu gro\u00df Funktionen und Klassen sollten m\u00f6glichst klein gehalten werden, damit sie einfacher zu lesen sind und damit sie nicht zu viel auf einmal tun. Der Code folgt den Konventionen Jede Programmiersprache und/oder jede Organisation folgt in der Regel einer Konvention wie Code strukturiert und aufgebaut sein sollte. Code der diesen Konventionen folgt ist einfacher zu lesen und schneller zu verstehen von Entwicklern die diese Konvention schon gew\u00f6hnt sind. Zudem sind in den Konventionen oft \"Tricks\" versteckt, welche unter bestimmten Umst\u00e4nden Fehler verhindern k\u00f6nnen. Google beispielsweise ver\u00f6ffentlicht sehr gute Styleguides: Google Java Styleguide Google Python Styleguide Der Code Enth\u00e4lt keine/kaum Duplikate Duplikate / der gleiche Code mehrfach in der Applikation f\u00fchrt oft zu Problemen, da sich der Entwickler immer daran erinnern muss dass er eine \u00c4nderung an einer Stelle auch an allen anderen Stellen nachholen muss. Dies wird bei wachsender Code-Gr\u00f6\u00dfe zu einem immer schwierigeren Problem Der Code beinhaltet Whitespaces f\u00fcr die Lesbarkeit Dicht aneinander geschriebener Code ohne jegliche Leerzeilen etc. ist f\u00fcr Menschen sehr schwer zu lesen. Gelegentliche Leerzeilen und Leerzeichen helfen. Der Code ist hierbei stehts konsistent! Der Code ist richtig einger\u00fcckt (Indentation) Richtiges Einr\u00fccken vom Code steigert die Lesbarkeit ungemein - und w\u00e4hrend es in Programmiersprachen wie Java \"nur\" der Lesbarkeit dient, wirkt sich das Einr\u00fccken vom Code in Sprachen wie Python sogar auf die gesamte Funktionalit\u00e4t aus! ... aber nicht zu oft einger\u00fcckt Ist ein Code sehr oft einger\u00fcckt, weil es viele IF Bedingungen gibt o\u00c4, so ist dies nicht nur schwierig zu lesen sondern auch mental sehr schwierig nachzuvollziehen. Eine Technik die sich in der Praxis gut bew\u00e4hrt hat um komplexe IF Szenarios zu vereinfachen ist das \"return early pattern\" - welches im Modul 2 genauer erkl\u00e4rt wird Der Code beinhaltet keine Magic Numbers Magic Numbers beschreiben Zahlen oder Werte im Code, die f\u00fcr einen Leser nicht direkt offensichtlich sind. Magic Numbers sollten mit der Hilfe von Konstanten oder \u00e4hnlichen Konstrukten weiter erkl\u00e4rt werden if(age >= 20) { executeCode(); } Besser: public static final int LEGAL_DRINKING_AGE_IN_JAPAN = 20; (...) if( age >= LEGAL_DRINKING_AGE_IN_JAPAN) { executeCode(); } Der Code kapselt komplexe Logik Komplexe Logik (z.B. gro\u00dfe IF Abfragen) k\u00f6nnen sehr schwierig zu lesen und zu verstehen sein, wodurch sie auch den Code um sie herum beeinflussen kann und schwieriger zu supporten macht. Um dies etwas zu verbessern sollte komplexe Logik via \"Zwischen-Variablen\" oder am besten gleich in dedizierte Funktionen gekapselt werden. Nicht gut: if ( employee.age > 55 && employee.yearsEmplyed > 10 && employee.isRetired ) { // do something } Besser: bool eligibleForPension = employee.age > minRetirementAge && employee.yearEmployed > minPensionEmploymentYears && emplyee.isRetired ; Noch besser: private boolean isEligbleForPension(Employee employee) { return employee.age > minRetirementAge && employee.yearEmployed > minPensionEmploymentYears && emplyee.isRetired; } (...) if( isEligbleForPension(employee) ) { // do something }","title":"Code-Struktur"},{"location":"module-1/structure/#wie-sieht-guter-code-aus","text":"","title":"Wie sieht guter Code aus?"},{"location":"module-1/structure/#der-code-ist-nicht-zu-gro","text":"Funktionen und Klassen sollten m\u00f6glichst klein gehalten werden, damit sie einfacher zu lesen sind und damit sie nicht zu viel auf einmal tun.","title":"Der Code ist nicht zu gro\u00df"},{"location":"module-1/structure/#der-code-folgt-den-konventionen","text":"Jede Programmiersprache und/oder jede Organisation folgt in der Regel einer Konvention wie Code strukturiert und aufgebaut sein sollte. Code der diesen Konventionen folgt ist einfacher zu lesen und schneller zu verstehen von Entwicklern die diese Konvention schon gew\u00f6hnt sind. Zudem sind in den Konventionen oft \"Tricks\" versteckt, welche unter bestimmten Umst\u00e4nden Fehler verhindern k\u00f6nnen. Google beispielsweise ver\u00f6ffentlicht sehr gute Styleguides: Google Java Styleguide Google Python Styleguide","title":"Der Code folgt den Konventionen"},{"location":"module-1/structure/#der-code-enthalt-keinekaum-duplikate","text":"Duplikate / der gleiche Code mehrfach in der Applikation f\u00fchrt oft zu Problemen, da sich der Entwickler immer daran erinnern muss dass er eine \u00c4nderung an einer Stelle auch an allen anderen Stellen nachholen muss. Dies wird bei wachsender Code-Gr\u00f6\u00dfe zu einem immer schwierigeren Problem","title":"Der Code Enth\u00e4lt keine/kaum Duplikate"},{"location":"module-1/structure/#der-code-beinhaltet-whitespaces-fur-die-lesbarkeit","text":"Dicht aneinander geschriebener Code ohne jegliche Leerzeilen etc. ist f\u00fcr Menschen sehr schwer zu lesen. Gelegentliche Leerzeilen und Leerzeichen helfen. Der Code ist hierbei stehts konsistent!","title":"Der Code beinhaltet Whitespaces f\u00fcr die Lesbarkeit"},{"location":"module-1/structure/#der-code-ist-richtig-eingeruckt-indentation","text":"Richtiges Einr\u00fccken vom Code steigert die Lesbarkeit ungemein - und w\u00e4hrend es in Programmiersprachen wie Java \"nur\" der Lesbarkeit dient, wirkt sich das Einr\u00fccken vom Code in Sprachen wie Python sogar auf die gesamte Funktionalit\u00e4t aus!","title":"Der Code ist richtig einger\u00fcckt (Indentation)"},{"location":"module-1/structure/#aber-nicht-zu-oft-eingeruckt","text":"Ist ein Code sehr oft einger\u00fcckt, weil es viele IF Bedingungen gibt o\u00c4, so ist dies nicht nur schwierig zu lesen sondern auch mental sehr schwierig nachzuvollziehen. Eine Technik die sich in der Praxis gut bew\u00e4hrt hat um komplexe IF Szenarios zu vereinfachen ist das \"return early pattern\" - welches im Modul 2 genauer erkl\u00e4rt wird","title":"... aber nicht zu oft einger\u00fcckt"},{"location":"module-1/structure/#der-code-beinhaltet-keine-magic-numbers","text":"Magic Numbers beschreiben Zahlen oder Werte im Code, die f\u00fcr einen Leser nicht direkt offensichtlich sind. Magic Numbers sollten mit der Hilfe von Konstanten oder \u00e4hnlichen Konstrukten weiter erkl\u00e4rt werden if(age >= 20) { executeCode(); } Besser: public static final int LEGAL_DRINKING_AGE_IN_JAPAN = 20; (...) if( age >= LEGAL_DRINKING_AGE_IN_JAPAN) { executeCode(); }","title":"Der Code beinhaltet keine Magic Numbers"},{"location":"module-1/structure/#der-code-kapselt-komplexe-logik","text":"Komplexe Logik (z.B. gro\u00dfe IF Abfragen) k\u00f6nnen sehr schwierig zu lesen und zu verstehen sein, wodurch sie auch den Code um sie herum beeinflussen kann und schwieriger zu supporten macht. Um dies etwas zu verbessern sollte komplexe Logik via \"Zwischen-Variablen\" oder am besten gleich in dedizierte Funktionen gekapselt werden. Nicht gut: if ( employee.age > 55 && employee.yearsEmplyed > 10 && employee.isRetired ) { // do something } Besser: bool eligibleForPension = employee.age > minRetirementAge && employee.yearEmployed > minPensionEmploymentYears && emplyee.isRetired ; Noch besser: private boolean isEligbleForPension(Employee employee) { return employee.age > minRetirementAge && employee.yearEmployed > minPensionEmploymentYears && emplyee.isRetired; } (...) if( isEligbleForPension(employee) ) { // do something }","title":"Der Code kapselt komplexe Logik"},{"location":"module-2/automated-formatters/","text":"Automatisierte Formatierung Da die Formatierungsregeln die Code-\u00d6kosysteme oder Organisationen oft sehr komplex und arbeitsaufw\u00e4ndig werden k\u00f6nnen, werden in der Praxis oft verschiedene M\u00f6glichkeiten zur Automatisierung und automatischer Kontrolle genutzt. Hier folgen nun einige M\u00f6glichkeiten Formatierungsregeln automatisch anzuwenden und zu pr\u00fcfen: Regelwerke in der Entwicklungsumgebung Jede moderne Entwicklungsumgebung wie Visual Studio Code oder IntelliJ bringt eigene (konfigurierbare) Formatierungsregeln f\u00fcr verschiedene Programmiersprachen mit. Diese Formatierungsregeln k\u00f6nnen entweder bei Verstoss als Warnung ausgegeben werden oder direkt beim Speichern einer Datei automatisch angewendet werden. Diese in der Entwicklungsumgebung zu nutzen hat f\u00fcr einen Entwickler den Vorteil, dass sie sehr einfach und komfortabel zu benutzen ist - hat jedoch den Nachteil, dass verschiedene Entwicklungsumgebungen (die durchaus gleichzeitig im selben Team benutzt werden k\u00f6nnen) unterschiedliche Regeln haben k\u00f6nnen. Diese m\u00fcssen dann entweder aneinaner angepasst werden oder das Team muss mit einer gewissen Abweichung in der Formatierung leben. Formatter-Tools Um unabh\u00e4ngiger von einzelnen Entwicklungsumgebungen zu sein gibt es auch \"unabh\u00e4gige\" Tools wie z.B. \"Prettier\", welche entweder als IDE-Plugin oder via Kommandozeile aufgerufen werden k\u00f6nnen und dann ihrerseits automatische Code-Formatierungen anhang von komplexen Regeln anwenden k\u00f6nnen. Diese Tools haben zudem zwei weitere Vorteile: Sie sind \"opinionated\", d.h. sie bringen von Haus aus fixe Regeln mit sich die sich aus Best Practices heraus ergeben haben Sie k\u00f6nnen via Git Hooks o\u00c4 automatisch angewendet werden wodurch sie forciert angewendet werden bevor der Sourcecode das Git Repository erreicht Git Hooks Git Hooks sind Trigger die bei bestimmten Aktionen im Git automatisch ausgef\u00fchrt werden. Ein verbreitetes Beispiel hierf\u00fcr sind \"Git Pre-Commit\"-Hooks. Hierbei werden in dem Moment wo ein User ein Git Commit ausf\u00fchrt automatisch weiterer Code ausgef\u00fchrt - wie beispielsweise das Code Formatting Tool \"Prettier\"","title":"Automatisierte Formatierung"},{"location":"module-2/automated-formatters/#automatisierte-formatierung","text":"Da die Formatierungsregeln die Code-\u00d6kosysteme oder Organisationen oft sehr komplex und arbeitsaufw\u00e4ndig werden k\u00f6nnen, werden in der Praxis oft verschiedene M\u00f6glichkeiten zur Automatisierung und automatischer Kontrolle genutzt. Hier folgen nun einige M\u00f6glichkeiten Formatierungsregeln automatisch anzuwenden und zu pr\u00fcfen:","title":"Automatisierte Formatierung"},{"location":"module-2/automated-formatters/#regelwerke-in-der-entwicklungsumgebung","text":"Jede moderne Entwicklungsumgebung wie Visual Studio Code oder IntelliJ bringt eigene (konfigurierbare) Formatierungsregeln f\u00fcr verschiedene Programmiersprachen mit. Diese Formatierungsregeln k\u00f6nnen entweder bei Verstoss als Warnung ausgegeben werden oder direkt beim Speichern einer Datei automatisch angewendet werden. Diese in der Entwicklungsumgebung zu nutzen hat f\u00fcr einen Entwickler den Vorteil, dass sie sehr einfach und komfortabel zu benutzen ist - hat jedoch den Nachteil, dass verschiedene Entwicklungsumgebungen (die durchaus gleichzeitig im selben Team benutzt werden k\u00f6nnen) unterschiedliche Regeln haben k\u00f6nnen. Diese m\u00fcssen dann entweder aneinaner angepasst werden oder das Team muss mit einer gewissen Abweichung in der Formatierung leben.","title":"Regelwerke in der Entwicklungsumgebung"},{"location":"module-2/automated-formatters/#formatter-tools","text":"Um unabh\u00e4ngiger von einzelnen Entwicklungsumgebungen zu sein gibt es auch \"unabh\u00e4gige\" Tools wie z.B. \"Prettier\", welche entweder als IDE-Plugin oder via Kommandozeile aufgerufen werden k\u00f6nnen und dann ihrerseits automatische Code-Formatierungen anhang von komplexen Regeln anwenden k\u00f6nnen. Diese Tools haben zudem zwei weitere Vorteile: Sie sind \"opinionated\", d.h. sie bringen von Haus aus fixe Regeln mit sich die sich aus Best Practices heraus ergeben haben Sie k\u00f6nnen via Git Hooks o\u00c4 automatisch angewendet werden wodurch sie forciert angewendet werden bevor der Sourcecode das Git Repository erreicht","title":"Formatter-Tools"},{"location":"module-2/automated-formatters/#git-hooks","text":"Git Hooks sind Trigger die bei bestimmten Aktionen im Git automatisch ausgef\u00fchrt werden. Ein verbreitetes Beispiel hierf\u00fcr sind \"Git Pre-Commit\"-Hooks. Hierbei werden in dem Moment wo ein User ein Git Commit ausf\u00fchrt automatisch weiterer Code ausgef\u00fchrt - wie beispielsweise das Code Formatting Tool \"Prettier\"","title":"Git Hooks"},{"location":"module-2/exception-handling/","text":"Fehlerbehandlung Einleitung Das Auftreten und Behandeln von Fehlern geh\u00f6rt zum Alltag jeder Applikation und zur t\u00e4glichen Arbeit eines jeden Entwicklers. Ob ein Fehler auftritt weil unser Code selbst diesen verursacht hat oder wir von einem externen System oder Modul abh\u00e4ngen und dieses widerum einen Fehlerzustand festgestellt hat ist hierbei nicht wichtig - wichtig ist nur, dass wir als Entwickler auf diesen Umstand reagieren m\u00fcssen Unterscheidung der Arten von Fehlern Beim Schreiben von Code zur Behandlung von Zust\u00e4nden die einen Fehler darstellen ist es zuerst am wichtigsten zu identifizieren ob wir selbst mit unserem Code diesen Zustand behandeln/l\u00f6sen k\u00f6nnen oder nicht. K\u00f6nnen wir den Fehler behandeln, l\u00f6sen oder umgehen - so ist es im Zweifel nur eine weitere Funktion oder ein weiteres Modul welches wir entwickeln m\u00fcssen um das Problem zu l\u00f6sen und einen \"normalen\" Zustand wieder herzustellen. K\u00f6nnen wir mit unserem Code den Fehler jedoch nicht l\u00f6sen (etwa, weil er ein Feedback vom Nutzer braucht, unser Code aber ein Java-Backend-System ohne direkten Zugriff zum User ist), so m\u00fcssen wir auf sogenannte Exceptions zur\u00fcckgreifen. Was sind Exceptions Exceptions sind als Paradigma in fast allen modernen Programmiersprachen vorhanden und beschreiben in der Regel gleichzeitig eine Ver\u00e4nderung des Kontrollflusses (also der Code der als n\u00e4chstes ausgef\u00fchrt wird) als auch ein Objekt mit Meta-Informationen zum aufgetretenen Fehler. Exceptions haben sich in der Praxis als besseres Paradigma als \"Return Codes\" herausgestellt, welche vor allem in fr\u00fcheren Programmiersprachen- und umgebungen sehr verbreitet waren. Return Codes haben den Nachteil, dass sie sehr viel Interpretation durch den Empf\u00e4nger des Return Codes ben\u00f6tigen und meistens sehr wenige dazugeh\u00f6rige Meta Informationen zur Verf\u00fcgung stellen, welche zur L\u00f6sung des Problems wom\u00f6glich sinnvoll w\u00e4ren. Wie nutze ich Exceptions Jede Programmiersprache hat zum Thema Exceptions ihren eigenen Syntax und Konzepte - wobei sich das Grundparadigma kaum unterscheidet. Betrachtet werden k\u00f6nnen immer 2 Szenarien: Szenario 1 - Werfen von Exceptions Erkennt unser Code einen Fehler den wir selbst nicht behandeln k\u00f6nnen, so wird das Werfen einer Exception sinnvoll. Wir erstellen hierbei ein typisiertes Exception-Objekt welches wir mit Informationen f\u00fcllen die dem \"Empf\u00e4nger\" dieses Objekts ggf. n\u00fctzlich sind um den Fehler behandeln zu k\u00f6nnen. Es ist hierbei wichtig dass wir sinnvolle Informationen und Exception-Typen w\u00e4hlen, um dem Empf\u00e4nger unserer Exception die beste Chance zu geben das Problem zu l\u00f6sen oder zu behandeln. if( somethingBadHappened) { throw new MyException(\"Dieser String\"); } Der Programmfluss wird hierbei beim Werfen der Exception unterbrochen, \"unser\" Code wird nicht weiter ausgef\u00fchrt sondern die Exception wandert in der Funktions-Hierarchie weiter nach oben bis es einen korrespondierenden Handler/Catch-Block erreicht. Gibt es in der gesamten Funktions-Hierarchie keinen passenden Exeption-Handler, so wird in der Regel die gesamte Applikation beendet. Szenario 2 - Fangen von Exceptions Haben wir Code oder Funktionen aufgerufen die unter Umst\u00e4nden Exceptions werfen, so liegt es an uns diese Exceptions zu \"fangen\" wenn wir sie behandeln k\u00f6nnen . Ist unser Code aus irgendwelchen Gr\u00fcnden nicht in der Lage die Exception zu behandeln, so sollten wir sie gar nicht erst fangen um einem anderen Modul weiter \"oben\" in der Hierarchie die M\u00f6glichkeit zu geben diese Exception zu behandeln. In der Java-Welt besteht ein Exception-Handling aus 3 Code-Bl\u00f6cken die zueinander geh\u00f6ren. Try: dies ist der Code Block, in dem wir Exceptions erwarten und bei deren Auftreten wir reagieren wollen Catch: in 0-n Catch-Bl\u00f6cken \"fangen\" und behandeln wir m\u00f6glicherweise auftretende Exceptions f\u00fcr jeweils 1 bestimmten Typ Finally: dieser Block beschreibt Code der definitiv ausgef\u00fchrt werden soll, egal ob eine Exception aufgetreten ist oder nicht try { callMyFunction(); } catch (MyException e) { displayErrorToUser(e.getMessage()); setErrorState(true); } finally { System.out.println(\"The function has finished\"); } Wie designe ich Exceptions Die meisten Programmiersprachen beinhalten selbst schon eine eigene Hierarchie von Exception-Typen, welche ihrerseits diverse Fehlerszenarien beschreiben. Es ist sinnvoll diese zu nutzen und ggf. um eigene Typen zu erweitern, wobei sich hier oft die Vorteile der Abstraktion zeigen. Wie funktioniert es in Java? Java unterscheidet grunds\u00e4tzlich zwischen Exceptions und Errors, wobei beide Arten (und ihre Unterarten) das Interface \"Throwable\" implementieren. Exceptions in der Java-Welt stellen Fehler und Zust\u00e4nde dar, von denen eigentlich zu erwarten ist dass eine Applikation diese auf irgendeine Weise behandelt und/oder weitergibt. Errors auf der anderen Seite stellen Zust\u00e4nde dar \u00fcber die die Applikation zwar informiert wird aber welche dann in der Regel nicht behandelt werden (k\u00f6nnen). OutOfMemoryError oder StackOverflowError beispielsweise sind 2 Fehlertypen bei denen die Applikation nicht weiter reagieren kann - da ihr Auftreten zur Terminierung der Applikation f\u00fchrt. Wann sollte ich keine Exceptions nutzen? Exceptions sollten vor allem in den Momenten nicht genutzt werden, wo die Applikation sich eigentlich noch in einem normalen Zustand und Fluss befindet. Dies hat vor allem zwei Gr\u00fcnde: + Das Nachverfolgen von einem durch Exceptions kontrollierten Programmfluss ist f\u00fcr einen Entwickler relaltiv schwierig + Exceptions sind aus Performanceperspektive relativ \"teure\" Operationen (mindestens in Java) und k\u00f6nnten in performancekritischen Code zu Verlusten f\u00fchren.","title":"Fehlerbehandlung"},{"location":"module-2/exception-handling/#fehlerbehandlung","text":"","title":"Fehlerbehandlung"},{"location":"module-2/exception-handling/#einleitung","text":"Das Auftreten und Behandeln von Fehlern geh\u00f6rt zum Alltag jeder Applikation und zur t\u00e4glichen Arbeit eines jeden Entwicklers. Ob ein Fehler auftritt weil unser Code selbst diesen verursacht hat oder wir von einem externen System oder Modul abh\u00e4ngen und dieses widerum einen Fehlerzustand festgestellt hat ist hierbei nicht wichtig - wichtig ist nur, dass wir als Entwickler auf diesen Umstand reagieren m\u00fcssen","title":"Einleitung"},{"location":"module-2/exception-handling/#unterscheidung-der-arten-von-fehlern","text":"Beim Schreiben von Code zur Behandlung von Zust\u00e4nden die einen Fehler darstellen ist es zuerst am wichtigsten zu identifizieren ob wir selbst mit unserem Code diesen Zustand behandeln/l\u00f6sen k\u00f6nnen oder nicht. K\u00f6nnen wir den Fehler behandeln, l\u00f6sen oder umgehen - so ist es im Zweifel nur eine weitere Funktion oder ein weiteres Modul welches wir entwickeln m\u00fcssen um das Problem zu l\u00f6sen und einen \"normalen\" Zustand wieder herzustellen. K\u00f6nnen wir mit unserem Code den Fehler jedoch nicht l\u00f6sen (etwa, weil er ein Feedback vom Nutzer braucht, unser Code aber ein Java-Backend-System ohne direkten Zugriff zum User ist), so m\u00fcssen wir auf sogenannte Exceptions zur\u00fcckgreifen.","title":"Unterscheidung der Arten von Fehlern"},{"location":"module-2/exception-handling/#was-sind-exceptions","text":"Exceptions sind als Paradigma in fast allen modernen Programmiersprachen vorhanden und beschreiben in der Regel gleichzeitig eine Ver\u00e4nderung des Kontrollflusses (also der Code der als n\u00e4chstes ausgef\u00fchrt wird) als auch ein Objekt mit Meta-Informationen zum aufgetretenen Fehler. Exceptions haben sich in der Praxis als besseres Paradigma als \"Return Codes\" herausgestellt, welche vor allem in fr\u00fcheren Programmiersprachen- und umgebungen sehr verbreitet waren. Return Codes haben den Nachteil, dass sie sehr viel Interpretation durch den Empf\u00e4nger des Return Codes ben\u00f6tigen und meistens sehr wenige dazugeh\u00f6rige Meta Informationen zur Verf\u00fcgung stellen, welche zur L\u00f6sung des Problems wom\u00f6glich sinnvoll w\u00e4ren.","title":"Was sind Exceptions"},{"location":"module-2/exception-handling/#wie-nutze-ich-exceptions","text":"Jede Programmiersprache hat zum Thema Exceptions ihren eigenen Syntax und Konzepte - wobei sich das Grundparadigma kaum unterscheidet. Betrachtet werden k\u00f6nnen immer 2 Szenarien:","title":"Wie nutze ich Exceptions"},{"location":"module-2/exception-handling/#szenario-1-werfen-von-exceptions","text":"Erkennt unser Code einen Fehler den wir selbst nicht behandeln k\u00f6nnen, so wird das Werfen einer Exception sinnvoll. Wir erstellen hierbei ein typisiertes Exception-Objekt welches wir mit Informationen f\u00fcllen die dem \"Empf\u00e4nger\" dieses Objekts ggf. n\u00fctzlich sind um den Fehler behandeln zu k\u00f6nnen. Es ist hierbei wichtig dass wir sinnvolle Informationen und Exception-Typen w\u00e4hlen, um dem Empf\u00e4nger unserer Exception die beste Chance zu geben das Problem zu l\u00f6sen oder zu behandeln. if( somethingBadHappened) { throw new MyException(\"Dieser String\"); } Der Programmfluss wird hierbei beim Werfen der Exception unterbrochen, \"unser\" Code wird nicht weiter ausgef\u00fchrt sondern die Exception wandert in der Funktions-Hierarchie weiter nach oben bis es einen korrespondierenden Handler/Catch-Block erreicht. Gibt es in der gesamten Funktions-Hierarchie keinen passenden Exeption-Handler, so wird in der Regel die gesamte Applikation beendet.","title":"Szenario 1 - Werfen von Exceptions"},{"location":"module-2/exception-handling/#szenario-2-fangen-von-exceptions","text":"Haben wir Code oder Funktionen aufgerufen die unter Umst\u00e4nden Exceptions werfen, so liegt es an uns diese Exceptions zu \"fangen\" wenn wir sie behandeln k\u00f6nnen . Ist unser Code aus irgendwelchen Gr\u00fcnden nicht in der Lage die Exception zu behandeln, so sollten wir sie gar nicht erst fangen um einem anderen Modul weiter \"oben\" in der Hierarchie die M\u00f6glichkeit zu geben diese Exception zu behandeln. In der Java-Welt besteht ein Exception-Handling aus 3 Code-Bl\u00f6cken die zueinander geh\u00f6ren. Try: dies ist der Code Block, in dem wir Exceptions erwarten und bei deren Auftreten wir reagieren wollen Catch: in 0-n Catch-Bl\u00f6cken \"fangen\" und behandeln wir m\u00f6glicherweise auftretende Exceptions f\u00fcr jeweils 1 bestimmten Typ Finally: dieser Block beschreibt Code der definitiv ausgef\u00fchrt werden soll, egal ob eine Exception aufgetreten ist oder nicht try { callMyFunction(); } catch (MyException e) { displayErrorToUser(e.getMessage()); setErrorState(true); } finally { System.out.println(\"The function has finished\"); }","title":"Szenario 2 - Fangen von Exceptions"},{"location":"module-2/exception-handling/#wie-designe-ich-exceptions","text":"Die meisten Programmiersprachen beinhalten selbst schon eine eigene Hierarchie von Exception-Typen, welche ihrerseits diverse Fehlerszenarien beschreiben. Es ist sinnvoll diese zu nutzen und ggf. um eigene Typen zu erweitern, wobei sich hier oft die Vorteile der Abstraktion zeigen.","title":"Wie designe ich Exceptions"},{"location":"module-2/exception-handling/#wie-funktioniert-es-in-java","text":"Java unterscheidet grunds\u00e4tzlich zwischen Exceptions und Errors, wobei beide Arten (und ihre Unterarten) das Interface \"Throwable\" implementieren. Exceptions in der Java-Welt stellen Fehler und Zust\u00e4nde dar, von denen eigentlich zu erwarten ist dass eine Applikation diese auf irgendeine Weise behandelt und/oder weitergibt. Errors auf der anderen Seite stellen Zust\u00e4nde dar \u00fcber die die Applikation zwar informiert wird aber welche dann in der Regel nicht behandelt werden (k\u00f6nnen). OutOfMemoryError oder StackOverflowError beispielsweise sind 2 Fehlertypen bei denen die Applikation nicht weiter reagieren kann - da ihr Auftreten zur Terminierung der Applikation f\u00fchrt.","title":"Wie funktioniert es in Java?"},{"location":"module-2/exception-handling/#wann-sollte-ich-keine-exceptions-nutzen","text":"Exceptions sollten vor allem in den Momenten nicht genutzt werden, wo die Applikation sich eigentlich noch in einem normalen Zustand und Fluss befindet. Dies hat vor allem zwei Gr\u00fcnde: + Das Nachverfolgen von einem durch Exceptions kontrollierten Programmfluss ist f\u00fcr einen Entwickler relaltiv schwierig + Exceptions sind aus Performanceperspektive relativ \"teure\" Operationen (mindestens in Java) und k\u00f6nnten in performancekritischen Code zu Verlusten f\u00fchren.","title":"Wann sollte ich keine Exceptions nutzen?"},{"location":"module-2/exercise/","text":"Aufgaben Aufgabe 1 Eure Aufgabe ist das Umschreiben dieser Funktion anhand der bisher gelernten Konzepte von Clean Code. Euer Ziel ist die Verbesserung der Lesbarkeit und Wartbarkeit des Codes, zusammen mit allen weiteren Optimierungen die m\u00f6glich w\u00e4ren. Was w\u00fcrdet ihr dem Autoren dieser Funktion sagen, was er/sie n\u00e4chstes Mal besser machen kann? public void onChangeSelectedChart(ClickEvent event, int: number) { if (event.checked != null) { if (event.checked == true) { if (typeChart == chartTypes.lineChart) { setIsLineChecked(true); setIsStackedChartChecked(false); rootStore.appState.setActiveChartType(chartTypes.lineChart); } else { setIsStackedChartChecked(true); setIsLineChecked(false); rootStore.appState.setActiveChartType(chartTypes.stackedChart); } } else { if (typeChart == chartTypes.lineChart) { setIsLineChecked(false); } else if (typeChart === chartTypes.stackedChart) { setIsStackedChartChecked(false); } } } }; Aufgabe 2 Was w\u00fcrdest du bei diesem Code optimieren? Bitte begr\u00fcnde deine L\u00f6sung public void createSavegame(String gameState, String filename) { try { BufferedWriter writer = new BufferedWriter(new FileWriter(fileName)); writer.write(str); writer.close(); } catch (IOException e) {} } public void doOtherStuff() { try { callMyApi(); } catch(StackOverflowError e) { // retry logic doOtherStuff(); } } Aufgabe 3 Erf\u00fcllt die Aufgabe unter https://github.com/lamchau/refactoring-exercise/tree/master/java","title":"Aufgaben"},{"location":"module-2/exercise/#aufgaben","text":"","title":"Aufgaben"},{"location":"module-2/exercise/#aufgabe-1","text":"Eure Aufgabe ist das Umschreiben dieser Funktion anhand der bisher gelernten Konzepte von Clean Code. Euer Ziel ist die Verbesserung der Lesbarkeit und Wartbarkeit des Codes, zusammen mit allen weiteren Optimierungen die m\u00f6glich w\u00e4ren. Was w\u00fcrdet ihr dem Autoren dieser Funktion sagen, was er/sie n\u00e4chstes Mal besser machen kann? public void onChangeSelectedChart(ClickEvent event, int: number) { if (event.checked != null) { if (event.checked == true) { if (typeChart == chartTypes.lineChart) { setIsLineChecked(true); setIsStackedChartChecked(false); rootStore.appState.setActiveChartType(chartTypes.lineChart); } else { setIsStackedChartChecked(true); setIsLineChecked(false); rootStore.appState.setActiveChartType(chartTypes.stackedChart); } } else { if (typeChart == chartTypes.lineChart) { setIsLineChecked(false); } else if (typeChart === chartTypes.stackedChart) { setIsStackedChartChecked(false); } } } };","title":"Aufgabe 1"},{"location":"module-2/exercise/#aufgabe-2","text":"Was w\u00fcrdest du bei diesem Code optimieren? Bitte begr\u00fcnde deine L\u00f6sung public void createSavegame(String gameState, String filename) { try { BufferedWriter writer = new BufferedWriter(new FileWriter(fileName)); writer.write(str); writer.close(); } catch (IOException e) {} } public void doOtherStuff() { try { callMyApi(); } catch(StackOverflowError e) { // retry logic doOtherStuff(); } }","title":"Aufgabe 2"},{"location":"module-2/exercise/#aufgabe-3","text":"Erf\u00fcllt die Aufgabe unter https://github.com/lamchau/refactoring-exercise/tree/master/java","title":"Aufgabe 3"},{"location":"module-2/if-inversion/","text":"If-Inversion Eine in der Praxis oft angewandte Strategie f\u00fcr die bessere Lesbarkeit von Code ist die sogenannte \"If-Inversion\", welche unter anderem auch als \"early return Stragie\", \"guard clauses\" und diverse andere Namen bekannt ist. Unabh\u00e4ngig vom Namen und den teilweise auch minimal anderen Zielen dieser verschiedenen Stragien verhalten sich diese jedoch alle im Grunde gleich: Ein Beispiel zur Veranschaulichung Betrachten wir den folgenden recht komplexen Code: public String returnStuff(SomeObject argument1, SomeObject argument2) { if (argument1.isValid()) { if (argument2.isValid()) { SomeObject otherVal1 = doSomeStuff(argument1, argument2) if (otherVal1.isValid()) { SomeObject otherVal2 = doAnotherStuff(otherVal1) if (otherVal2.isValid()) { return \"Stuff\"; } else { throw new Exception(); } } else { throw new Exception(); } } else { throw new Exception(); } } else { throw new Exception(); } } Anwendung der If-Inversion Drehen wir nun aber den Code um und behandeln die F\u00e4lle bei denen wir \"nichts machen k\u00f6nnen\" zuerst, so sehen wir wie ganz automatisch die Menge der geschachtelten Ausdr\u00fccke immer weiter abnimmt. Wir k\u00f6nnen nach und nach verschiedene Fehler-Szenarien abfangen und hierzu passende L\u00f6sungen (Return-Werte, Exceptions oder sonstige Behandlungen) ausf\u00fchren, ohne auf den restlichen Code Auswirkungen zu haben. Der Code wird hierdurch deutlich klarer und von einem Leser deutlich einfacher zu lesen. public String returnStuff(SomeObject argument1, SomeObject argument2){ if (!argument1.isValid()) { throw new Exception(); } if (!argument2.isValid()) { throw new Exception(); } SomeObject otherVal1 = doSomeStuff(argument1, argument2); if (!otherVal1.isValid()) { throw new Exception(); } SomeObject otherVal2 = doAnotherStuff(otherVal1); if (!otherVal2.isValid()) { throw new Exception(); } return \"Stuff\"; } https://medium.com/swlh/return-early-pattern-3d18a41bba8","title":"If-Inversion"},{"location":"module-2/if-inversion/#if-inversion","text":"Eine in der Praxis oft angewandte Strategie f\u00fcr die bessere Lesbarkeit von Code ist die sogenannte \"If-Inversion\", welche unter anderem auch als \"early return Stragie\", \"guard clauses\" und diverse andere Namen bekannt ist. Unabh\u00e4ngig vom Namen und den teilweise auch minimal anderen Zielen dieser verschiedenen Stragien verhalten sich diese jedoch alle im Grunde gleich:","title":"If-Inversion"},{"location":"module-2/if-inversion/#ein-beispiel-zur-veranschaulichung","text":"Betrachten wir den folgenden recht komplexen Code: public String returnStuff(SomeObject argument1, SomeObject argument2) { if (argument1.isValid()) { if (argument2.isValid()) { SomeObject otherVal1 = doSomeStuff(argument1, argument2) if (otherVal1.isValid()) { SomeObject otherVal2 = doAnotherStuff(otherVal1) if (otherVal2.isValid()) { return \"Stuff\"; } else { throw new Exception(); } } else { throw new Exception(); } } else { throw new Exception(); } } else { throw new Exception(); } }","title":"Ein Beispiel zur Veranschaulichung"},{"location":"module-2/if-inversion/#anwendung-der-if-inversion","text":"Drehen wir nun aber den Code um und behandeln die F\u00e4lle bei denen wir \"nichts machen k\u00f6nnen\" zuerst, so sehen wir wie ganz automatisch die Menge der geschachtelten Ausdr\u00fccke immer weiter abnimmt. Wir k\u00f6nnen nach und nach verschiedene Fehler-Szenarien abfangen und hierzu passende L\u00f6sungen (Return-Werte, Exceptions oder sonstige Behandlungen) ausf\u00fchren, ohne auf den restlichen Code Auswirkungen zu haben. Der Code wird hierdurch deutlich klarer und von einem Leser deutlich einfacher zu lesen. public String returnStuff(SomeObject argument1, SomeObject argument2){ if (!argument1.isValid()) { throw new Exception(); } if (!argument2.isValid()) { throw new Exception(); } SomeObject otherVal1 = doSomeStuff(argument1, argument2); if (!otherVal1.isValid()) { throw new Exception(); } SomeObject otherVal2 = doAnotherStuff(otherVal1); if (!otherVal2.isValid()) { throw new Exception(); } return \"Stuff\"; } https://medium.com/swlh/return-early-pattern-3d18a41bba8","title":"Anwendung der If-Inversion"},{"location":"module-2/refactoring/","text":"Refactoring In vorherigen Kapiteln haben wir diverse Strategien betrachtet wie wir beim Schreiben von Code eine gute Qualit\u00e4t erreicht k\u00f6nnen. Was aber wenn wir oder ein anderer Entwickler bereits suboptimalen Code geschrieben und in unsere Applikation integriert haben? Es gibt vorrangig 2 Gr\u00fcnde warum wir \u00fcber die Zeit existierenden Code ver\u00e4ndern oder verbessern m\u00fcssen: Es haben sich Anforderungen oder Rahmenbedingungen ge\u00e4ndert Existierender Code erf\u00fcllt nicht unsere Qualt\u00e4tsanforderungen Das \u00c4ndern unseres Codes ohne Ver\u00e4nderung der eigentlichen Funktionalit\u00e4t nennt man Refactoring - und es hat grunds\u00e4tzlich immer zum Ziel eine dieser beiden problematischen Situationen zu verbessern. High Coupling Wir als Entwickler stehen oft vor dem Dilemma, dass der Code den wir refactoren wollen so tief in unsere restliche Applikation verworren ist, dass er nur sehr schwierig ver\u00e4ndert oder erweitert werden kann. M\u00f6glicherweise etwa gibt es sehr viele andere Module die konkret gegen diese eine Implementation unseres Code entwickelt haben, wodurch jede \u00c4nderung pl\u00f6tzlich ungewollte Seiteneffekte mit sich bringt. Diese Situation ist \"High Coupling\", de facto das Gegenteil dessen was wir in \"clean code\" eigentlich erreichen wollen. Refactoring by Abstraction W\u00e4hrend das Refactoring bei vergleichsweise kleinen Modulen und Applikationen noch relativ einfach ausgef\u00fchrt werden kann, so kann dies bei sehr gro\u00dfen und komplexen Applikationen eine gro\u00dfe H\u00fcrde darstellen. Eine Strategie die sich zur L\u00f6sung dieses Problems bew\u00e4hrt hat ist das Refactoring by Abstraction. \u00c4hnlich wie beim Dependency Inversion gehes auch hier darum eine weitere Abstraktionsebene zwischen 2 Code-Modulen einzuf\u00fchren. Mit Hilfe dieser Abstraktions-Ebene k\u00f6nnen auf beiden Seiten der Abstraktion nach und nach kleinere oder gr\u00f6\u00dfere \u00c4nderungen vorgenommen werden, ohne dass dies negative Auswirkungen auf die jeweils andere Seite haben muss.","title":"Refactoring"},{"location":"module-2/refactoring/#refactoring","text":"In vorherigen Kapiteln haben wir diverse Strategien betrachtet wie wir beim Schreiben von Code eine gute Qualit\u00e4t erreicht k\u00f6nnen. Was aber wenn wir oder ein anderer Entwickler bereits suboptimalen Code geschrieben und in unsere Applikation integriert haben? Es gibt vorrangig 2 Gr\u00fcnde warum wir \u00fcber die Zeit existierenden Code ver\u00e4ndern oder verbessern m\u00fcssen: Es haben sich Anforderungen oder Rahmenbedingungen ge\u00e4ndert Existierender Code erf\u00fcllt nicht unsere Qualt\u00e4tsanforderungen Das \u00c4ndern unseres Codes ohne Ver\u00e4nderung der eigentlichen Funktionalit\u00e4t nennt man Refactoring - und es hat grunds\u00e4tzlich immer zum Ziel eine dieser beiden problematischen Situationen zu verbessern.","title":"Refactoring"},{"location":"module-2/refactoring/#high-coupling","text":"Wir als Entwickler stehen oft vor dem Dilemma, dass der Code den wir refactoren wollen so tief in unsere restliche Applikation verworren ist, dass er nur sehr schwierig ver\u00e4ndert oder erweitert werden kann. M\u00f6glicherweise etwa gibt es sehr viele andere Module die konkret gegen diese eine Implementation unseres Code entwickelt haben, wodurch jede \u00c4nderung pl\u00f6tzlich ungewollte Seiteneffekte mit sich bringt. Diese Situation ist \"High Coupling\", de facto das Gegenteil dessen was wir in \"clean code\" eigentlich erreichen wollen.","title":"High Coupling"},{"location":"module-2/refactoring/#refactoring-by-abstraction","text":"W\u00e4hrend das Refactoring bei vergleichsweise kleinen Modulen und Applikationen noch relativ einfach ausgef\u00fchrt werden kann, so kann dies bei sehr gro\u00dfen und komplexen Applikationen eine gro\u00dfe H\u00fcrde darstellen. Eine Strategie die sich zur L\u00f6sung dieses Problems bew\u00e4hrt hat ist das Refactoring by Abstraction. \u00c4hnlich wie beim Dependency Inversion gehes auch hier darum eine weitere Abstraktionsebene zwischen 2 Code-Modulen einzuf\u00fchren. Mit Hilfe dieser Abstraktions-Ebene k\u00f6nnen auf beiden Seiten der Abstraktion nach und nach kleinere oder gr\u00f6\u00dfere \u00c4nderungen vorgenommen werden, ohne dass dies negative Auswirkungen auf die jeweils andere Seite haben muss.","title":"Refactoring by Abstraction"},{"location":"module-2/single-responsibility-principle/","text":"Single-Responsibility Principle Code-Module die zu viele Dinge auf einmal tut wird \u00fcber kurz oder lang sehr schwierig zu warten und zu lesen. In der Praxis hat sich daher das \"Single-Responsibility Principle\" (SRP) etabliert. Dieses wurde von Robert C. Martin in der Form seines Mantras \"Eine Klasse sollte nur einen Grund sich zu \u00e4ndern haben\" (A class should have only one reason to change). Dies bedeutet, dass jede Klasse (und de facto auch jede Funktion) exakt 1 Funktion haben sollte. Stellt sich irgendwann heraus, dass eine Klasse beginnt mehr Funktionen zu implementieren, so sollten diese in eine neue Klasse ausgelagert werden. Ein Beispiel Was sagt ihr zu diesem Beispiel? public class UserService { public void registerUser(User user) { final String emailSender = \"myemail@yahoo.com\"; final String emailPassword = \"mypassword\"; final String toEmail = user.getEmail(); Properties props = new Properties(); props.put(\"mail.smtp.host\", \"smtp.gmail.com\"); // SMTP Host props.put(\"mail.smtp.port\", \"587\"); // TLS Port props.put(\"mail.smtp.auth\", \"true\"); // enable authentication props.put(\"mail.smtp.starttls.enable\", \"true\"); // enable STARTTLS // create Authenticator object to pass in Session.getInstance argument Authenticator auth = new Authenticator() { // override the getPasswordAuthentication method protected PasswordAuthentication getPasswordAuthentication() { return new PasswordAuthentication(emailSender, emailPassword); } }; Session session = Session.getInstance(props, auth); sendEmail(session, toEmail, \"User registered\", \"A user was registered\"); database.registerUser(user); } private void sendEmail(Session session, String toEmail, String subject, String body) { try { MimeMessage msg = new MimeMessage(session); msg.addHeader(\"Content-type\", \"text/HTML; charset=UTF-8\"); // Insert email preparation code here Transport.send(msg); System.out.println(\"EMail Sent Successfully!!\"); } catch (Exception e) { e.printStackTrace(); } } } Cohesion VS Coupling Im Rahmen des SRP wird oft \u00fcber den Vergleich zwischen Cohesion und (Loose) Coupling gesprochen. Cohesion beschreibt den Umstand, dass Code der logisch und technisch zusammen geh\u00f6rt auch in der gleichen Klasse/im gleichen Modul sein sollte. Das angestrebte \"Loose Coupling\" widerum beschreibt das logische Gegenteil hiervon: Code der nicht direkt zusammengeh\u00f6rt sollte in verschiede Klassen/Module aufgeteilt sein und hierbei alleine lauff\u00e4hig sein! Funktioniert eine Klasse/Modul nur zusammen mit einer/m anderen Klasse/Modul, so sind diese nicht \"loosely coupled\". Ein Moment zum Nachdenken Die Herausforderung beim Anwenden des SRP ist, dass jeder Entwickler seine eigene Interpretation und seine eigene Meinung haben wird, was genau die eigetliche Aufgabe eines jeden Moduls sein soll. Die Entscheidung, ob eine neue Funktionalit\u00e4t noch Teil eines Moduls sein sollte oder besser in ein neues Modul geh\u00f6rt, ist daher oft nicht klar zu beantworten. Es ist daher wichtig, dass jeder Entwickler sorgf\u00e4ltig dar\u00fcber nachdenkt, wie er seinen Code strukturiert - und stets auch andere Entwickler und deren Anspr\u00fcche im Hinterkopf beh\u00e4lt.","title":"Single-Responsibility Principle"},{"location":"module-2/single-responsibility-principle/#single-responsibility-principle","text":"Code-Module die zu viele Dinge auf einmal tut wird \u00fcber kurz oder lang sehr schwierig zu warten und zu lesen. In der Praxis hat sich daher das \"Single-Responsibility Principle\" (SRP) etabliert. Dieses wurde von Robert C. Martin in der Form seines Mantras \"Eine Klasse sollte nur einen Grund sich zu \u00e4ndern haben\" (A class should have only one reason to change). Dies bedeutet, dass jede Klasse (und de facto auch jede Funktion) exakt 1 Funktion haben sollte. Stellt sich irgendwann heraus, dass eine Klasse beginnt mehr Funktionen zu implementieren, so sollten diese in eine neue Klasse ausgelagert werden.","title":"Single-Responsibility Principle"},{"location":"module-2/single-responsibility-principle/#ein-beispiel","text":"Was sagt ihr zu diesem Beispiel? public class UserService { public void registerUser(User user) { final String emailSender = \"myemail@yahoo.com\"; final String emailPassword = \"mypassword\"; final String toEmail = user.getEmail(); Properties props = new Properties(); props.put(\"mail.smtp.host\", \"smtp.gmail.com\"); // SMTP Host props.put(\"mail.smtp.port\", \"587\"); // TLS Port props.put(\"mail.smtp.auth\", \"true\"); // enable authentication props.put(\"mail.smtp.starttls.enable\", \"true\"); // enable STARTTLS // create Authenticator object to pass in Session.getInstance argument Authenticator auth = new Authenticator() { // override the getPasswordAuthentication method protected PasswordAuthentication getPasswordAuthentication() { return new PasswordAuthentication(emailSender, emailPassword); } }; Session session = Session.getInstance(props, auth); sendEmail(session, toEmail, \"User registered\", \"A user was registered\"); database.registerUser(user); } private void sendEmail(Session session, String toEmail, String subject, String body) { try { MimeMessage msg = new MimeMessage(session); msg.addHeader(\"Content-type\", \"text/HTML; charset=UTF-8\"); // Insert email preparation code here Transport.send(msg); System.out.println(\"EMail Sent Successfully!!\"); } catch (Exception e) { e.printStackTrace(); } } }","title":"Ein Beispiel"},{"location":"module-2/single-responsibility-principle/#cohesion-vs-coupling","text":"Im Rahmen des SRP wird oft \u00fcber den Vergleich zwischen Cohesion und (Loose) Coupling gesprochen. Cohesion beschreibt den Umstand, dass Code der logisch und technisch zusammen geh\u00f6rt auch in der gleichen Klasse/im gleichen Modul sein sollte. Das angestrebte \"Loose Coupling\" widerum beschreibt das logische Gegenteil hiervon: Code der nicht direkt zusammengeh\u00f6rt sollte in verschiede Klassen/Module aufgeteilt sein und hierbei alleine lauff\u00e4hig sein! Funktioniert eine Klasse/Modul nur zusammen mit einer/m anderen Klasse/Modul, so sind diese nicht \"loosely coupled\".","title":"Cohesion VS Coupling"},{"location":"module-2/single-responsibility-principle/#ein-moment-zum-nachdenken","text":"Die Herausforderung beim Anwenden des SRP ist, dass jeder Entwickler seine eigene Interpretation und seine eigene Meinung haben wird, was genau die eigetliche Aufgabe eines jeden Moduls sein soll. Die Entscheidung, ob eine neue Funktionalit\u00e4t noch Teil eines Moduls sein sollte oder besser in ein neues Modul geh\u00f6rt, ist daher oft nicht klar zu beantworten. Es ist daher wichtig, dass jeder Entwickler sorgf\u00e4ltig dar\u00fcber nachdenkt, wie er seinen Code strukturiert - und stets auch andere Entwickler und deren Anspr\u00fcche im Hinterkopf beh\u00e4lt.","title":"Ein Moment zum Nachdenken"},{"location":"module-2/solutions/","text":"L\u00f6sungen zu den Aufgaben von Modul 2 (1) IF Inversion if (null == event || null == event.checked) return; const isActive: boolean = event.checked; const isLineChart: boolean = typeChart === chartTypes.lineChart; const activeChartType: string = isLineChart ? chartTypes.lineChart : chartTypes.stackedChart; if (isActive) { setIsLineChecked(isLineChart); setIsStackedChartChecked(!isLineChart); rootStore.appState.setActiveChartType(activeChartType); } else { isLineChart ? setIsLineChecked(isActive) : setIsStackedChartChecked(isActive); }","title":"L\u00f6sungen zu den Aufgaben von Modul 2"},{"location":"module-2/solutions/#losungen-zu-den-aufgaben-von-modul-2","text":"","title":"L\u00f6sungen zu den Aufgaben von Modul 2"},{"location":"module-2/solutions/#1-if-inversion","text":"if (null == event || null == event.checked) return; const isActive: boolean = event.checked; const isLineChart: boolean = typeChart === chartTypes.lineChart; const activeChartType: string = isLineChart ? chartTypes.lineChart : chartTypes.stackedChart; if (isActive) { setIsLineChecked(isLineChart); setIsStackedChartChecked(!isLineChart); rootStore.appState.setActiveChartType(activeChartType); } else { isLineChart ? setIsLineChecked(isActive) : setIsStackedChartChecked(isActive); }","title":"(1) IF Inversion"},{"location":"module-2/testability/","text":"Testbarkeit Eine wichtige Eigenschaft von \"Clean Code\" ist, dass dieser testbar ist. Ein Code ist dann gut testbar wenn mit relativ geringem Aufwand Unit- und andere Formen von automatisierten Tests geschrieben werden k\u00f6nnen. Diese Tests widerum sollen verl\u00e4ssliche Aussagen dar\u00fcber treffen k\u00f6nnen ob ein Code jetzt und in der Zukunft immer noch korrekt arbeitet und sein Verhalten nicht gravierend ver\u00e4ndert hat. Mit Hilfe solcher automatisierten Tests sollen vor allem sogenannte Regressions-Fehler gefunden werden. Regressions-Fehler sind Fehler die entstehen wenn eine \u00c4nderung an einer Stelle im Code ungewollte&unerwartete Fehler an einer anderen Stelle hervorruft. Die folgenden Kriterien haben Auswirkungen auf die Testbarkeit eines Code-Moduls: Code-Aufteilung entsprechend seines Zwecks Um eine h\u00f6here Cohesion innerhalb des eigenen Codes zu erreichen ist es oft sinnvoll diesen entlang von Aufgabenbereichen zu trennen und aufzuteilen. Besonders sinnvoll ist dies beispielsweise bei der Trennung zwischen Code zur Steuerung der grafischen Oberfl\u00e4che und Code zur Ausf\u00fchrung von Gesch\u00e4ftsprozessen oder anderen Arten von Berechnungen. Ist der Code entsprechend getrennt, so ist es deutlich einfacher automatiserte Tests (mindestens f\u00fcr Teile der Applikation) zu schreiben, da die einzelnen Module automatisch jeweils weniger Funktionalit\u00e4ten und Verantwortlichkeiten haben. Dependency Inversion Das Prinzip der Dependency Inversion ist eine Strategie um eine \"loose Coupling\" von Modulen im Code zu erreichen. Ausgangslage ist hierbei meistens eine harte Abh\u00e4ngigkeit von 2 Klassen, bei denen mindestes eine Klasse ohne die andere nicht funktionieren kann und daher auch nicht unabh\u00e4ngig getestet werden kann: Wendet man nun das Konzept der Dependency Inversion an, so wird es notwendig eine zus\u00e4tzliche Abstraktios-Ebene einzuf\u00fchren, meistens in Form eines Interface oder Abstrakter Klasse. W\u00e4hrend die eine Klasse nun das Interface implementiert und dementsprechend \u00fcber die Methoden des Interface aufgerufen werden kann, so \"kennt\" die aufrufende Klasse nun ebenfalls nur noch das Interface und ruft die Methoden von diesem auf. Welche konkrete Implementation sich dahinter verbirgt ist nicht mehr bekannt oder relevant. Durch die zus\u00e4tzliche Abstraktions-Ebene k\u00f6nnen nun in einem Unit Test sehr einfach \"Test-Implementationen\" unseres Interfaces erstellt und f\u00fcr die Tests genutzt werden. Pure Functions Eine Funktion oder ein Modul ist dann \"pure\", wenn sie/er bei gleichen Parametern immer die gleichen Ergebnisse liefert und keine Auswirkungen oder Abh\u00e4ngigkeiten auf \"externe\" Module hat. Beispiel einer pure Function Diese Funktion ist pure, da sie keinerlei Kontakt \"nach au\u00dfen\" hat mit Ausnahme von den 2 Parametern. Diese Funktion ist somit sehr einfach testbar, da wir keine komplexen Voraussetzungen erf\u00fcllen m\u00fcssen um sie auszuf\u00fchren. public int sum(int numberA, int numberB) { return numberA + numberB; } Beispiel von non-pure Funktionen Diese beiden Funktion sind nicht \"pure\", da sie sie neben ihrer Parameter auch noch externe Aufrufe bzw Ver\u00e4nderungen durchf\u00fchrt. // Um diese Funktion richtig zu testen brauchen wir eine reale oder simulierte \"Datenbank\", // welche uns den gew\u00fcnschten Wert zur\u00fcckliefert public String generateMessageOfTheDay(String name) { String prefix = \"Hello \" + name + \" this is your message of the day! \\n\"; String messageOfTheDay = database.getMessageOfTheDayTemplate(); return prefix + messageOfTheDay; } // Um diese Funktion richtig zu testen brauchen wir eine reale oder simulierte \"Datenbank\", // welche wir nach Ausf\u00fchrung \u00fcberpr\u00fcfen k\u00f6nnen ob das neue Datum gesetzt wurde. public void updateDatabase() { Date now = new Date(); database.setTimestampOfLastUpdate( now ); } F\u00fcr einen besser testbaren Code ist es oft sinnvoll seine Funktionen oder Module in pure und unpure Teile aufzuteilen - hierdurch wird zumindest ein Teil der Applikation sehr einfach testbar. Um etwa das Message-Of-The-Day-Beispiel aufzuteilen k\u00f6nnten die Funktionalit\u00e4t in 2 Funktionen aufgeteilt werden: // Wir haben die non-pure Funktionalit\u00e4ten in diese Funktion verlagert public void printMessageOfTheDay() { String name = \"Skippy the Magnificent\"; String messageOfTheDayTemplate = database.getMessageOfTheDayTemplate(); String messageOfTheday = generateMessageOfTheDay(messageOfTheDayTemplate, name); System.out.println(messageOfTheDay); } // Diese Funktion ist pure public String generateMessageOfTheDay(String messageOfTheDayTemplate, String name) { String prefix = \"Hello \" + name + \" this is your message of the day: \"; return prefix + messageOfTheDayTemplate; } @Test public void testMessageOfThDayGenerator() { String name = \"Filthy Monkey\"; String messageOfTheDay = \"Test 123\"; String expected = \"Hello Filthy Monkey this is your message of the day: Test 123\"; String actual = generateMessageOfTheDay(messageOfTheDay, name); AssertEquals(expected, actual); }","title":"Testbarkeit"},{"location":"module-2/testability/#testbarkeit","text":"Eine wichtige Eigenschaft von \"Clean Code\" ist, dass dieser testbar ist. Ein Code ist dann gut testbar wenn mit relativ geringem Aufwand Unit- und andere Formen von automatisierten Tests geschrieben werden k\u00f6nnen. Diese Tests widerum sollen verl\u00e4ssliche Aussagen dar\u00fcber treffen k\u00f6nnen ob ein Code jetzt und in der Zukunft immer noch korrekt arbeitet und sein Verhalten nicht gravierend ver\u00e4ndert hat. Mit Hilfe solcher automatisierten Tests sollen vor allem sogenannte Regressions-Fehler gefunden werden. Regressions-Fehler sind Fehler die entstehen wenn eine \u00c4nderung an einer Stelle im Code ungewollte&unerwartete Fehler an einer anderen Stelle hervorruft. Die folgenden Kriterien haben Auswirkungen auf die Testbarkeit eines Code-Moduls:","title":"Testbarkeit"},{"location":"module-2/testability/#code-aufteilung-entsprechend-seines-zwecks","text":"Um eine h\u00f6here Cohesion innerhalb des eigenen Codes zu erreichen ist es oft sinnvoll diesen entlang von Aufgabenbereichen zu trennen und aufzuteilen. Besonders sinnvoll ist dies beispielsweise bei der Trennung zwischen Code zur Steuerung der grafischen Oberfl\u00e4che und Code zur Ausf\u00fchrung von Gesch\u00e4ftsprozessen oder anderen Arten von Berechnungen. Ist der Code entsprechend getrennt, so ist es deutlich einfacher automatiserte Tests (mindestens f\u00fcr Teile der Applikation) zu schreiben, da die einzelnen Module automatisch jeweils weniger Funktionalit\u00e4ten und Verantwortlichkeiten haben.","title":"Code-Aufteilung entsprechend seines Zwecks"},{"location":"module-2/testability/#dependency-inversion","text":"Das Prinzip der Dependency Inversion ist eine Strategie um eine \"loose Coupling\" von Modulen im Code zu erreichen. Ausgangslage ist hierbei meistens eine harte Abh\u00e4ngigkeit von 2 Klassen, bei denen mindestes eine Klasse ohne die andere nicht funktionieren kann und daher auch nicht unabh\u00e4ngig getestet werden kann: Wendet man nun das Konzept der Dependency Inversion an, so wird es notwendig eine zus\u00e4tzliche Abstraktios-Ebene einzuf\u00fchren, meistens in Form eines Interface oder Abstrakter Klasse. W\u00e4hrend die eine Klasse nun das Interface implementiert und dementsprechend \u00fcber die Methoden des Interface aufgerufen werden kann, so \"kennt\" die aufrufende Klasse nun ebenfalls nur noch das Interface und ruft die Methoden von diesem auf. Welche konkrete Implementation sich dahinter verbirgt ist nicht mehr bekannt oder relevant. Durch die zus\u00e4tzliche Abstraktions-Ebene k\u00f6nnen nun in einem Unit Test sehr einfach \"Test-Implementationen\" unseres Interfaces erstellt und f\u00fcr die Tests genutzt werden.","title":"Dependency Inversion"},{"location":"module-2/testability/#pure-functions","text":"Eine Funktion oder ein Modul ist dann \"pure\", wenn sie/er bei gleichen Parametern immer die gleichen Ergebnisse liefert und keine Auswirkungen oder Abh\u00e4ngigkeiten auf \"externe\" Module hat.","title":"Pure Functions"},{"location":"module-2/testability/#beispiel-einer-pure-function","text":"Diese Funktion ist pure, da sie keinerlei Kontakt \"nach au\u00dfen\" hat mit Ausnahme von den 2 Parametern. Diese Funktion ist somit sehr einfach testbar, da wir keine komplexen Voraussetzungen erf\u00fcllen m\u00fcssen um sie auszuf\u00fchren. public int sum(int numberA, int numberB) { return numberA + numberB; }","title":"Beispiel einer pure Function"},{"location":"module-2/testability/#beispiel-von-non-pure-funktionen","text":"Diese beiden Funktion sind nicht \"pure\", da sie sie neben ihrer Parameter auch noch externe Aufrufe bzw Ver\u00e4nderungen durchf\u00fchrt. // Um diese Funktion richtig zu testen brauchen wir eine reale oder simulierte \"Datenbank\", // welche uns den gew\u00fcnschten Wert zur\u00fcckliefert public String generateMessageOfTheDay(String name) { String prefix = \"Hello \" + name + \" this is your message of the day! \\n\"; String messageOfTheDay = database.getMessageOfTheDayTemplate(); return prefix + messageOfTheDay; } // Um diese Funktion richtig zu testen brauchen wir eine reale oder simulierte \"Datenbank\", // welche wir nach Ausf\u00fchrung \u00fcberpr\u00fcfen k\u00f6nnen ob das neue Datum gesetzt wurde. public void updateDatabase() { Date now = new Date(); database.setTimestampOfLastUpdate( now ); } F\u00fcr einen besser testbaren Code ist es oft sinnvoll seine Funktionen oder Module in pure und unpure Teile aufzuteilen - hierdurch wird zumindest ein Teil der Applikation sehr einfach testbar. Um etwa das Message-Of-The-Day-Beispiel aufzuteilen k\u00f6nnten die Funktionalit\u00e4t in 2 Funktionen aufgeteilt werden: // Wir haben die non-pure Funktionalit\u00e4ten in diese Funktion verlagert public void printMessageOfTheDay() { String name = \"Skippy the Magnificent\"; String messageOfTheDayTemplate = database.getMessageOfTheDayTemplate(); String messageOfTheday = generateMessageOfTheDay(messageOfTheDayTemplate, name); System.out.println(messageOfTheDay); } // Diese Funktion ist pure public String generateMessageOfTheDay(String messageOfTheDayTemplate, String name) { String prefix = \"Hello \" + name + \" this is your message of the day: \"; return prefix + messageOfTheDayTemplate; } @Test public void testMessageOfThDayGenerator() { String name = \"Filthy Monkey\"; String messageOfTheDay = \"Test 123\"; String expected = \"Hello Filthy Monkey this is your message of the day: Test 123\"; String actual = generateMessageOfTheDay(messageOfTheDay, name); AssertEquals(expected, actual); }","title":"Beispiel von non-pure Funktionen"},{"location":"module-3/code-reviews/","text":"Code Reviews Coming soon","title":"Code Reviews"},{"location":"module-3/code-reviews/#code-reviews","text":"Coming soon","title":"Code Reviews"},{"location":"module-3/exercise/","text":"Aufgaben Epic: Fdibamon Ziel dieser Aufgabe ist die Entwicklung des Spiels Fdibamon . In Fdibamon treten jeweils 2 Fdibamon (kleine aber sehr gef\u00e4hrliche Monster) in einer Arena gegeneinander an - und bek\u00e4mpfen sich bis eines der Fdibamon als Sieger hervor geht. Das Spiel soll via Pair Programming entwickelt werden und mit Unit Tests getestet werden. Bitte beachtet alles was wir bisher in vergangenen Modulen gelernt haben. Story 1 - Spielstart Motivation Als Spieler m\u00f6chte ich die zwei Fdibamon ausw\u00e4hlen k\u00f6nnen, damit diese in der Arena gegeneinander antreten Beschreibung Das Spiel soll eine (konstante) Liste an Fdibamon zur Verf\u00fcgung stellen, welche ein Spieler zum Kampf ausw\u00e4hlen kann. Ein Fdibamon hat hierbei die folgenden Eigenschaften \u2611\ufe0f Name (String) \u2611\ufe0f Hitpoints (Positive integer) \u2611\ufe0f Attack Power (Positive integer) Bei Start eines Spiels muss der User aus der Liste der Fdibamon exakt 2 ausw\u00e4hlen, damit diese sp\u00e4ter in der Arena gegeneinander antreten. Das ausw\u00e4hlen der Fdibamon kann entweder hardcoded im Code erfolgen oder (besser) via Kommandozeile erfolgen Akzeptanzkriterien \u2611\ufe0f Es gibt mindestens 5 Fdibamon zur Auswahl \u2611\ufe0f Jedes Fdibamon hat einen kreativen Namen \u2611\ufe0f Der Code ist im Git Story 2 - Der Kampf Motivation Als Spieler m\u00f6chte ich sobald einen Kampf starten k\u00f6nnen damit ich sehen kann, welches der beiden Fdibamon als Sieger hervorgeht. Beschreibung Ein Kampf in Fdibamon wird rundenweise ausgef\u00fchrt. In jeder Runde greifen beide Fdibamon das jeweils andere Fdibamon an. Der Kampf hierbei wird simuliert indem die Hitpoints des verteidigenden Fdibamon verringert werden auf Basis der Attack Power des angreifenden Fdibamon. Beide Fdibamon sind hierbei in jeder Runde sowohl Angreifer als auch Verteidiger! Hat ein Fdibamon keine Hitpoints mehr (0), so hat es den Kampf verloren und das Spiel ist beendet. Erreichen beide Fdibamon in der gleichen Runde 0 Hitpoints, so ist es ein Unentschieden. Akzeptanzkriterien \u2611\ufe0f A1: Der Spieler muss w\u00e4hrend jeder Runde dar\u00fcber informiert werden was passiert ist. \u2611\ufe0f A2: Der Spieler muss nach jeder Runde dar\u00fcber informiert werden wie der Zustand der beiden Fdibamon ist. \u2611\ufe0f A3: Am Ende des Kampfes sind die Hitpoints von mindestens einem Fdibamon 0 Story 3 - Der Kampfreport Motivation Als Spieler m\u00f6chte ich am Ende eines Kampfes eine Datei mit einem Kampfreport erhalen um meine spannenden Fdibamon-K\u00e4mpfe meinen Freunden zu zeigen. Beschreibung Ein Kampfreport soll eine einfache Textdatei sein die nach jedem Kampf erstellt wird. Der Dateiname soll sich hierbei aus den Namen der beiden Fdibamon sowohl dem aktuellen Datum und Uhrzeit zusammensetzen Akzeptanzkriterien \u2611\ufe0f A1: Der Dateiname wird generiert aus den Namen der beiden Fdibamon sowohl dem aktuellen Datum und Uhrzeit \u2611\ufe0f A2: Der Kampfreport ist eine einfache Text-Datei \u2611\ufe0f A3: Der Kampfreport enth\u00e4lt die Namen der Fdibamon \u2611\ufe0f A4: Der Kampfreport sagt welches Fdibamon gewonnen hat (oder ob es ein Unentschieden gab) \u2611\ufe0f A5: Der Kampfreport sagt nach wievielen Runden der Kampf zu Ende war Story 4 - Spezialkr\u00e4fte Motivation Als Spieler m\u00f6chte ich, dass meine Fdibamon Spezialkr\u00e4fte einsetzen k\u00f6nnen damit die K\u00e4mpfe noch spannender werden. Beschreibung Die Spezialf\u00e4higkeit eines Fdibamo wird automatisch alle 5 Runden angewendet anstatt der normalen Angriffe . Es gibt hierbei 2 Arten von Spezialf\u00e4higkeiten: Power-Attack: Reduziert die Hitpoints des Ziels um 3 x (Attack Power) Jedi-Healing: Erh\u00f6ht die eigenen Hitpoints um 3 x (Attack Power) Alle anderen Regeln des Spiels bleiben bestehen. Akzeptanzkriterien \u2611\ufe0f A1: Jedes Fdibamon hat eine der beiden Spezialf\u00e4higkeiten \u2611\ufe0f A2: Der Kampfreport sagt, wie oft jedes Fdibamon eine Spezialf\u00e4higkeit angewendet hat \u2611\ufe0f A3: Ich werde w\u00e4hrend einer Runde dar\u00fcber informiert wenn eine Spezialf\u00e4higkeit angewendet wurde Story 5 - (Bonus) Zufallswerte Motivation Als Spieler m\u00f6chte ich, dass mehr Zufall in das Spiel eingebaut wird, damit die K\u00e4mpfe NOCH spannender werden Beschreibung Bisher hatte jeder Angriff eine Trefferwahrscheinlichkeit von 100% - dies macht die K\u00e4mpfe sehr einfach aber auch sehr langweilig, denn im Grunde ist schon vor Kampfbeginn klar, welches Fdibamon gewinnen wird. Um etwas mehr Spannung ins Spiel einzubauen f\u00fchren wir nun 2 weitere Werte ein: \u2611\ufe0f Hit Chance (Positive integer) \u2611\ufe0f Evasion Chance (Positive integer) Beide Zahlen stellen den oberen Bereich einer Zufallszahl dar, welche wir jede Runde neu kalkulieren. Ein Angriff ist dann erfolgreich, wenn die effektive Hit-Chance des Angreifers in einer Runde gr\u00f6\u00dfer ist als die effektive Evasion-Chance des Verteidigers. Ein Beispiel : Angreifer hat Hit Chance 70 Verteidiger hat Evasion Chance 50 Runde 1 Effective Hit Chance = Random(0..70) => 48 Effective Evasion Chance = Random(0..50) => 32 48 > 32 der Angriff war erfolgreich Akzeptanzkriterien \u2611\ufe0f A1: Jedes Fdibamon hat eine Hit- und Evasion Chance \u2611\ufe0f A2: Jede Runde werde ich informiert wie die effekiven Hit- und Evasion Chancen sind","title":"Aufgaben"},{"location":"module-3/exercise/#aufgaben","text":"","title":"Aufgaben"},{"location":"module-3/exercise/#epic-fdibamon","text":"Ziel dieser Aufgabe ist die Entwicklung des Spiels Fdibamon . In Fdibamon treten jeweils 2 Fdibamon (kleine aber sehr gef\u00e4hrliche Monster) in einer Arena gegeneinander an - und bek\u00e4mpfen sich bis eines der Fdibamon als Sieger hervor geht. Das Spiel soll via Pair Programming entwickelt werden und mit Unit Tests getestet werden. Bitte beachtet alles was wir bisher in vergangenen Modulen gelernt haben.","title":"Epic: Fdibamon"},{"location":"module-3/exercise/#story-1-spielstart","text":"","title":"Story 1 - Spielstart"},{"location":"module-3/exercise/#motivation","text":"Als Spieler m\u00f6chte ich die zwei Fdibamon ausw\u00e4hlen k\u00f6nnen, damit diese in der Arena gegeneinander antreten","title":"Motivation"},{"location":"module-3/exercise/#beschreibung","text":"Das Spiel soll eine (konstante) Liste an Fdibamon zur Verf\u00fcgung stellen, welche ein Spieler zum Kampf ausw\u00e4hlen kann. Ein Fdibamon hat hierbei die folgenden Eigenschaften \u2611\ufe0f Name (String) \u2611\ufe0f Hitpoints (Positive integer) \u2611\ufe0f Attack Power (Positive integer) Bei Start eines Spiels muss der User aus der Liste der Fdibamon exakt 2 ausw\u00e4hlen, damit diese sp\u00e4ter in der Arena gegeneinander antreten. Das ausw\u00e4hlen der Fdibamon kann entweder hardcoded im Code erfolgen oder (besser) via Kommandozeile erfolgen","title":"Beschreibung"},{"location":"module-3/exercise/#akzeptanzkriterien","text":"\u2611\ufe0f Es gibt mindestens 5 Fdibamon zur Auswahl \u2611\ufe0f Jedes Fdibamon hat einen kreativen Namen \u2611\ufe0f Der Code ist im Git","title":"Akzeptanzkriterien"},{"location":"module-3/exercise/#story-2-der-kampf","text":"","title":"Story 2 - Der Kampf"},{"location":"module-3/exercise/#motivation_1","text":"Als Spieler m\u00f6chte ich sobald einen Kampf starten k\u00f6nnen damit ich sehen kann, welches der beiden Fdibamon als Sieger hervorgeht.","title":"Motivation"},{"location":"module-3/exercise/#beschreibung_1","text":"Ein Kampf in Fdibamon wird rundenweise ausgef\u00fchrt. In jeder Runde greifen beide Fdibamon das jeweils andere Fdibamon an. Der Kampf hierbei wird simuliert indem die Hitpoints des verteidigenden Fdibamon verringert werden auf Basis der Attack Power des angreifenden Fdibamon. Beide Fdibamon sind hierbei in jeder Runde sowohl Angreifer als auch Verteidiger! Hat ein Fdibamon keine Hitpoints mehr (0), so hat es den Kampf verloren und das Spiel ist beendet. Erreichen beide Fdibamon in der gleichen Runde 0 Hitpoints, so ist es ein Unentschieden.","title":"Beschreibung"},{"location":"module-3/exercise/#akzeptanzkriterien_1","text":"\u2611\ufe0f A1: Der Spieler muss w\u00e4hrend jeder Runde dar\u00fcber informiert werden was passiert ist. \u2611\ufe0f A2: Der Spieler muss nach jeder Runde dar\u00fcber informiert werden wie der Zustand der beiden Fdibamon ist. \u2611\ufe0f A3: Am Ende des Kampfes sind die Hitpoints von mindestens einem Fdibamon 0","title":"Akzeptanzkriterien"},{"location":"module-3/exercise/#story-3-der-kampfreport","text":"","title":"Story 3 - Der Kampfreport"},{"location":"module-3/exercise/#motivation_2","text":"Als Spieler m\u00f6chte ich am Ende eines Kampfes eine Datei mit einem Kampfreport erhalen um meine spannenden Fdibamon-K\u00e4mpfe meinen Freunden zu zeigen.","title":"Motivation"},{"location":"module-3/exercise/#beschreibung_2","text":"Ein Kampfreport soll eine einfache Textdatei sein die nach jedem Kampf erstellt wird. Der Dateiname soll sich hierbei aus den Namen der beiden Fdibamon sowohl dem aktuellen Datum und Uhrzeit zusammensetzen","title":"Beschreibung"},{"location":"module-3/exercise/#akzeptanzkriterien_2","text":"\u2611\ufe0f A1: Der Dateiname wird generiert aus den Namen der beiden Fdibamon sowohl dem aktuellen Datum und Uhrzeit \u2611\ufe0f A2: Der Kampfreport ist eine einfache Text-Datei \u2611\ufe0f A3: Der Kampfreport enth\u00e4lt die Namen der Fdibamon \u2611\ufe0f A4: Der Kampfreport sagt welches Fdibamon gewonnen hat (oder ob es ein Unentschieden gab) \u2611\ufe0f A5: Der Kampfreport sagt nach wievielen Runden der Kampf zu Ende war","title":"Akzeptanzkriterien"},{"location":"module-3/exercise/#story-4-spezialkrafte","text":"","title":"Story 4 - Spezialkr\u00e4fte"},{"location":"module-3/exercise/#motivation_3","text":"Als Spieler m\u00f6chte ich, dass meine Fdibamon Spezialkr\u00e4fte einsetzen k\u00f6nnen damit die K\u00e4mpfe noch spannender werden.","title":"Motivation"},{"location":"module-3/exercise/#beschreibung_3","text":"Die Spezialf\u00e4higkeit eines Fdibamo wird automatisch alle 5 Runden angewendet anstatt der normalen Angriffe . Es gibt hierbei 2 Arten von Spezialf\u00e4higkeiten: Power-Attack: Reduziert die Hitpoints des Ziels um 3 x (Attack Power) Jedi-Healing: Erh\u00f6ht die eigenen Hitpoints um 3 x (Attack Power) Alle anderen Regeln des Spiels bleiben bestehen.","title":"Beschreibung"},{"location":"module-3/exercise/#akzeptanzkriterien_3","text":"\u2611\ufe0f A1: Jedes Fdibamon hat eine der beiden Spezialf\u00e4higkeiten \u2611\ufe0f A2: Der Kampfreport sagt, wie oft jedes Fdibamon eine Spezialf\u00e4higkeit angewendet hat \u2611\ufe0f A3: Ich werde w\u00e4hrend einer Runde dar\u00fcber informiert wenn eine Spezialf\u00e4higkeit angewendet wurde","title":"Akzeptanzkriterien"},{"location":"module-3/exercise/#story-5-bonus-zufallswerte","text":"","title":"Story 5 - (Bonus) Zufallswerte"},{"location":"module-3/exercise/#motivation_4","text":"Als Spieler m\u00f6chte ich, dass mehr Zufall in das Spiel eingebaut wird, damit die K\u00e4mpfe NOCH spannender werden","title":"Motivation"},{"location":"module-3/exercise/#beschreibung_4","text":"Bisher hatte jeder Angriff eine Trefferwahrscheinlichkeit von 100% - dies macht die K\u00e4mpfe sehr einfach aber auch sehr langweilig, denn im Grunde ist schon vor Kampfbeginn klar, welches Fdibamon gewinnen wird. Um etwas mehr Spannung ins Spiel einzubauen f\u00fchren wir nun 2 weitere Werte ein: \u2611\ufe0f Hit Chance (Positive integer) \u2611\ufe0f Evasion Chance (Positive integer) Beide Zahlen stellen den oberen Bereich einer Zufallszahl dar, welche wir jede Runde neu kalkulieren. Ein Angriff ist dann erfolgreich, wenn die effektive Hit-Chance des Angreifers in einer Runde gr\u00f6\u00dfer ist als die effektive Evasion-Chance des Verteidigers. Ein Beispiel : Angreifer hat Hit Chance 70 Verteidiger hat Evasion Chance 50 Runde 1 Effective Hit Chance = Random(0..70) => 48 Effective Evasion Chance = Random(0..50) => 32 48 > 32 der Angriff war erfolgreich","title":"Beschreibung"},{"location":"module-3/exercise/#akzeptanzkriterien_4","text":"\u2611\ufe0f A1: Jedes Fdibamon hat eine Hit- und Evasion Chance \u2611\ufe0f A2: Jede Runde werde ich informiert wie die effekiven Hit- und Evasion Chancen sind","title":"Akzeptanzkriterien"},{"location":"module-3/pair-programming/","text":"Pair Programming","title":"Pair Programming"},{"location":"module-3/pair-programming/#pair-programming","text":"","title":"Pair Programming"},{"location":"module-3/testing/","text":"Automatisiertes Testen Wie bereits in vergangenen Modulen gelernt, ist eines der wichtigsten Ziele des Clean Code, dass wir jederzeit sicherstellen k\u00f6nnen, dass unser Code korrekt ist. Code gilt hierbei dann als korrekt, wenn er das tut was urspr\u00fcnglich f\u00fcr jede Funktionalit\u00e4t spezifiziert worden ist. Warum dies mit der Zeit immer schwieriger wird W\u00e4hrend es am Anfang einer Applikation oft noch relativ einfach ist zu pr\u00fcfen, ob ein Code korrekt funktioniert, so wird dies mit steigener Komplexit\u00e4t und Gr\u00f6\u00dfe einer Applikation immer und immer schwieriger. Dies liegt vor allem daran, dass die Beziehungen zwischen den Code-Modulen immer komplexer und un\u00fcbersichtlicher werden - so kann eine kleine \u00c4nderung in Modul A pl\u00f6tzlich gro\u00dfe Probleme in Modul B verursachen. In der Praxis f\u00fchrt man daher in regelm\u00e4ssigen Abst\u00e4nden sogenannte Regressions-Tests durch. Diese Regressions-Tests haben das Ziel sicherzustellen, dass \"alte\" Funktionalit\u00e4ten immer noch so funktionieren wie sie sollen. Dies kann mit steigener Komplexit\u00e4t der Applikation aber sehr aufw\u00e4ndig werden, da sehr viele Menschen hiermit \u00fcber einen langen Zeitraum besch\u00e4ftigt werden. Zur Veranschaulichung: Ein deutsches Bahnunternehmen rechnete im Jahr 2015 f\u00fcr das Regressions-Testen einer Applikation mit Kosten von 160.000 EUR und einer Dauer von mehreren Wochen. Diese Regressions-Tests wurden mehrmals pro Jahr durchgef\u00fchrt - f\u00fcr hunderte Applikationen. Die L\u00f6sung Um diesen Aufwand (und die Kosten) zu begrenzen werden in der Praxis Tests so weit wie m\u00f6glich automatisiert - dies hat den Vorteil, dass Tests im besten Fall nur einmal entwickelt werden m\u00fcssen und danach de facto ohne weitere Kosten und in sehr kurzer Zeit ihre Ergebnisse liefern. Hierdurch kann sehr viel schneller Feedback daf\u00fcr eingeholt werden, ob eine Applikation noch korrekt funktioniert. Hierbei kommen verschiedene Arten von Tests zum Einsatz, die sich alle in ihrer Perspektive auf die Applikation aber auch auf andere Arten und Weisen unterscheiden. Unit Tests Als Unit Tests bezeichnet man Tests die nur kleine Einheiten von Code auf einmal testen, meistens nur eine einzelne Funktion. Unit Tests werden ausschlie\u00dflich von Entwicklern geschrieben und unterst\u00fctzen hierbei sowohl beim Regression-Testing als auch w\u00e4hrend der Entwicklung selbst. Da Unit Tests aber Funktionen in Isolation testen - und oft sehr viel gemocked (simuliert) wird um sie ausf\u00fchren zu k\u00f6nnen - haben sie gewisse Limitationen. Unit Tests k\u00f6nnen gute Aussagen dar\u00fcber treffen ob eine Funktion selbst funktioniert, sie k\u00f6nnen aber kaum eine Aussage dar\u00fcber treffen ob eine Funktion noch kompatibel zum restlichen System ist. \u2705 Sehr einfach und schnell zu erstellen \u2705 K\u00f6nnen sehr schnell ausgef\u00fchrt werden, geben also schnelles Feedback \u2705 Tests geben sehr verl\u00e4ssliches Feedback \u2705 Fehler die hier aufkommen k\u00f6nnen sehr einfach identifizier werden \u274c Unit Tests testen Funktionen nur auf kleinster Ebene \u274c Unit Tests k\u00f6nnen keine Aussage dar\u00fcber treffen ob Module zusammen funktionieren Integration Tests Integration Tests gehen einen Schritt weiter als Unit Tests. Mit Hilfe von Integration Tests pr\u00fcfen wir ob unsere Code-Module nicht nur f\u00fcr sich alleine sondern auch gemeinsam funkionieren. Beim Integration Testing werden hierbei also zwei oder mehr Module gestartet, welche dann gemeinsam automatisiert einen Testfall ausf\u00fchren. Integration Tests sind hierbei ein Zwischenschritt zwischen Unit Tests und E2E Tests, weil sie zwar komplexere Prozesse testen, dies aber nicht auf die Art tun wie es ein Mensch in der Regel tun w\u00fcrde. Integration Tests interagieren also in der Regel nicht mit einer grafischen Oberfl\u00e4che etc. (wobei es hier Ausnahmen gibt). \u2705 Kann komplexe Szenarien testen \u2705 Gibt relativ pr\u00e4zises Feedback \u00fcber die Fehler-Ursache \u274c Aufw\u00e4ndig/teuer zu supporten \u274c Erstellung von Tests kann unter Umst\u00e4nden aufw\u00e4ndig sein \u274c Manchmal zeitaufw\u00e4ndig in der Ausf\u00fchrung E2E Tests End-to-End Tests (E2E) sind automatisierte Tests die eine Applikation fast wie ein Mensch bedienen. Technisch basieren sie meistens auf Automatisierungs-Werkzeugen die einen (fast) normalen Browser oder \u00e4hnliches benutzen um ganz normale Mausklicks, Tastatureingaben etc. durchzuf\u00fchren. Hierbei wird unsere Applikation so installiert und benutzt, wie sie auch im realen Leben benutzt werden w\u00fcrde. E2E Tests werden in manchen Unternehmen von den Entwicklern selbst geschrieben, in anderen Unternehmen aber \u2705 Kann komplexe Szenarien testen, von Anfang bis Ende \u2705 Bedient die Applikation wie ein echter Mensch \u274c Sehr aufw\u00e4ndig/teuer zu supporten \u274c Tests werden \u00fcber die Zeit \"flaky\" (sogar kleine \u00c4nderung in z.B. einem Text k\u00f6nnen zu Problemen f\u00fchren) \u274c Sehr zeitaufw\u00e4ndig in der Ausf\u00fchrung (oft mehrere Stunden), geben also kein direktes Feedback \u274c Die Ursache f\u00fcr Probleme die hier auftreten k\u00f6nnen oft nur sehr schwierig gefunden werden Wie und wieviel sollte man testen? Wie viel und was genau getestet werden sollte - und auf welche Art und Weise man dies testet - ist in jeder Organisation und f\u00fcr jede Applikation eine schwierige Frage. Jede Applikation hat ihre eigenen Anforderungen an die Menge an Fehlern die noch akzeptabel sind: W\u00e4hrend ein kleiner Bug auf einer Hotel-Website wahrscheinlich kein gro\u00dfes Problem ist, sieht dies f\u00fcr die Steuerungs-Software f\u00fcr einen medizinischen Roboter ganz anders aus. Absolute Aussagen wie \"Unit Tests f\u00fcr mindestens 80% des Codes\" sind daher in der Praxis zwar oft verbreitet aber meistens eher ungeeignet. F\u00fcr jede Applikation sollt konkret entschieden werden was genau getestet werden soll und welche Techniken hierf\u00fcr zum Einsatz kommen sollten.","title":"Automatisiertes Testen"},{"location":"module-3/testing/#automatisiertes-testen","text":"Wie bereits in vergangenen Modulen gelernt, ist eines der wichtigsten Ziele des Clean Code, dass wir jederzeit sicherstellen k\u00f6nnen, dass unser Code korrekt ist. Code gilt hierbei dann als korrekt, wenn er das tut was urspr\u00fcnglich f\u00fcr jede Funktionalit\u00e4t spezifiziert worden ist.","title":"Automatisiertes Testen"},{"location":"module-3/testing/#warum-dies-mit-der-zeit-immer-schwieriger-wird","text":"W\u00e4hrend es am Anfang einer Applikation oft noch relativ einfach ist zu pr\u00fcfen, ob ein Code korrekt funktioniert, so wird dies mit steigener Komplexit\u00e4t und Gr\u00f6\u00dfe einer Applikation immer und immer schwieriger. Dies liegt vor allem daran, dass die Beziehungen zwischen den Code-Modulen immer komplexer und un\u00fcbersichtlicher werden - so kann eine kleine \u00c4nderung in Modul A pl\u00f6tzlich gro\u00dfe Probleme in Modul B verursachen. In der Praxis f\u00fchrt man daher in regelm\u00e4ssigen Abst\u00e4nden sogenannte Regressions-Tests durch. Diese Regressions-Tests haben das Ziel sicherzustellen, dass \"alte\" Funktionalit\u00e4ten immer noch so funktionieren wie sie sollen. Dies kann mit steigener Komplexit\u00e4t der Applikation aber sehr aufw\u00e4ndig werden, da sehr viele Menschen hiermit \u00fcber einen langen Zeitraum besch\u00e4ftigt werden. Zur Veranschaulichung: Ein deutsches Bahnunternehmen rechnete im Jahr 2015 f\u00fcr das Regressions-Testen einer Applikation mit Kosten von 160.000 EUR und einer Dauer von mehreren Wochen. Diese Regressions-Tests wurden mehrmals pro Jahr durchgef\u00fchrt - f\u00fcr hunderte Applikationen.","title":"Warum dies mit der Zeit immer schwieriger wird"},{"location":"module-3/testing/#die-losung","text":"Um diesen Aufwand (und die Kosten) zu begrenzen werden in der Praxis Tests so weit wie m\u00f6glich automatisiert - dies hat den Vorteil, dass Tests im besten Fall nur einmal entwickelt werden m\u00fcssen und danach de facto ohne weitere Kosten und in sehr kurzer Zeit ihre Ergebnisse liefern. Hierdurch kann sehr viel schneller Feedback daf\u00fcr eingeholt werden, ob eine Applikation noch korrekt funktioniert. Hierbei kommen verschiedene Arten von Tests zum Einsatz, die sich alle in ihrer Perspektive auf die Applikation aber auch auf andere Arten und Weisen unterscheiden.","title":"Die L\u00f6sung"},{"location":"module-3/testing/#unit-tests","text":"Als Unit Tests bezeichnet man Tests die nur kleine Einheiten von Code auf einmal testen, meistens nur eine einzelne Funktion. Unit Tests werden ausschlie\u00dflich von Entwicklern geschrieben und unterst\u00fctzen hierbei sowohl beim Regression-Testing als auch w\u00e4hrend der Entwicklung selbst. Da Unit Tests aber Funktionen in Isolation testen - und oft sehr viel gemocked (simuliert) wird um sie ausf\u00fchren zu k\u00f6nnen - haben sie gewisse Limitationen. Unit Tests k\u00f6nnen gute Aussagen dar\u00fcber treffen ob eine Funktion selbst funktioniert, sie k\u00f6nnen aber kaum eine Aussage dar\u00fcber treffen ob eine Funktion noch kompatibel zum restlichen System ist. \u2705 Sehr einfach und schnell zu erstellen \u2705 K\u00f6nnen sehr schnell ausgef\u00fchrt werden, geben also schnelles Feedback \u2705 Tests geben sehr verl\u00e4ssliches Feedback \u2705 Fehler die hier aufkommen k\u00f6nnen sehr einfach identifizier werden \u274c Unit Tests testen Funktionen nur auf kleinster Ebene \u274c Unit Tests k\u00f6nnen keine Aussage dar\u00fcber treffen ob Module zusammen funktionieren","title":"Unit Tests"},{"location":"module-3/testing/#integration-tests","text":"Integration Tests gehen einen Schritt weiter als Unit Tests. Mit Hilfe von Integration Tests pr\u00fcfen wir ob unsere Code-Module nicht nur f\u00fcr sich alleine sondern auch gemeinsam funkionieren. Beim Integration Testing werden hierbei also zwei oder mehr Module gestartet, welche dann gemeinsam automatisiert einen Testfall ausf\u00fchren. Integration Tests sind hierbei ein Zwischenschritt zwischen Unit Tests und E2E Tests, weil sie zwar komplexere Prozesse testen, dies aber nicht auf die Art tun wie es ein Mensch in der Regel tun w\u00fcrde. Integration Tests interagieren also in der Regel nicht mit einer grafischen Oberfl\u00e4che etc. (wobei es hier Ausnahmen gibt). \u2705 Kann komplexe Szenarien testen \u2705 Gibt relativ pr\u00e4zises Feedback \u00fcber die Fehler-Ursache \u274c Aufw\u00e4ndig/teuer zu supporten \u274c Erstellung von Tests kann unter Umst\u00e4nden aufw\u00e4ndig sein \u274c Manchmal zeitaufw\u00e4ndig in der Ausf\u00fchrung","title":"Integration Tests"},{"location":"module-3/testing/#e2e-tests","text":"End-to-End Tests (E2E) sind automatisierte Tests die eine Applikation fast wie ein Mensch bedienen. Technisch basieren sie meistens auf Automatisierungs-Werkzeugen die einen (fast) normalen Browser oder \u00e4hnliches benutzen um ganz normale Mausklicks, Tastatureingaben etc. durchzuf\u00fchren. Hierbei wird unsere Applikation so installiert und benutzt, wie sie auch im realen Leben benutzt werden w\u00fcrde. E2E Tests werden in manchen Unternehmen von den Entwicklern selbst geschrieben, in anderen Unternehmen aber \u2705 Kann komplexe Szenarien testen, von Anfang bis Ende \u2705 Bedient die Applikation wie ein echter Mensch \u274c Sehr aufw\u00e4ndig/teuer zu supporten \u274c Tests werden \u00fcber die Zeit \"flaky\" (sogar kleine \u00c4nderung in z.B. einem Text k\u00f6nnen zu Problemen f\u00fchren) \u274c Sehr zeitaufw\u00e4ndig in der Ausf\u00fchrung (oft mehrere Stunden), geben also kein direktes Feedback \u274c Die Ursache f\u00fcr Probleme die hier auftreten k\u00f6nnen oft nur sehr schwierig gefunden werden","title":"E2E Tests"},{"location":"module-3/testing/#wie-und-wieviel-sollte-man-testen","text":"Wie viel und was genau getestet werden sollte - und auf welche Art und Weise man dies testet - ist in jeder Organisation und f\u00fcr jede Applikation eine schwierige Frage. Jede Applikation hat ihre eigenen Anforderungen an die Menge an Fehlern die noch akzeptabel sind: W\u00e4hrend ein kleiner Bug auf einer Hotel-Website wahrscheinlich kein gro\u00dfes Problem ist, sieht dies f\u00fcr die Steuerungs-Software f\u00fcr einen medizinischen Roboter ganz anders aus. Absolute Aussagen wie \"Unit Tests f\u00fcr mindestens 80% des Codes\" sind daher in der Praxis zwar oft verbreitet aber meistens eher ungeeignet. F\u00fcr jede Applikation sollt konkret entschieden werden was genau getestet werden soll und welche Techniken hierf\u00fcr zum Einsatz kommen sollten.","title":"Wie und wieviel sollte man testen?"},{"location":"module-4/introduction/","text":"DevOps Coming soon :)","title":"DevOps"},{"location":"module-4/introduction/#devops","text":"Coming soon :)","title":"DevOps"},{"location":"module-5/introduction/","text":"Eine Exkursion in die Welt der Agilit\u00e4t Powerpoint","title":"Eine Exkursion in die Welt der Agilit\u00e4t"},{"location":"module-5/introduction/#eine-exkursion-in-die-welt-der-agilitat","text":"Powerpoint","title":"Eine Exkursion in die Welt der Agilit\u00e4t"},{"location":"module-6/behavioral-patterns/","text":"Behavioral Patterns Observer Pattern Strategy Pattern","title":"Behavioral Patterns"},{"location":"module-6/behavioral-patterns/#behavioral-patterns","text":"Observer Pattern Strategy Pattern","title":"Behavioral Patterns"},{"location":"module-6/creational-patterns/","text":"Creational Patterns Creational Patterns behandeln allesamt das Erstellen von Objekten oder \u00e4hnlichen Datenstrukturen. Sie f\u00f6rdern hierbei die Flexibilit\u00e4t als auch die Widerverwendbarkeit von Code. Hier einige Beispiele: Prototype Pattern Singleton Pattern","title":"Creational Patterns"},{"location":"module-6/creational-patterns/#creational-patterns","text":"Creational Patterns behandeln allesamt das Erstellen von Objekten oder \u00e4hnlichen Datenstrukturen. Sie f\u00f6rdern hierbei die Flexibilit\u00e4t als auch die Widerverwendbarkeit von Code. Hier einige Beispiele: Prototype Pattern Singleton Pattern","title":"Creational Patterns"},{"location":"module-6/introduction/","text":"Design Patterns Was sind Design Patterns? Design Patterns sind typische L\u00f6sungen zu Problemen die in der Software-Entwicklung immer und immer wieder in \u00e4hnlicher Form vorkommen. Design Patterns sind hierbei in der Regel unabh\u00e4ngig von bestimmten Programmiersprachen, Branchen oder Applikationstypen sondern k\u00f6nnen in de facto jedem Umfeld angewendet werden. Welche Vorteile bringen Design Patterns? Design Patterns bringen einem Entwickler gleich mehrere Vorteile auf einmal. Der offensichtlichste Vorteil eines Design Patterns ist, dass es ein bestimmtes Problem l\u00f6st auf das ein Entwickler mit sehr hoher Wahrscheinlichkeit w\u00e4hrend seiner Karriere sto\u00dfen wird - wom\u00f6glich sogar regelm\u00e4\u00dfig. Der Entwickler muss hierdurch nicht immer wieder \"das Rad neu erfinden\". Durch die Nutzung eines standardisierten und bekannten Design Patterns ist die Kommunikation mit anderen Entwicklern sehr viel einfacher. Ein anderer Entwickler wird sofort verstehen wenn man sagt, dass man f\u00fcr ein bestimmtes Szenario einfach \"das Singleton-Pattern benutzen kann\". Aufgrund der Verbreitung von Design Patterns sind diverse Code-Beispiele oder sogar schon fertige L\u00f6sungen im Internet f\u00fcr bestimmte Probleme und bestimmte Programmiersprachen verf\u00fcgbar. Klassifizierungen Design Patterns unterscheiden sich voneinander sowohl in ihrer Komplexit\u00e4t als auch in der Breite ihrer Anwendbarkeit. Zudem k\u00f6nnen Design Patterns in der Regel in eine von 3 Gruppen eingeteilt werden: Creational Patterns Structural Patterns Behavioral Patterns","title":"Design Patterns"},{"location":"module-6/introduction/#design-patterns","text":"","title":"Design Patterns"},{"location":"module-6/introduction/#was-sind-design-patterns","text":"Design Patterns sind typische L\u00f6sungen zu Problemen die in der Software-Entwicklung immer und immer wieder in \u00e4hnlicher Form vorkommen. Design Patterns sind hierbei in der Regel unabh\u00e4ngig von bestimmten Programmiersprachen, Branchen oder Applikationstypen sondern k\u00f6nnen in de facto jedem Umfeld angewendet werden.","title":"Was sind Design Patterns?"},{"location":"module-6/introduction/#welche-vorteile-bringen-design-patterns","text":"Design Patterns bringen einem Entwickler gleich mehrere Vorteile auf einmal. Der offensichtlichste Vorteil eines Design Patterns ist, dass es ein bestimmtes Problem l\u00f6st auf das ein Entwickler mit sehr hoher Wahrscheinlichkeit w\u00e4hrend seiner Karriere sto\u00dfen wird - wom\u00f6glich sogar regelm\u00e4\u00dfig. Der Entwickler muss hierdurch nicht immer wieder \"das Rad neu erfinden\". Durch die Nutzung eines standardisierten und bekannten Design Patterns ist die Kommunikation mit anderen Entwicklern sehr viel einfacher. Ein anderer Entwickler wird sofort verstehen wenn man sagt, dass man f\u00fcr ein bestimmtes Szenario einfach \"das Singleton-Pattern benutzen kann\". Aufgrund der Verbreitung von Design Patterns sind diverse Code-Beispiele oder sogar schon fertige L\u00f6sungen im Internet f\u00fcr bestimmte Probleme und bestimmte Programmiersprachen verf\u00fcgbar.","title":"Welche Vorteile bringen Design Patterns?"},{"location":"module-6/introduction/#klassifizierungen","text":"Design Patterns unterscheiden sich voneinander sowohl in ihrer Komplexit\u00e4t als auch in der Breite ihrer Anwendbarkeit. Zudem k\u00f6nnen Design Patterns in der Regel in eine von 3 Gruppen eingeteilt werden: Creational Patterns Structural Patterns Behavioral Patterns","title":"Klassifizierungen"},{"location":"module-6/structural-patterns/","text":"Structural Patterns Structural Patterns organisieren das Zusammenspiel zwischen mehreren Objekten und deren gemeinsamen Strukturen. Sie organisieren die Kommunikation zwischen verschiedenen Objekten mit dem Ziel die Strukturen flexibel und effizient zu halten. Adapter Pattern Facade Pattern","title":"Structural Patterns"},{"location":"module-6/structural-patterns/#structural-patterns","text":"Structural Patterns organisieren das Zusammenspiel zwischen mehreren Objekten und deren gemeinsamen Strukturen. Sie organisieren die Kommunikation zwischen verschiedenen Objekten mit dem Ziel die Strukturen flexibel und effizient zu halten. Adapter Pattern Facade Pattern","title":"Structural Patterns"},{"location":"module-6/behavioral-patterns/observer/","text":"Observer Pattern public class SoccerGame { private List<Observer> observers = new ArrayList<Observer>(); private String currentStandings = \"1 : 2\"; public void updateStandings(String newStandings) { this.currentStandings = new Standings(); notifyAllObservers(); } public String getCurrentStandings() { return this.currentStandings; } public void attach(Observer observer){ observers.add(observer); } public void notifyAllObservers(){ for (Observer observer : observers) { observer.update(); } } } public abstract class Observer { protected SoccerGame game; public abstract void update(); } public class GermanTVAnnouncer extends Observer { public GermanTVAnnouncer(SoccerGame game) { this.game = game; } @Override public void update() { System.out.println(\"Der neue Spielstand ist: \" + game.getCurrentStandings()); } } public class BritishTVAnnouncer extends Observer { public GermanTVAnnouncer(SoccerGame game) { this.game = game; } @Override public void update() { System.out.println(\"Oy Mate, they be playin \" + game.getCurrentStandings()); } }","title":"Observer Pattern"},{"location":"module-6/behavioral-patterns/observer/#observer-pattern","text":"public class SoccerGame { private List<Observer> observers = new ArrayList<Observer>(); private String currentStandings = \"1 : 2\"; public void updateStandings(String newStandings) { this.currentStandings = new Standings(); notifyAllObservers(); } public String getCurrentStandings() { return this.currentStandings; } public void attach(Observer observer){ observers.add(observer); } public void notifyAllObservers(){ for (Observer observer : observers) { observer.update(); } } } public abstract class Observer { protected SoccerGame game; public abstract void update(); } public class GermanTVAnnouncer extends Observer { public GermanTVAnnouncer(SoccerGame game) { this.game = game; } @Override public void update() { System.out.println(\"Der neue Spielstand ist: \" + game.getCurrentStandings()); } } public class BritishTVAnnouncer extends Observer { public GermanTVAnnouncer(SoccerGame game) { this.game = game; } @Override public void update() { System.out.println(\"Oy Mate, they be playin \" + game.getCurrentStandings()); } }","title":"Observer Pattern"},{"location":"module-6/behavioral-patterns/strategy/","text":"","title":"Strategy"},{"location":"module-6/creational-patterns/prototype/","text":"Prototype Pattern Das Prototype Pattern beschreibt einen Mechanismus zum Kopieren von Objekten ohne deren konkrete Implementation zu kennen (oder ggf. sogar darauf zugreifen zu k\u00f6nnen). Das Prototype Pattern kann in Java sehr einfach angewendet werden indem eine abstrakte Klasse das \"Cloneable\" Interface extended und alle Subklassen die dazugeh\u00f6rige copy() Methode implementieren. public class Animal implements Cloneable { // ... public abstract Animal clone(); } public class Bird extends Animal { // ... @Override public Animal clone() { Bird clone = new Bird(); clone.setWingspan(this.getWingspan()); return clone; } } public class Fish extends Animal { // ... @Override public Animal clone() { Fish clone = new Fish(); clone.setLivesInSaltwater(this.getLivesInSaltwater()); return clone; } } Zur\u00fcck zu den Creational Patterns","title":"Prototype Pattern"},{"location":"module-6/creational-patterns/prototype/#prototype-pattern","text":"Das Prototype Pattern beschreibt einen Mechanismus zum Kopieren von Objekten ohne deren konkrete Implementation zu kennen (oder ggf. sogar darauf zugreifen zu k\u00f6nnen). Das Prototype Pattern kann in Java sehr einfach angewendet werden indem eine abstrakte Klasse das \"Cloneable\" Interface extended und alle Subklassen die dazugeh\u00f6rige copy() Methode implementieren. public class Animal implements Cloneable { // ... public abstract Animal clone(); } public class Bird extends Animal { // ... @Override public Animal clone() { Bird clone = new Bird(); clone.setWingspan(this.getWingspan()); return clone; } } public class Fish extends Animal { // ... @Override public Animal clone() { Fish clone = new Fish(); clone.setLivesInSaltwater(this.getLivesInSaltwater()); return clone; } } Zur\u00fcck zu den Creational Patterns","title":"Prototype Pattern"},{"location":"module-6/creational-patterns/singleton/","text":"Singleton Pattern Das Singleton Pattern kontrolliert/beschr\u00e4nkt die Erstellung von Objekten einer Klasse auf nur eine einzige Instanz. Dies ist sinnvoll in Szenarios wo mehrere Instanzen einer Klasse unm\u00f6glich sind (etwa bei Kontroll-Objekten f\u00fcr einen physikalischen Drucker) oder aufgrund von Ressourcen-Kosten ungewollt sind (Verbindungen zu einer Datenbank). public class MySingleton { private static final MySingleton instance = new MySingleton(); // private constructor to avoid client applications using the constructor private MySingleton(){} public static MySingleton getInstance() { return instance; } } Das hier gezeigte Code-Snippet ist die einfachste Form eines Singletons unter Java und ist zur Veranschaulichung des Prinzips ausreichend. In der realen Welt h\u00e4tte dieser Code aber ein paar kleinere Probleme - diese k\u00f6nnen hier nachgelesen werden Zur\u00fcck zu den Creational Patterns","title":"Singleton Pattern"},{"location":"module-6/creational-patterns/singleton/#singleton-pattern","text":"Das Singleton Pattern kontrolliert/beschr\u00e4nkt die Erstellung von Objekten einer Klasse auf nur eine einzige Instanz. Dies ist sinnvoll in Szenarios wo mehrere Instanzen einer Klasse unm\u00f6glich sind (etwa bei Kontroll-Objekten f\u00fcr einen physikalischen Drucker) oder aufgrund von Ressourcen-Kosten ungewollt sind (Verbindungen zu einer Datenbank). public class MySingleton { private static final MySingleton instance = new MySingleton(); // private constructor to avoid client applications using the constructor private MySingleton(){} public static MySingleton getInstance() { return instance; } } Das hier gezeigte Code-Snippet ist die einfachste Form eines Singletons unter Java und ist zur Veranschaulichung des Prinzips ausreichend. In der realen Welt h\u00e4tte dieser Code aber ein paar kleinere Probleme - diese k\u00f6nnen hier nachgelesen werden Zur\u00fcck zu den Creational Patterns","title":"Singleton Pattern"},{"location":"module-6/structural-patterns/adapter/","text":"Adapter Pattern Das Adapter Pattern verbindet 2 Typen von Objekten miteinander die eigentlich inkompatibel zueinander sind. Dies ist vor allem in Situationen relevant in denen wir 2 existierende Code-Module nutzen wollen, die jedoch ihrerseits nicht kompatibel zueinander sind und von uns nicht ver\u00e4ndert werden k\u00f6nnen. Wir alle kennen dies aus dem echten Leben beim Reisen in ferne L\u00e4nder, welche unterschiedliche Steckdosen benutzen. Weder k\u00f6nnen wir uns neue Elektroger\u00e4te f\u00fcr unsere Reise kaufen noch wird das Land seine Steckdosen f\u00fcr uns \u00e4ndern - was wir also brauchen ist ein Adapter. public interface AmericanPizzaRecipe { public float getAmountOfFlourInCups(); } public interface EuropeanPizzaRecipe { public int getAmountOfFlourInGrams(); } public class EuropeanPizzaChef { public static Pizza followRecipe(EuropeanPizzaRecipe recipe) { ... } } public class AmericanRecipeAdapter implements EuropeanPizzaRecipe { public AmericanRecipeAdapter(AmericanPizzaRecipe wrappedRecipe) { ... } @Override public int getAmountOfFlourInGrams() { // 1 cup of all-purpose flour is approximately 120 grams return wrappedRecipe.getAmountOfFlourInCups() * 120; } } public void makePizza() { AmericanPizzaRecipe chicagoDeepDishPizzaRecipe = ...; AmericanRecipeAdapter adaptedRecipe = new AmericanRecipeAdapter( chicagoDeepDishPizzaRecipe ); Pizza deepDishPizza = EuropeanPizzaChef.followRecipe(adaptedRecipe); } Zur\u00fcck zu den Structural Patterns","title":"Adapter Pattern"},{"location":"module-6/structural-patterns/adapter/#adapter-pattern","text":"Das Adapter Pattern verbindet 2 Typen von Objekten miteinander die eigentlich inkompatibel zueinander sind. Dies ist vor allem in Situationen relevant in denen wir 2 existierende Code-Module nutzen wollen, die jedoch ihrerseits nicht kompatibel zueinander sind und von uns nicht ver\u00e4ndert werden k\u00f6nnen. Wir alle kennen dies aus dem echten Leben beim Reisen in ferne L\u00e4nder, welche unterschiedliche Steckdosen benutzen. Weder k\u00f6nnen wir uns neue Elektroger\u00e4te f\u00fcr unsere Reise kaufen noch wird das Land seine Steckdosen f\u00fcr uns \u00e4ndern - was wir also brauchen ist ein Adapter. public interface AmericanPizzaRecipe { public float getAmountOfFlourInCups(); } public interface EuropeanPizzaRecipe { public int getAmountOfFlourInGrams(); } public class EuropeanPizzaChef { public static Pizza followRecipe(EuropeanPizzaRecipe recipe) { ... } } public class AmericanRecipeAdapter implements EuropeanPizzaRecipe { public AmericanRecipeAdapter(AmericanPizzaRecipe wrappedRecipe) { ... } @Override public int getAmountOfFlourInGrams() { // 1 cup of all-purpose flour is approximately 120 grams return wrappedRecipe.getAmountOfFlourInCups() * 120; } } public void makePizza() { AmericanPizzaRecipe chicagoDeepDishPizzaRecipe = ...; AmericanRecipeAdapter adaptedRecipe = new AmericanRecipeAdapter( chicagoDeepDishPizzaRecipe ); Pizza deepDishPizza = EuropeanPizzaChef.followRecipe(adaptedRecipe); } Zur\u00fcck zu den Structural Patterns","title":"Adapter Pattern"},{"location":"module-6/structural-patterns/facade/","text":"Facade Pattern Das Facade Pattern f\u00fcgt eine Abstraktions-Schicht vor ein komplexes System mit mehreren komplexen Funktionalit\u00e4ten ein. Es verfolgt hierbei vor allem das Ziel die komplexe Funktionalit\u00e4t zu verstecken und einem \"User\" (Entwickler) eine einfachere Schnittstelle zu bieten. Diese ist dann in der Regel deutlich einfacher, bietet aber meistens nicht mehr so viele M\u00f6glichkeiten. Als \"Bonus\" sorgt das Facade Pattern zudem daf\u00fcr, dass wir eine Entkoppelung zwischen einem Client und dem komplexen System erreichen. // Das komplexe System public class PizzaKitchen { // many fields public void preheatOven(int degrees) { ... } public void mixDough(String[] ingredients) { ... } public void letDoughRest(int minutes) { ... } public void addToSauce(String[] ingredients) { ... } public void stirSauce(); public void cookSauceFor(int minutes) { ... } public String[] getAvailableToppings() { ... } public void addTopping(String topping) { ... } public void bake(Pizza pizza) { ... } public Pizza deliverFinishedPizza(); // ... } // Unsere Facade public class PizzaFacade() { public Pizza orderPizzaFromDominos() { PizzaKitchen kitchen = new PizzaKitchen(); // somebody at Dominos does all the preparation // Add the mandatory ingredient for good pizza kitchen.addTopping(\"Pineapple\"); // do the baking and whatever else... return kitchen.deliverFinishedPizza(); } } Zur\u00fcck zu den Structural Patterns","title":"Facade Pattern"},{"location":"module-6/structural-patterns/facade/#facade-pattern","text":"Das Facade Pattern f\u00fcgt eine Abstraktions-Schicht vor ein komplexes System mit mehreren komplexen Funktionalit\u00e4ten ein. Es verfolgt hierbei vor allem das Ziel die komplexe Funktionalit\u00e4t zu verstecken und einem \"User\" (Entwickler) eine einfachere Schnittstelle zu bieten. Diese ist dann in der Regel deutlich einfacher, bietet aber meistens nicht mehr so viele M\u00f6glichkeiten. Als \"Bonus\" sorgt das Facade Pattern zudem daf\u00fcr, dass wir eine Entkoppelung zwischen einem Client und dem komplexen System erreichen. // Das komplexe System public class PizzaKitchen { // many fields public void preheatOven(int degrees) { ... } public void mixDough(String[] ingredients) { ... } public void letDoughRest(int minutes) { ... } public void addToSauce(String[] ingredients) { ... } public void stirSauce(); public void cookSauceFor(int minutes) { ... } public String[] getAvailableToppings() { ... } public void addTopping(String topping) { ... } public void bake(Pizza pizza) { ... } public Pizza deliverFinishedPizza(); // ... } // Unsere Facade public class PizzaFacade() { public Pizza orderPizzaFromDominos() { PizzaKitchen kitchen = new PizzaKitchen(); // somebody at Dominos does all the preparation // Add the mandatory ingredient for good pizza kitchen.addTopping(\"Pineapple\"); // do the baking and whatever else... return kitchen.deliverFinishedPizza(); } } Zur\u00fcck zu den Structural Patterns","title":"Facade Pattern"}]}