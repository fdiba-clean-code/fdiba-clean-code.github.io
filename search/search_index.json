{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"\"Clean Code\" - FDIBA - Winter Semester 2022 Liebe Studenten, in den kommenden Wochen werden wir zusammen erarbeiten was es bedeutet \"Clean Code\" zu schreiben. Wir werden hierbei analysieren was genau es bedeutet \"Clean Code\" zu produzieren und welche Voraussetzungen wir hierf\u00fcr erf\u00fcllen m\u00fcssen. Diese Dokumentation hierbei wird eine \"living documentation\" sein. Das bedeutet, sie wird kontinuierlich erweitert und auf agile Art und Weise nach und nach verbessert. Um nicht st\u00e4ndig das Rad neu zu erfinden werden wir viele existierenden Quelle nutzen und verlinken.","title":"Home"},{"location":"#clean-code-fdiba-winter-semester-2022","text":"Liebe Studenten, in den kommenden Wochen werden wir zusammen erarbeiten was es bedeutet \"Clean Code\" zu schreiben. Wir werden hierbei analysieren was genau es bedeutet \"Clean Code\" zu produzieren und welche Voraussetzungen wir hierf\u00fcr erf\u00fcllen m\u00fcssen. Diese Dokumentation hierbei wird eine \"living documentation\" sein. Das bedeutet, sie wird kontinuierlich erweitert und auf agile Art und Weise nach und nach verbessert. Um nicht st\u00e4ndig das Rad neu zu erfinden werden wir viele existierenden Quelle nutzen und verlinken.","title":"\"Clean Code\" - FDIBA - Winter Semester 2022"},{"location":"about/","text":"\u00dcber uns Jan Br\u00fcggmann - der Tech Guru Jan begann mit 14 Jahren Software zu entwickeln und hat in den ca. 25 Jahren seitdem eigentlich auch nie etwas anderes getan oder gelernt. Seine professionelle Karriere began mit Anfang 20 als IT-Berater f\u00fcr diverse deutsche Unternehmen, von Airlines bis hin zu Banken und der Immobilienwirtschaft. Seit etwas \u00fcber 10 Jahren ist er als Mitgr\u00fcnder und Partner der Unternehmens Blubito als CTO t\u00e4tig und \u00fcbernimmt hierbei alles um Technik, Ausbildung und Recruiting. Jan unterrichtet \"Clean Code\" an der TU Sofia und unterst\u00fctzt viele Kollegen als auch Kunden bei der L\u00f6sung diverser technischen Probleme. Klaus Riedel - der Agile Transformer Im Bereich agile Transformation gibt es wohl nichts, was Klaus nicht schon gesehen hat. \u00dcber 10 Jahre agile Transformationen in Organisationen wie Deutsche Bahn, Lufthansa, Microsoft, Bosch, Conrad Electronics, Bank of Scotland, Deutsche Bank und einige mehr lassen agile Transformationen leicht aussehen. Seit etwas \u00fcber 10 Jahren ist er als Mitgr\u00fcnder und Partner der Unternehmens Blubito als CEO t\u00e4tig und \u00fcbernimmt hierbei rund um die Organisation, Sales und Marketing. Klaus unterrichtet \u201eAgiles Projektmanagement\u201c sowie \"Clean Code\" an der TU Sofia, ist Autor des Blubito Blogs f\u00fcr agile Softwareentwicklung und des runScrum Blogs \u00fcber agiles Projektmanagement und betreut mehrere Teams als Product Owner. G\u00e4ste Sp\u00e4ter mehr...","title":"\u00dcber uns"},{"location":"about/#uber-uns","text":"","title":"\u00dcber uns"},{"location":"about/#jan-bruggmann-der-tech-guru","text":"Jan begann mit 14 Jahren Software zu entwickeln und hat in den ca. 25 Jahren seitdem eigentlich auch nie etwas anderes getan oder gelernt. Seine professionelle Karriere began mit Anfang 20 als IT-Berater f\u00fcr diverse deutsche Unternehmen, von Airlines bis hin zu Banken und der Immobilienwirtschaft. Seit etwas \u00fcber 10 Jahren ist er als Mitgr\u00fcnder und Partner der Unternehmens Blubito als CTO t\u00e4tig und \u00fcbernimmt hierbei alles um Technik, Ausbildung und Recruiting. Jan unterrichtet \"Clean Code\" an der TU Sofia und unterst\u00fctzt viele Kollegen als auch Kunden bei der L\u00f6sung diverser technischen Probleme.","title":"Jan Br\u00fcggmann - der Tech Guru"},{"location":"about/#klaus-riedel-der-agile-transformer","text":"Im Bereich agile Transformation gibt es wohl nichts, was Klaus nicht schon gesehen hat. \u00dcber 10 Jahre agile Transformationen in Organisationen wie Deutsche Bahn, Lufthansa, Microsoft, Bosch, Conrad Electronics, Bank of Scotland, Deutsche Bank und einige mehr lassen agile Transformationen leicht aussehen. Seit etwas \u00fcber 10 Jahren ist er als Mitgr\u00fcnder und Partner der Unternehmens Blubito als CEO t\u00e4tig und \u00fcbernimmt hierbei rund um die Organisation, Sales und Marketing. Klaus unterrichtet \u201eAgiles Projektmanagement\u201c sowie \"Clean Code\" an der TU Sofia, ist Autor des Blubito Blogs f\u00fcr agile Softwareentwicklung und des runScrum Blogs \u00fcber agiles Projektmanagement und betreut mehrere Teams als Product Owner.","title":"Klaus Riedel - der Agile Transformer"},{"location":"about/#gaste","text":"Sp\u00e4ter mehr...","title":"G\u00e4ste"},{"location":"module-1/comments/","text":"","title":"Kommentare"},{"location":"module-1/debugging/","text":"","title":"Debugging"},{"location":"module-1/git/","text":"Was ist Source Control? Source Control beschreibt die Versionierung von Source Code, also das Speichern aller Code-Dateien zu einem bestimmten Zeitpunkt. Das Source Control System hat hierbei die Aufgabe sicherzustellen, dass ein Nutzer auch sp\u00e4ter zu einer fr\u00fcheren Version seines Source Codes zur\u00fcckkehren kann - etwa um zu Vergleichen was sich ge\u00e4ndert hat oder um komplett auf eine fr\u00fchere Version zur\u00fcckzukehren. Was hat Source Control mit Clean Code zu tun? Ohne Source Control ist es sehr schwierig Source Code \u00fcber eine lange Zeit sauber und wartbar zu halten. Entwickler verlieren die \u00dcbersicht dar\u00fcber wann, von wem welche \u00c4nderung gemacht worden ist, was vor allem dann zu Problemen f\u00fchrt wenn mehrere Entwickler am gleichen Projekt arbeiten. Beim Austausch von Code zwischen Entwicklern wird es sehr schwierig nachzuvollziehen welche Datei ge\u00e4ndert worden ist und ob sich hieraus vielleicht Probleme ergeben, weil der neue Code von Entwickler A nicht zum neuen Code von Entwickler B passt. Ein Source Control System hilft dabei einen Code sauber und kompatibel zu behalten - auch wenn es weiterhin an den Entwicklern liegt, dies alles sicherzustellen. Was ist Git? Git ist das Source Control System das sich als de facto Standard in der gesamten IT Welt durchgesetzt hat. Es ist hierbei ein sogenanntes Distributed Source Control System, d.h. jeder Client (meistens Entwickler-Computer) h\u00e4lt die gesamte Historie und den gesamten Source Code des Projekts. Jedes \"Commit\" vom Code und jeder \"Push\" zu einem anderen Client \u00fcbertr\u00e4gt hierbei widerum die gesamten letzten \u00c4nderungen, nicht nur den finalen/aktuellen Stand. Commit, Push...? Die folgenden Begriffe beschreiben die Haupt-Funktionalit\u00e4ten von Git (sowieso eigentlich auch jedes anderen Source Control Systems). Eine kurze offizielle Einf\u00fchrung zu Git findet ihr hier Eine detailliertere Referenz zu Git befindet sich hier Repository Ein Git Repository ist eine Menge an Dateien die in Git verwaltet werden. Ein Repository besteht hierbei aus den Dateien selbst, mehreren Branches (d.h. parallelen Versionen) sowie der Historie/den \u00c4nderungen \u00fcber die Zeit. Clone Das Clonen eines Projekts ist das erste \"Downloaden\" eines Git Repositories auf die lokale Workstation, in der Regel vom zentralen Repository. Pull Ein Git Pull ist das \"Downloaden\" von allen \u00c4nderungen die im zentralen Repository seit dem letzten Git Pull passiert sind. Branch Branches beschreiben parallele Bearbeitungs-St\u00e4nde innerhalb eines Git Repositories. Ein Beispiel hierbei w\u00e4re ein Projekt mit 2 Entwicklern. Jeder Entwickler arbeitet an unterschiedlichen Features - aber sie m\u00fcssen beide gleichzeitig die gleichen Dateien ver\u00e4ndern. Um also nicht st\u00e4ndig Probleme mit den \u00c4nderungen des jeweils anderen Enwicklers zu bekommen startet jeder der Entwickler einen sogenannten \"Branch\". Solange er auf diesem Branch arbeitet, kann er jederzeit alle Dateien \u00e4ndern aber der jeweils andere Entwickler sieht keine dieser \u00c4nderungen. Erst wenn sein Branch zur\u00fcck in den Haupt-Branch \"gemerged\" wird, werden seine \u00c4nderungen f\u00fcr alle anderen sichtbar. Beim Branching entstehen sehr oft \"Merge Conflicts\", d.h. Probleme die daraus entstehen dass die gleiche Dateien in verschiedenen Branches ver\u00e4ndert worden sind. Um dies zu reparieren muss in der Regel ein Entwickler beide Code-Versionen vergleichen und diese Zusammenf\u00fchren. Je l\u00e4nger kein Merge stattgefunden hat, desto schwieriger wird das Mergen - es ist daher extrem wichtig so fr\u00fch wie m\u00f6glich einen Merge durchzuf\u00fchren und einen Branch wieder zu l\u00f6schen. Zudem sollten regelm\u00e4ssig die letzten \u00c4nderungen vom Haupt-Branch \u00fcbernommen werden. Commit Ein Commit ist das Abspeichern von einem Code-Stand zu einem bestimmten Zeitpunkt. Ein Commit beinhaltet normalerweise 1..n Dateien zusammen mit einer Commit Message, welche die \u00c4nderung beschreibt. Es ist bei einem Commit wichtig mit allen Entwicklern eine gemeinsame Konvention zu etablieren, wie Commit-Messages verfasst werden sollen. In der Regel beinhalten Commit-Messages daher oft die ID des Work Items zu dem diese \u00c4nderung geh\u00f6rt zusammen mit einer kurzen Beschreibung der eigentlichen \u00c4nderung. git commit -m \"bug/123 Fixed validation logic for german zip codes\" Add/Stage Beim \"Adden\" einer Datei nehmen wir sie in die Versionierung durch Git in diesem Repository mit auf. Bevor eine Datei geaddet wurde, werden ihre verschiedenen Versionsst\u00e4nde von Git ignoriert und nicht mit gespeichert. Beim Stagen markieren wir eine \u00c4nderung an einer Datei so, dass wir sie beim n\u00e4chsten Commit mit \"committen\" wollen. Wenn eine \u00c4nderung nicht \"gestaged\" wurde, dann wird sie in der Regel bei einem Commit ignoriert. Es k\u00f6nnen nur \u00c4nderung von bereits \"geaddeten\" Dateien gestaged werden. Push Ein Push \u00fcbertr\u00e4gt lokale \u00c4nderung (durch Commits) an ein anderes Git System, ein sogenanntes \"Remote\". Dies k\u00f6nnten theoretisch auch andere Entwickler Computer sein, in der Praxis hat sich aber etabliert dies an ein zentrales Repository zu senden, zu dem jeder Entwickler Zugriff hat. In den meisten F\u00e4llen wird dies ein System wie Github, Gitlab, Azure DevOps etc. sein. git push origin master .gitignore File Das .gitignore File in einem Projekt beschreibt die Dateien, die nicht mit in das Repository commited werden sollen. Dies sind in der Regel vor allem Dateien die immer wieder automatisch generiert werde (Builds) Secrets enthalten (z.B. Passw\u00f6rter, Secrets) Ein einfaches Beispiel git init git add . git commit -am \"First commit\" git remote add origin git@github.com:your_github_user/myapplication.git -- Change/write README.md and .gitignore files git pull origin main -- Send the entire application to Github git push origin main","title":"Git"},{"location":"module-1/git/#was-ist-source-control","text":"Source Control beschreibt die Versionierung von Source Code, also das Speichern aller Code-Dateien zu einem bestimmten Zeitpunkt. Das Source Control System hat hierbei die Aufgabe sicherzustellen, dass ein Nutzer auch sp\u00e4ter zu einer fr\u00fcheren Version seines Source Codes zur\u00fcckkehren kann - etwa um zu Vergleichen was sich ge\u00e4ndert hat oder um komplett auf eine fr\u00fchere Version zur\u00fcckzukehren.","title":"Was ist Source Control?"},{"location":"module-1/git/#was-hat-source-control-mit-clean-code-zu-tun","text":"Ohne Source Control ist es sehr schwierig Source Code \u00fcber eine lange Zeit sauber und wartbar zu halten. Entwickler verlieren die \u00dcbersicht dar\u00fcber wann, von wem welche \u00c4nderung gemacht worden ist, was vor allem dann zu Problemen f\u00fchrt wenn mehrere Entwickler am gleichen Projekt arbeiten. Beim Austausch von Code zwischen Entwicklern wird es sehr schwierig nachzuvollziehen welche Datei ge\u00e4ndert worden ist und ob sich hieraus vielleicht Probleme ergeben, weil der neue Code von Entwickler A nicht zum neuen Code von Entwickler B passt. Ein Source Control System hilft dabei einen Code sauber und kompatibel zu behalten - auch wenn es weiterhin an den Entwicklern liegt, dies alles sicherzustellen.","title":"Was hat Source Control mit Clean Code zu tun?"},{"location":"module-1/git/#was-ist-git","text":"Git ist das Source Control System das sich als de facto Standard in der gesamten IT Welt durchgesetzt hat. Es ist hierbei ein sogenanntes Distributed Source Control System, d.h. jeder Client (meistens Entwickler-Computer) h\u00e4lt die gesamte Historie und den gesamten Source Code des Projekts. Jedes \"Commit\" vom Code und jeder \"Push\" zu einem anderen Client \u00fcbertr\u00e4gt hierbei widerum die gesamten letzten \u00c4nderungen, nicht nur den finalen/aktuellen Stand.","title":"Was ist Git?"},{"location":"module-1/git/#commit-push","text":"Die folgenden Begriffe beschreiben die Haupt-Funktionalit\u00e4ten von Git (sowieso eigentlich auch jedes anderen Source Control Systems). Eine kurze offizielle Einf\u00fchrung zu Git findet ihr hier Eine detailliertere Referenz zu Git befindet sich hier","title":"Commit, Push...?"},{"location":"module-1/git/#repository","text":"Ein Git Repository ist eine Menge an Dateien die in Git verwaltet werden. Ein Repository besteht hierbei aus den Dateien selbst, mehreren Branches (d.h. parallelen Versionen) sowie der Historie/den \u00c4nderungen \u00fcber die Zeit.","title":"Repository"},{"location":"module-1/git/#clone","text":"Das Clonen eines Projekts ist das erste \"Downloaden\" eines Git Repositories auf die lokale Workstation, in der Regel vom zentralen Repository.","title":"Clone"},{"location":"module-1/git/#pull","text":"Ein Git Pull ist das \"Downloaden\" von allen \u00c4nderungen die im zentralen Repository seit dem letzten Git Pull passiert sind.","title":"Pull"},{"location":"module-1/git/#branch","text":"Branches beschreiben parallele Bearbeitungs-St\u00e4nde innerhalb eines Git Repositories. Ein Beispiel hierbei w\u00e4re ein Projekt mit 2 Entwicklern. Jeder Entwickler arbeitet an unterschiedlichen Features - aber sie m\u00fcssen beide gleichzeitig die gleichen Dateien ver\u00e4ndern. Um also nicht st\u00e4ndig Probleme mit den \u00c4nderungen des jeweils anderen Enwicklers zu bekommen startet jeder der Entwickler einen sogenannten \"Branch\". Solange er auf diesem Branch arbeitet, kann er jederzeit alle Dateien \u00e4ndern aber der jeweils andere Entwickler sieht keine dieser \u00c4nderungen. Erst wenn sein Branch zur\u00fcck in den Haupt-Branch \"gemerged\" wird, werden seine \u00c4nderungen f\u00fcr alle anderen sichtbar. Beim Branching entstehen sehr oft \"Merge Conflicts\", d.h. Probleme die daraus entstehen dass die gleiche Dateien in verschiedenen Branches ver\u00e4ndert worden sind. Um dies zu reparieren muss in der Regel ein Entwickler beide Code-Versionen vergleichen und diese Zusammenf\u00fchren. Je l\u00e4nger kein Merge stattgefunden hat, desto schwieriger wird das Mergen - es ist daher extrem wichtig so fr\u00fch wie m\u00f6glich einen Merge durchzuf\u00fchren und einen Branch wieder zu l\u00f6schen. Zudem sollten regelm\u00e4ssig die letzten \u00c4nderungen vom Haupt-Branch \u00fcbernommen werden.","title":"Branch"},{"location":"module-1/git/#commit","text":"Ein Commit ist das Abspeichern von einem Code-Stand zu einem bestimmten Zeitpunkt. Ein Commit beinhaltet normalerweise 1..n Dateien zusammen mit einer Commit Message, welche die \u00c4nderung beschreibt. Es ist bei einem Commit wichtig mit allen Entwicklern eine gemeinsame Konvention zu etablieren, wie Commit-Messages verfasst werden sollen. In der Regel beinhalten Commit-Messages daher oft die ID des Work Items zu dem diese \u00c4nderung geh\u00f6rt zusammen mit einer kurzen Beschreibung der eigentlichen \u00c4nderung. git commit -m \"bug/123 Fixed validation logic for german zip codes\"","title":"Commit"},{"location":"module-1/git/#addstage","text":"Beim \"Adden\" einer Datei nehmen wir sie in die Versionierung durch Git in diesem Repository mit auf. Bevor eine Datei geaddet wurde, werden ihre verschiedenen Versionsst\u00e4nde von Git ignoriert und nicht mit gespeichert. Beim Stagen markieren wir eine \u00c4nderung an einer Datei so, dass wir sie beim n\u00e4chsten Commit mit \"committen\" wollen. Wenn eine \u00c4nderung nicht \"gestaged\" wurde, dann wird sie in der Regel bei einem Commit ignoriert. Es k\u00f6nnen nur \u00c4nderung von bereits \"geaddeten\" Dateien gestaged werden.","title":"Add/Stage"},{"location":"module-1/git/#push","text":"Ein Push \u00fcbertr\u00e4gt lokale \u00c4nderung (durch Commits) an ein anderes Git System, ein sogenanntes \"Remote\". Dies k\u00f6nnten theoretisch auch andere Entwickler Computer sein, in der Praxis hat sich aber etabliert dies an ein zentrales Repository zu senden, zu dem jeder Entwickler Zugriff hat. In den meisten F\u00e4llen wird dies ein System wie Github, Gitlab, Azure DevOps etc. sein. git push origin master","title":"Push"},{"location":"module-1/git/#gitignore-file","text":"Das .gitignore File in einem Projekt beschreibt die Dateien, die nicht mit in das Repository commited werden sollen. Dies sind in der Regel vor allem Dateien die immer wieder automatisch generiert werde (Builds) Secrets enthalten (z.B. Passw\u00f6rter, Secrets)","title":".gitignore File"},{"location":"module-1/git/#ein-einfaches-beispiel","text":"git init git add . git commit -am \"First commit\" git remote add origin git@github.com:your_github_user/myapplication.git -- Change/write README.md and .gitignore files git pull origin main -- Send the entire application to Github git push origin main","title":"Ein einfaches Beispiel"},{"location":"module-1/introduction/","text":"Einleitung \"Any fool can write code that a computer can understand. Good programmers write code that humans can understand.\" \u2013 Martin Fowler Clean Code beschreibt die Art und Weise Code so zu schreiben, dass dieser nicht nur seine eigentliche Funktionalit\u00e4t erf\u00fcllt, sondern gleichzeitig auch lesbar, wartbar und erweiterbar ist. Die gesamte Disziplin des \"Clean Code\" basiert hierbar auf dem ebenfalls \"Clean Code\" genannten Buch von Robert Martin (\"Uncle Bob\") - welches eines der wichtigsten B\u00fccher der gesamten IT-Geschichte darstellt und heute noch genauso aktuell ist wie damals.","title":"Einf\u00fchrung"},{"location":"module-1/introduction/#einleitung","text":"\"Any fool can write code that a computer can understand. Good programmers write code that humans can understand.\" \u2013 Martin Fowler Clean Code beschreibt die Art und Weise Code so zu schreiben, dass dieser nicht nur seine eigentliche Funktionalit\u00e4t erf\u00fcllt, sondern gleichzeitig auch lesbar, wartbar und erweiterbar ist. Die gesamte Disziplin des \"Clean Code\" basiert hierbar auf dem ebenfalls \"Clean Code\" genannten Buch von Robert Martin (\"Uncle Bob\") - welches eines der wichtigsten B\u00fccher der gesamten IT-Geschichte darstellt und heute noch genauso aktuell ist wie damals.","title":"Einleitung"},{"location":"module-1/logging/","text":"","title":"Logging"},{"location":"module-1/naming/","text":"","title":"Namen"},{"location":"module-1/structure/","text":"","title":"Code-Struktur"},{"location":"module-2/automated-formatters/","text":"","title":"Automated formatters"},{"location":"module-2/dependency-injection/","text":"","title":"Dependency injection"},{"location":"module-2/do-one-thing-well/","text":"","title":"Do one thing well"},{"location":"module-2/exception-handling/","text":"","title":"Exception handling"},{"location":"module-2/magic-numbers/","text":"","title":"Magic numbers"},{"location":"module-2/refactoring/","text":"","title":"Refactoring"},{"location":"module-2/testability/","text":"","title":"Testability"}]}