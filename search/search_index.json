{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"\"Clean Code\" - FDIBA - Winter Semester 2022 Liebe Studenten, in den kommenden Wochen werden wir zusammen erarbeiten was es bedeutet \"Clean Code\" zu schreiben. Wir werden hierbei analysieren was genau es bedeutet \"Clean Code\" zu produzieren und welche Voraussetzungen wir hierf\u00fcr erf\u00fcllen m\u00fcssen. Diese Dokumentation hierbei wird eine \"living documentation\" sein. Das bedeutet, sie wird kontinuierlich erweitert und auf agile Art und Weise nach und nach verbessert. Um nicht st\u00e4ndig das Rad neu zu erfinden werden wir viele existierenden Quelle nutzen und verlinken.","title":"Home"},{"location":"#clean-code-fdiba-winter-semester-2022","text":"Liebe Studenten, in den kommenden Wochen werden wir zusammen erarbeiten was es bedeutet \"Clean Code\" zu schreiben. Wir werden hierbei analysieren was genau es bedeutet \"Clean Code\" zu produzieren und welche Voraussetzungen wir hierf\u00fcr erf\u00fcllen m\u00fcssen. Diese Dokumentation hierbei wird eine \"living documentation\" sein. Das bedeutet, sie wird kontinuierlich erweitert und auf agile Art und Weise nach und nach verbessert. Um nicht st\u00e4ndig das Rad neu zu erfinden werden wir viele existierenden Quelle nutzen und verlinken.","title":"\"Clean Code\" - FDIBA - Winter Semester 2022"},{"location":"about/","text":"\u00dcber uns Klaus Riedel - der Agile Transformer Im Bereich agile Transformation gibt es wohl nichts, was Klaus nicht schon gesehen hat. \u00dcber 10 Jahre agile Transformationen in Organisationen wie Deutsche Bahn, Lufthansa, Microsoft, Bosch, Conrad Electronics, Bank of Scotland, Deutsche Bank und einige mehr lassen agile Transformationen leicht aussehen. Seit etwas \u00fcber 10 Jahren ist er als Mitgr\u00fcnder und Partner der Unternehmens Blubito als CEO t\u00e4tig und \u00fcbernimmt hierbei rund um die Organisation, Sales und Marketing. Klaus unterrichtet \u201eAgiles Projektmanagement\u201c sowie \"Clean Code\" an der TU Sofia, ist Autor des Blubito Blogs f\u00fcr agile Softwareentwicklung und des runScrum Blogs \u00fcber agiles Projektmanagement und betreut mehrere Teams als Product Owner. Jan Br\u00fcggmann - der Tech Guru Jan begann mit 14 Jahren Software zu entwickeln und hat in den ca. 25 Jahren seitdem eigentlich auch nie etwas anderes getan oder gelernt. Seine professionelle Karriere began mit Anfang 20 als IT-Berater f\u00fcr diverse deutsche Unternehmen, von Airlines bis hin zu Banken und der Immobilienwirtschaft. Seit etwas \u00fcber 10 Jahren ist er als Mitgr\u00fcnder und Partner der Unternehmens Blubito als CTO t\u00e4tig und \u00fcbernimmt hierbei alles um Technik, Ausbildung und Recruiting. Jan unterrichtet \"Clean Code\" an der TU Sofia und unterst\u00fctzt viele Kollegen als auch Kunden bei der L\u00f6sung diverser technischen Probleme. G\u00e4ste Sp\u00e4ter mehr...","title":"Soon..."},{"location":"about/#uber-uns","text":"","title":"\u00dcber uns"},{"location":"about/#klaus-riedel-der-agile-transformer","text":"Im Bereich agile Transformation gibt es wohl nichts, was Klaus nicht schon gesehen hat. \u00dcber 10 Jahre agile Transformationen in Organisationen wie Deutsche Bahn, Lufthansa, Microsoft, Bosch, Conrad Electronics, Bank of Scotland, Deutsche Bank und einige mehr lassen agile Transformationen leicht aussehen. Seit etwas \u00fcber 10 Jahren ist er als Mitgr\u00fcnder und Partner der Unternehmens Blubito als CEO t\u00e4tig und \u00fcbernimmt hierbei rund um die Organisation, Sales und Marketing. Klaus unterrichtet \u201eAgiles Projektmanagement\u201c sowie \"Clean Code\" an der TU Sofia, ist Autor des Blubito Blogs f\u00fcr agile Softwareentwicklung und des runScrum Blogs \u00fcber agiles Projektmanagement und betreut mehrere Teams als Product Owner.","title":"Klaus Riedel - der Agile Transformer"},{"location":"about/#jan-bruggmann-der-tech-guru","text":"Jan begann mit 14 Jahren Software zu entwickeln und hat in den ca. 25 Jahren seitdem eigentlich auch nie etwas anderes getan oder gelernt. Seine professionelle Karriere began mit Anfang 20 als IT-Berater f\u00fcr diverse deutsche Unternehmen, von Airlines bis hin zu Banken und der Immobilienwirtschaft. Seit etwas \u00fcber 10 Jahren ist er als Mitgr\u00fcnder und Partner der Unternehmens Blubito als CTO t\u00e4tig und \u00fcbernimmt hierbei alles um Technik, Ausbildung und Recruiting. Jan unterrichtet \"Clean Code\" an der TU Sofia und unterst\u00fctzt viele Kollegen als auch Kunden bei der L\u00f6sung diverser technischen Probleme.","title":"Jan Br\u00fcggmann - der Tech Guru"},{"location":"about/#gaste","text":"Sp\u00e4ter mehr...","title":"G\u00e4ste"},{"location":"module-1/comments/","text":"Das Problem mit den Kommentaren im Code... Kommentare im Code werden von verschiedenen Personen und Organisatione sehr unterschiedlich betrachtet und es gibt keine wirklich 100% einheitliche L\u00f6sung wie man mit Kommentaren im Code umgehen soll. Viele Organisationen erwarten von ihren Entwicklern, dass der gesamte Code kommentiert ist und die Kommentare selbst die Funktionalit\u00e4t als auch die Beziehungen des Codes selbst klar beschreiben. Dies ist vor allem in Organisationen der Fall in denen Richtlinien vorrangig von Personen etabliert werden, die selbst nur wenig Erfahrung mit dem Schreiben von Software haben. Dem gegen\u00fcber stehen die Puristen, welche die Meinung vertreten Kommentare sind im besten Fall nutzlos, im schlimmsten Fall sogar st\u00f6rend und verschlechtern die Verst\u00e4ndlichkeit von Code. Kommentare aus der Sicht des Clean Code Aus der Perspektive des \"Clean Code\" sollten Kommentare m\u00f6glichst selten genutzt werden. Kommentare sollten vor allem dann eingesetzt werden, wenn im Code etwas passiert was nicht durch den Code selbst erkl\u00e4rt werden kann - dies bezieht sich also vor allem auf die Fragen wie \"WARUM tut der Code das, was er hier tut?\" Kommentare die den Zweck haben zu erkl\u00e4ren WAS der Code selbst tut sind in fast allen F\u00e4llen eher ein Zeichen daf\u00fcr, dass der Code selbst zu kompliziert ist und \u00fcberarbeitet werden sollte. Mit besseren Namen und Vereinfachung des Codes selbst, k\u00f6nnen fast alle solcher Kommentare \u00fcberfl\u00fcssig gemacht werden. In Ausnahmef\u00e4llen k\u00f6nnen Kommentare n\u00fctzlich sein um Code zu erkl\u00e4ren, der sehr schwierig zu verstehen ist aber leider nicht weiter vereinfacht werden kann. Dies ist oft der Fall bei Dinge die Regul\u00e4ren Ausdr\u00fccken (RegEx) Die Gefahr der Kommentar Jeder Kommentar der geschrieben wird, muss stets geupdated werden wenn sich die Funktion auf die er sich bezieht \u00e4ndert. Dies ist nur ein kleines Problem bei wenigen Kommentaren die sich vorrangig um das \"WARUM\" k\u00fcmmern - kann jedoch zu einem sehr gro\u00dfen Problem werden wenn diese Regel nicht eingehalten wird. Jeder Entwickler kommt in seiner Karriere einmal an den Punkt dass er auf ein Problem st\u00f6sst dass er partout nicht l\u00f6sen kann, trotz viel Zeit und Arbeit - nur um dann Tage sp\u00e4ter zu bemerken dass die Kommentare die den Code beschrieben haben den er nutzt, nicht mehr mit der eigentlichen Implementation \u00fcbereinstimmen. Irgendwann wurde vergessen bei einer \u00c4nderung die Kommentare mit zu aktualisieren. Beispiele f\u00fcr gute Kommentare // Matches a Dutch zipcode, eg, '1974 XA' or '4844RA' Pattern DUTCH_ZIPCODE = Pattern.compile(\"[1-9][0-9]{3} ?[A-Z]{2}\"); int resultCode = ...; boolean isSucess = resultCode == 200; boolean isTemporaryError = resultCode == 503 || resultCode == 504; // Sometime we receive a temporary error. // However, in all cases which were researched, results were successfully stored. // Because of this we will return true in that case. return (isSucess || isTemporaryError); Anti-Patterns Danke, Captain Obvious // numeric session-id int sessionId = 0; // expiry date Date expiry = new Date(); // numeric session-id int sessionTimeoutInSeconds = 3600; // resets session-id to 99; function reset() { sessionId = 99; } Erkl\u00e4rt unklaren Code // timeout in seconds int timeout = 5; // <---- nicht gut int timeoutInSeconds = 5; // <---- besser // if during work hours if (currentTime.hours >= 9 && currentTime.hours <= 17) // <---- nicht gut if (isDuringWorkingHours(currentTime)) // <---- besser Auskommentierter Code Entwickler neigen vor allem am Anfang ihrer Karriere dazu Code auszukommentieren aus Angst ihn zu verlieren und dann sp\u00e4ter noch eimal zu brauchen. Dieses \"Feature\" ist gut gemeint, f\u00fchrt aber vor allem zu aufgebl\u00e4htem und schwer lesbaren Code - und wird so gut wie nie wirklich gebraucht. Zudem ist das Ziel selbst schon vom Source Control System erf\u00fcllt, denn hier kann auch gel\u00f6schter Code notfalls wieder hergestellt werden. Quellen https://www.baeldung.com/cs/clean-code-comments https://medium.com/codex/clean-code-comments-833e11a706dc","title":"Kommentare"},{"location":"module-1/comments/#das-problem-mit-den-kommentaren-im-code","text":"Kommentare im Code werden von verschiedenen Personen und Organisatione sehr unterschiedlich betrachtet und es gibt keine wirklich 100% einheitliche L\u00f6sung wie man mit Kommentaren im Code umgehen soll. Viele Organisationen erwarten von ihren Entwicklern, dass der gesamte Code kommentiert ist und die Kommentare selbst die Funktionalit\u00e4t als auch die Beziehungen des Codes selbst klar beschreiben. Dies ist vor allem in Organisationen der Fall in denen Richtlinien vorrangig von Personen etabliert werden, die selbst nur wenig Erfahrung mit dem Schreiben von Software haben. Dem gegen\u00fcber stehen die Puristen, welche die Meinung vertreten Kommentare sind im besten Fall nutzlos, im schlimmsten Fall sogar st\u00f6rend und verschlechtern die Verst\u00e4ndlichkeit von Code.","title":"Das Problem mit den Kommentaren im Code..."},{"location":"module-1/comments/#kommentare-aus-der-sicht-des-clean-code","text":"Aus der Perspektive des \"Clean Code\" sollten Kommentare m\u00f6glichst selten genutzt werden. Kommentare sollten vor allem dann eingesetzt werden, wenn im Code etwas passiert was nicht durch den Code selbst erkl\u00e4rt werden kann - dies bezieht sich also vor allem auf die Fragen wie \"WARUM tut der Code das, was er hier tut?\" Kommentare die den Zweck haben zu erkl\u00e4ren WAS der Code selbst tut sind in fast allen F\u00e4llen eher ein Zeichen daf\u00fcr, dass der Code selbst zu kompliziert ist und \u00fcberarbeitet werden sollte. Mit besseren Namen und Vereinfachung des Codes selbst, k\u00f6nnen fast alle solcher Kommentare \u00fcberfl\u00fcssig gemacht werden. In Ausnahmef\u00e4llen k\u00f6nnen Kommentare n\u00fctzlich sein um Code zu erkl\u00e4ren, der sehr schwierig zu verstehen ist aber leider nicht weiter vereinfacht werden kann. Dies ist oft der Fall bei Dinge die Regul\u00e4ren Ausdr\u00fccken (RegEx)","title":"Kommentare aus der Sicht des Clean Code"},{"location":"module-1/comments/#die-gefahr-der-kommentar","text":"Jeder Kommentar der geschrieben wird, muss stets geupdated werden wenn sich die Funktion auf die er sich bezieht \u00e4ndert. Dies ist nur ein kleines Problem bei wenigen Kommentaren die sich vorrangig um das \"WARUM\" k\u00fcmmern - kann jedoch zu einem sehr gro\u00dfen Problem werden wenn diese Regel nicht eingehalten wird. Jeder Entwickler kommt in seiner Karriere einmal an den Punkt dass er auf ein Problem st\u00f6sst dass er partout nicht l\u00f6sen kann, trotz viel Zeit und Arbeit - nur um dann Tage sp\u00e4ter zu bemerken dass die Kommentare die den Code beschrieben haben den er nutzt, nicht mehr mit der eigentlichen Implementation \u00fcbereinstimmen. Irgendwann wurde vergessen bei einer \u00c4nderung die Kommentare mit zu aktualisieren.","title":"Die Gefahr der Kommentar"},{"location":"module-1/comments/#beispiele-fur-gute-kommentare","text":"// Matches a Dutch zipcode, eg, '1974 XA' or '4844RA' Pattern DUTCH_ZIPCODE = Pattern.compile(\"[1-9][0-9]{3} ?[A-Z]{2}\"); int resultCode = ...; boolean isSucess = resultCode == 200; boolean isTemporaryError = resultCode == 503 || resultCode == 504; // Sometime we receive a temporary error. // However, in all cases which were researched, results were successfully stored. // Because of this we will return true in that case. return (isSucess || isTemporaryError);","title":"Beispiele f\u00fcr gute Kommentare"},{"location":"module-1/comments/#anti-patterns","text":"","title":"Anti-Patterns"},{"location":"module-1/comments/#danke-captain-obvious","text":"// numeric session-id int sessionId = 0; // expiry date Date expiry = new Date(); // numeric session-id int sessionTimeoutInSeconds = 3600; // resets session-id to 99; function reset() { sessionId = 99; }","title":"Danke, Captain Obvious"},{"location":"module-1/comments/#erklart-unklaren-code","text":"// timeout in seconds int timeout = 5; // <---- nicht gut int timeoutInSeconds = 5; // <---- besser // if during work hours if (currentTime.hours >= 9 && currentTime.hours <= 17) // <---- nicht gut if (isDuringWorkingHours(currentTime)) // <---- besser","title":"Erkl\u00e4rt unklaren Code"},{"location":"module-1/comments/#auskommentierter-code","text":"Entwickler neigen vor allem am Anfang ihrer Karriere dazu Code auszukommentieren aus Angst ihn zu verlieren und dann sp\u00e4ter noch eimal zu brauchen. Dieses \"Feature\" ist gut gemeint, f\u00fchrt aber vor allem zu aufgebl\u00e4htem und schwer lesbaren Code - und wird so gut wie nie wirklich gebraucht. Zudem ist das Ziel selbst schon vom Source Control System erf\u00fcllt, denn hier kann auch gel\u00f6schter Code notfalls wieder hergestellt werden.","title":"Auskommentierter Code"},{"location":"module-1/comments/#quellen","text":"https://www.baeldung.com/cs/clean-code-comments https://medium.com/codex/clean-code-comments-833e11a706dc","title":"Quellen"},{"location":"module-1/debugging/","text":"Was ist Debugging? Debugging beschreibt die T\u00e4tigkeit ein Computerprogramm von einem technischen- oder inhaltlichen Fehler zu befreien. W\u00e4hrend das Debuggen selbst eigentlich keinen direkten Bezug zu Clean Code hat, so beeinflussen sich beide doch massiv. Je \"sauberer\" der Code ist, desto eher besteht die Chance dass wir einen Bug noch w\u00e4hrend der Entwicklung entdecken. Zudem tr\u00e4gt gut strukturierter Code ungemein dazu bei, dass wir im Falle eines Problems in der Lage sind schnell die Ursache des Problems zu identifizieren und eine L\u00f6sung zu implementieren. Hierbei k\u00f6nnen uns mehrere Dinge von Nutzen sein: Logging Logging beschreibt die Ausgabe von zus\u00e4tzlichen Informationen die nicht f\u00fcr den Endnutzer bestimmt sind. Log-Statements werden hierbei in der Regel in die Console ausgegeben oder zur sp\u00e4teren Analyse an ein externes System gesendet wie beispielsweise eine Datei auf der Festplatte oder ein zentrales Logging-Tool in der Cloud. Hierbei sind folgende Punkte wichtig: Log Statements sollten hierbei die Informationen beinhalten, die sp\u00e4ter zur L\u00f6sung von Problemen tats\u00e4chlich n\u00fctzlich sind. \"Ein Fehler ist aufgetreten!\" hilft niemandem. \"Zeile 50 der Buchungs-Datei bookings-2022.csv konnte nicht vollst\u00e4ndig gelesen werden\" gibt einem Entwickler aber einen guten ersten Ansatz f\u00fcr die Fehlersuche. Die Menge an geschriebenen Log-Statements sollte \u00fcber sogenannte \"Log Levels\" anpassbar sein - denn w\u00e4hrend wir w\u00e4hrend der Entwicklung oft m\u00f6glichst viel Informationen auch von absolut erfolgreichen Events sehen wollen, so ist dies im produktiven Betrieb oft zu verwirrend. Hier wollen wir wom\u00f6glich nur \u00fcber kritische Fehler informiert werden. Logs d\u00fcrfen auf keinen Fall pers\u00f6nliche oder sicherheitskritische Informationen beinhalten - dies gilt vor allem f\u00fcr Dinge wie Kreditkarten-Nummern etc. Debugger Tools Debugger Tools sind Dinge mit denen ein Entwickler in der Lage ist eine Applikation w\u00e4hrend ihrer Ausf\u00fchrung zu pausieren und den internen Zustand der Applikation auszuwerten oder sogar zu ver\u00e4ndern. Der Punkt an dem die Applikation pausieren soll wird in der Regel \u00fcber sogenannte \"Breakpoints\" im Code definiert. Definiere ich beispielsweise einen Breakpoint innerhalb meiner doSomething() Funktion, so wird meine Applikation bei Erreichen von genau dieser Codezeile stoppen und ich kann damit beginnen die Werte von Variablen zu betrachten oder zu ver\u00e4ndern. Je nach Programmiersprache und -Umgebung kommen als Debugger-Tools verschiedene Applikationen zum Einsatz. F\u00fcr Java-Applikationen beispielsweise ist es in der Regel die IDE wie IntelliJ oder Eclipse welche die Debugger-Tools zur Verf\u00fcgung stellt, wodurch ein Entwickler seine gewohnte Umgebung gar nicht erst verlassen muss. F\u00fcr web-basierte Applikationen auf Basis von JavaScript, welche in der Regel im Browser ausgef\u00fchrt werden, bieten alle modernen Browser wie Chrome, Firefox und Safari ihre eigenen Entwickler-Tools mit Debugging Funktionalit\u00e4ten. Eclipse Debugger View","title":"Debugging"},{"location":"module-1/debugging/#was-ist-debugging","text":"Debugging beschreibt die T\u00e4tigkeit ein Computerprogramm von einem technischen- oder inhaltlichen Fehler zu befreien. W\u00e4hrend das Debuggen selbst eigentlich keinen direkten Bezug zu Clean Code hat, so beeinflussen sich beide doch massiv. Je \"sauberer\" der Code ist, desto eher besteht die Chance dass wir einen Bug noch w\u00e4hrend der Entwicklung entdecken. Zudem tr\u00e4gt gut strukturierter Code ungemein dazu bei, dass wir im Falle eines Problems in der Lage sind schnell die Ursache des Problems zu identifizieren und eine L\u00f6sung zu implementieren. Hierbei k\u00f6nnen uns mehrere Dinge von Nutzen sein:","title":"Was ist Debugging?"},{"location":"module-1/debugging/#logging","text":"Logging beschreibt die Ausgabe von zus\u00e4tzlichen Informationen die nicht f\u00fcr den Endnutzer bestimmt sind. Log-Statements werden hierbei in der Regel in die Console ausgegeben oder zur sp\u00e4teren Analyse an ein externes System gesendet wie beispielsweise eine Datei auf der Festplatte oder ein zentrales Logging-Tool in der Cloud. Hierbei sind folgende Punkte wichtig: Log Statements sollten hierbei die Informationen beinhalten, die sp\u00e4ter zur L\u00f6sung von Problemen tats\u00e4chlich n\u00fctzlich sind. \"Ein Fehler ist aufgetreten!\" hilft niemandem. \"Zeile 50 der Buchungs-Datei bookings-2022.csv konnte nicht vollst\u00e4ndig gelesen werden\" gibt einem Entwickler aber einen guten ersten Ansatz f\u00fcr die Fehlersuche. Die Menge an geschriebenen Log-Statements sollte \u00fcber sogenannte \"Log Levels\" anpassbar sein - denn w\u00e4hrend wir w\u00e4hrend der Entwicklung oft m\u00f6glichst viel Informationen auch von absolut erfolgreichen Events sehen wollen, so ist dies im produktiven Betrieb oft zu verwirrend. Hier wollen wir wom\u00f6glich nur \u00fcber kritische Fehler informiert werden. Logs d\u00fcrfen auf keinen Fall pers\u00f6nliche oder sicherheitskritische Informationen beinhalten - dies gilt vor allem f\u00fcr Dinge wie Kreditkarten-Nummern etc.","title":"Logging"},{"location":"module-1/debugging/#debugger-tools","text":"Debugger Tools sind Dinge mit denen ein Entwickler in der Lage ist eine Applikation w\u00e4hrend ihrer Ausf\u00fchrung zu pausieren und den internen Zustand der Applikation auszuwerten oder sogar zu ver\u00e4ndern. Der Punkt an dem die Applikation pausieren soll wird in der Regel \u00fcber sogenannte \"Breakpoints\" im Code definiert. Definiere ich beispielsweise einen Breakpoint innerhalb meiner doSomething() Funktion, so wird meine Applikation bei Erreichen von genau dieser Codezeile stoppen und ich kann damit beginnen die Werte von Variablen zu betrachten oder zu ver\u00e4ndern. Je nach Programmiersprache und -Umgebung kommen als Debugger-Tools verschiedene Applikationen zum Einsatz. F\u00fcr Java-Applikationen beispielsweise ist es in der Regel die IDE wie IntelliJ oder Eclipse welche die Debugger-Tools zur Verf\u00fcgung stellt, wodurch ein Entwickler seine gewohnte Umgebung gar nicht erst verlassen muss. F\u00fcr web-basierte Applikationen auf Basis von JavaScript, welche in der Regel im Browser ausgef\u00fchrt werden, bieten alle modernen Browser wie Chrome, Firefox und Safari ihre eigenen Entwickler-Tools mit Debugging Funktionalit\u00e4ten.","title":"Debugger Tools"},{"location":"module-1/debugging/#eclipse-debugger-view","text":"","title":"Eclipse Debugger View"},{"location":"module-1/exercise/","text":"Aufgabe zum Modul 1 Aufgabe Git installieren Github Repository erstellen Euer Repository von Github clonen Erstellt einen neuen Branch in eurem Repository Erstellt ein neues Java Projekt in diesem Branch (\"Feature Branch\") Die Applikation sollte folgende Funktionalit\u00e4t erf\u00fcllen Es k\u00f6nnen 1 oder mehrere Zahlen \u00fcber die Kommandozeile eingegeben werden Nachdem 1 oder mehrere Zahlen eingegeben wurden, kann uns die App den Durchschnitt dieser Zahlen nennen Falsche Eingaben werden abgefangen und mit einer guten Fehlermeldung abgelehnt Der Code ist \"clean\" entsprechend der Clean Code Definitionen Erstellt einen Merge Request von eurem Feature Branch in den Main Branch","title":"Aufgaben"},{"location":"module-1/exercise/#aufgabe-zum-modul-1","text":"","title":"Aufgabe zum Modul 1"},{"location":"module-1/exercise/#aufgabe","text":"Git installieren Github Repository erstellen Euer Repository von Github clonen Erstellt einen neuen Branch in eurem Repository Erstellt ein neues Java Projekt in diesem Branch (\"Feature Branch\") Die Applikation sollte folgende Funktionalit\u00e4t erf\u00fcllen Es k\u00f6nnen 1 oder mehrere Zahlen \u00fcber die Kommandozeile eingegeben werden Nachdem 1 oder mehrere Zahlen eingegeben wurden, kann uns die App den Durchschnitt dieser Zahlen nennen Falsche Eingaben werden abgefangen und mit einer guten Fehlermeldung abgelehnt Der Code ist \"clean\" entsprechend der Clean Code Definitionen Erstellt einen Merge Request von eurem Feature Branch in den Main Branch","title":"Aufgabe"},{"location":"module-1/git/","text":"Was ist Source Control? Source Control beschreibt die Versionierung von Source Code, also das Speichern aller Code-Dateien zu einem bestimmten Zeitpunkt. Das Source Control System hat hierbei die Aufgabe sicherzustellen, dass ein Nutzer auch sp\u00e4ter zu einer fr\u00fcheren Version seines Source Codes zur\u00fcckkehren kann - etwa um zu Vergleichen was sich ge\u00e4ndert hat oder um komplett auf eine fr\u00fchere Version zur\u00fcckzukehren. Was hat Source Control mit Clean Code zu tun? Ohne Source Control ist es sehr schwierig Source Code \u00fcber eine lange Zeit sauber und wartbar zu halten. Entwickler verlieren die \u00dcbersicht dar\u00fcber wann, von wem welche \u00c4nderung gemacht worden ist, was vor allem dann zu Problemen f\u00fchrt wenn mehrere Entwickler am gleichen Projekt arbeiten. Beim Austausch von Code zwischen Entwicklern wird es sehr schwierig nachzuvollziehen welche Datei ge\u00e4ndert worden ist und ob sich hieraus vielleicht Probleme ergeben, weil der neue Code von Entwickler A nicht zum neuen Code von Entwickler B passt. Ein Source Control System hilft dabei einen Code sauber und kompatibel zu behalten - auch wenn es weiterhin an den Entwicklern liegt, dies alles sicherzustellen. Was ist Git? Git ist das Source Control System das sich als de facto Standard in der gesamten IT Welt durchgesetzt hat. Es ist hierbei ein sogenanntes Distributed Source Control System, d.h. jeder Client (meistens Entwickler-Computer) h\u00e4lt die gesamte Historie und den gesamten Source Code des Projekts. Jedes \"Commit\" vom Code und jeder \"Push\" zu einem anderen Client \u00fcbertr\u00e4gt hierbei widerum die gesamten letzten \u00c4nderungen, nicht nur den finalen/aktuellen Stand. Commit, Push...? Die folgenden Begriffe beschreiben die Haupt-Funktionalit\u00e4ten von Git (sowieso eigentlich auch jedes anderen Source Control Systems). Eine kurze offizielle Einf\u00fchrung zu Git findet ihr hier Eine detailliertere Referenz zu Git befindet sich hier Repository Ein Git Repository ist eine Menge an Dateien die in Git verwaltet werden. Ein Repository besteht hierbei aus den Dateien selbst, mehreren Branches (d.h. parallelen Versionen) sowie der Historie/den \u00c4nderungen \u00fcber die Zeit. Clone Das Clonen eines Projekts ist das erste \"Downloaden\" eines Git Repositories auf die lokale Workstation, in der Regel vom zentralen Repository. Pull Ein Git Pull ist das \"Downloaden\" von allen \u00c4nderungen die im zentralen Repository seit dem letzten Git Pull passiert sind. Branch Branches beschreiben parallele Bearbeitungs-St\u00e4nde innerhalb eines Git Repositories. Ein Beispiel hierbei w\u00e4re ein Projekt mit 2 Entwicklern. Jeder Entwickler arbeitet an unterschiedlichen Features - aber sie m\u00fcssen beide gleichzeitig die gleichen Dateien ver\u00e4ndern. Um also nicht st\u00e4ndig Probleme mit den \u00c4nderungen des jeweils anderen Enwicklers zu bekommen startet jeder der Entwickler einen sogenannten \"Branch\". Solange er auf diesem Branch arbeitet, kann er jederzeit alle Dateien \u00e4ndern aber der jeweils andere Entwickler sieht keine dieser \u00c4nderungen. Erst wenn sein Branch zur\u00fcck in den Haupt-Branch \"gemerged\" wird, werden seine \u00c4nderungen f\u00fcr alle anderen sichtbar. Beim Branching entstehen sehr oft \"Merge Conflicts\", d.h. Probleme die daraus entstehen dass die gleiche Dateien in verschiedenen Branches ver\u00e4ndert worden sind. Um dies zu reparieren muss in der Regel ein Entwickler beide Code-Versionen vergleichen und diese Zusammenf\u00fchren. Je l\u00e4nger kein Merge stattgefunden hat, desto schwieriger wird das Mergen - es ist daher extrem wichtig so fr\u00fch wie m\u00f6glich einen Merge durchzuf\u00fchren und einen Branch wieder zu l\u00f6schen. Zudem sollten regelm\u00e4ssig die letzten \u00c4nderungen vom Haupt-Branch \u00fcbernommen werden. Commit Ein Commit ist das Abspeichern von einem Code-Stand zu einem bestimmten Zeitpunkt. Ein Commit beinhaltet normalerweise 1..n Dateien zusammen mit einer Commit Message, welche die \u00c4nderung beschreibt. Es ist bei einem Commit wichtig mit allen Entwicklern eine gemeinsame Konvention zu etablieren, wie Commit-Messages verfasst werden sollen. In der Regel beinhalten Commit-Messages daher oft die ID des Work Items zu dem diese \u00c4nderung geh\u00f6rt zusammen mit einer kurzen Beschreibung der eigentlichen \u00c4nderung. git commit -m \"bug/123 Fixed validation logic for german zip codes\" Add/Stage Beim \"Adden\" einer Datei nehmen wir sie in die Versionierung durch Git in diesem Repository mit auf. Bevor eine Datei geaddet wurde, werden ihre verschiedenen Versionsst\u00e4nde von Git ignoriert und nicht mit gespeichert. Beim Stagen markieren wir eine \u00c4nderung an einer Datei so, dass wir sie beim n\u00e4chsten Commit mit \"committen\" wollen. Wenn eine \u00c4nderung nicht \"gestaged\" wurde, dann wird sie in der Regel bei einem Commit ignoriert. Es k\u00f6nnen nur \u00c4nderung von bereits \"geaddeten\" Dateien gestaged werden. Push Ein Push \u00fcbertr\u00e4gt lokale \u00c4nderung (durch Commits) an ein anderes Git System, ein sogenanntes \"Remote\". Dies k\u00f6nnten theoretisch auch andere Entwickler Computer sein, in der Praxis hat sich aber etabliert dies an ein zentrales Repository zu senden, zu dem jeder Entwickler Zugriff hat. In den meisten F\u00e4llen wird dies ein System wie Github, Gitlab, Azure DevOps etc. sein. git push origin master .gitignore File Das .gitignore File in einem Projekt beschreibt die Dateien, die nicht mit in das Repository commited werden sollen. Dies sind in der Regel vor allem Dateien die immer wieder automatisch generiert werde (Builds) Secrets enthalten (z.B. Passw\u00f6rter, Secrets) Ein einfaches Beispiel git init git add . git commit -am \"First commit\" git remote add origin git@github.com:your_github_user/myapplication.git -- Change/write README.md and .gitignore files git pull origin main -- Send the entire application to Github git push origin main","title":"Git"},{"location":"module-1/git/#was-ist-source-control","text":"Source Control beschreibt die Versionierung von Source Code, also das Speichern aller Code-Dateien zu einem bestimmten Zeitpunkt. Das Source Control System hat hierbei die Aufgabe sicherzustellen, dass ein Nutzer auch sp\u00e4ter zu einer fr\u00fcheren Version seines Source Codes zur\u00fcckkehren kann - etwa um zu Vergleichen was sich ge\u00e4ndert hat oder um komplett auf eine fr\u00fchere Version zur\u00fcckzukehren.","title":"Was ist Source Control?"},{"location":"module-1/git/#was-hat-source-control-mit-clean-code-zu-tun","text":"Ohne Source Control ist es sehr schwierig Source Code \u00fcber eine lange Zeit sauber und wartbar zu halten. Entwickler verlieren die \u00dcbersicht dar\u00fcber wann, von wem welche \u00c4nderung gemacht worden ist, was vor allem dann zu Problemen f\u00fchrt wenn mehrere Entwickler am gleichen Projekt arbeiten. Beim Austausch von Code zwischen Entwicklern wird es sehr schwierig nachzuvollziehen welche Datei ge\u00e4ndert worden ist und ob sich hieraus vielleicht Probleme ergeben, weil der neue Code von Entwickler A nicht zum neuen Code von Entwickler B passt. Ein Source Control System hilft dabei einen Code sauber und kompatibel zu behalten - auch wenn es weiterhin an den Entwicklern liegt, dies alles sicherzustellen.","title":"Was hat Source Control mit Clean Code zu tun?"},{"location":"module-1/git/#was-ist-git","text":"Git ist das Source Control System das sich als de facto Standard in der gesamten IT Welt durchgesetzt hat. Es ist hierbei ein sogenanntes Distributed Source Control System, d.h. jeder Client (meistens Entwickler-Computer) h\u00e4lt die gesamte Historie und den gesamten Source Code des Projekts. Jedes \"Commit\" vom Code und jeder \"Push\" zu einem anderen Client \u00fcbertr\u00e4gt hierbei widerum die gesamten letzten \u00c4nderungen, nicht nur den finalen/aktuellen Stand.","title":"Was ist Git?"},{"location":"module-1/git/#commit-push","text":"Die folgenden Begriffe beschreiben die Haupt-Funktionalit\u00e4ten von Git (sowieso eigentlich auch jedes anderen Source Control Systems). Eine kurze offizielle Einf\u00fchrung zu Git findet ihr hier Eine detailliertere Referenz zu Git befindet sich hier","title":"Commit, Push...?"},{"location":"module-1/git/#repository","text":"Ein Git Repository ist eine Menge an Dateien die in Git verwaltet werden. Ein Repository besteht hierbei aus den Dateien selbst, mehreren Branches (d.h. parallelen Versionen) sowie der Historie/den \u00c4nderungen \u00fcber die Zeit.","title":"Repository"},{"location":"module-1/git/#clone","text":"Das Clonen eines Projekts ist das erste \"Downloaden\" eines Git Repositories auf die lokale Workstation, in der Regel vom zentralen Repository.","title":"Clone"},{"location":"module-1/git/#pull","text":"Ein Git Pull ist das \"Downloaden\" von allen \u00c4nderungen die im zentralen Repository seit dem letzten Git Pull passiert sind.","title":"Pull"},{"location":"module-1/git/#branch","text":"Branches beschreiben parallele Bearbeitungs-St\u00e4nde innerhalb eines Git Repositories. Ein Beispiel hierbei w\u00e4re ein Projekt mit 2 Entwicklern. Jeder Entwickler arbeitet an unterschiedlichen Features - aber sie m\u00fcssen beide gleichzeitig die gleichen Dateien ver\u00e4ndern. Um also nicht st\u00e4ndig Probleme mit den \u00c4nderungen des jeweils anderen Enwicklers zu bekommen startet jeder der Entwickler einen sogenannten \"Branch\". Solange er auf diesem Branch arbeitet, kann er jederzeit alle Dateien \u00e4ndern aber der jeweils andere Entwickler sieht keine dieser \u00c4nderungen. Erst wenn sein Branch zur\u00fcck in den Haupt-Branch \"gemerged\" wird, werden seine \u00c4nderungen f\u00fcr alle anderen sichtbar. Beim Branching entstehen sehr oft \"Merge Conflicts\", d.h. Probleme die daraus entstehen dass die gleiche Dateien in verschiedenen Branches ver\u00e4ndert worden sind. Um dies zu reparieren muss in der Regel ein Entwickler beide Code-Versionen vergleichen und diese Zusammenf\u00fchren. Je l\u00e4nger kein Merge stattgefunden hat, desto schwieriger wird das Mergen - es ist daher extrem wichtig so fr\u00fch wie m\u00f6glich einen Merge durchzuf\u00fchren und einen Branch wieder zu l\u00f6schen. Zudem sollten regelm\u00e4ssig die letzten \u00c4nderungen vom Haupt-Branch \u00fcbernommen werden.","title":"Branch"},{"location":"module-1/git/#commit","text":"Ein Commit ist das Abspeichern von einem Code-Stand zu einem bestimmten Zeitpunkt. Ein Commit beinhaltet normalerweise 1..n Dateien zusammen mit einer Commit Message, welche die \u00c4nderung beschreibt. Es ist bei einem Commit wichtig mit allen Entwicklern eine gemeinsame Konvention zu etablieren, wie Commit-Messages verfasst werden sollen. In der Regel beinhalten Commit-Messages daher oft die ID des Work Items zu dem diese \u00c4nderung geh\u00f6rt zusammen mit einer kurzen Beschreibung der eigentlichen \u00c4nderung. git commit -m \"bug/123 Fixed validation logic for german zip codes\"","title":"Commit"},{"location":"module-1/git/#addstage","text":"Beim \"Adden\" einer Datei nehmen wir sie in die Versionierung durch Git in diesem Repository mit auf. Bevor eine Datei geaddet wurde, werden ihre verschiedenen Versionsst\u00e4nde von Git ignoriert und nicht mit gespeichert. Beim Stagen markieren wir eine \u00c4nderung an einer Datei so, dass wir sie beim n\u00e4chsten Commit mit \"committen\" wollen. Wenn eine \u00c4nderung nicht \"gestaged\" wurde, dann wird sie in der Regel bei einem Commit ignoriert. Es k\u00f6nnen nur \u00c4nderung von bereits \"geaddeten\" Dateien gestaged werden.","title":"Add/Stage"},{"location":"module-1/git/#push","text":"Ein Push \u00fcbertr\u00e4gt lokale \u00c4nderung (durch Commits) an ein anderes Git System, ein sogenanntes \"Remote\". Dies k\u00f6nnten theoretisch auch andere Entwickler Computer sein, in der Praxis hat sich aber etabliert dies an ein zentrales Repository zu senden, zu dem jeder Entwickler Zugriff hat. In den meisten F\u00e4llen wird dies ein System wie Github, Gitlab, Azure DevOps etc. sein. git push origin master","title":"Push"},{"location":"module-1/git/#gitignore-file","text":"Das .gitignore File in einem Projekt beschreibt die Dateien, die nicht mit in das Repository commited werden sollen. Dies sind in der Regel vor allem Dateien die immer wieder automatisch generiert werde (Builds) Secrets enthalten (z.B. Passw\u00f6rter, Secrets)","title":".gitignore File"},{"location":"module-1/git/#ein-einfaches-beispiel","text":"git init git add . git commit -am \"First commit\" git remote add origin git@github.com:your_github_user/myapplication.git -- Change/write README.md and .gitignore files git pull origin main -- Send the entire application to Github git push origin main","title":"Ein einfaches Beispiel"},{"location":"module-1/introduction/","text":"Einleitung \"Any fool can write code that a computer can understand. Good programmers write code that humans can understand.\" \u2013 Martin Fowler Clean Code beschreibt die Art und Weise Code so zu schreiben, dass dieser nicht nur seine eigentliche Funktionalit\u00e4t erf\u00fcllt, sondern gleichzeitig auch lesbar, wartbar und erweiterbar ist. Die gesamte Disziplin des \"Clean Code\" basiert hierbar auf dem ebenfalls \"Clean Code\" genannten Buch von Robert Martin (\"Uncle Bob\") - welches eines der wichtigsten B\u00fccher der gesamten IT-Geschichte darstellt und heute noch genauso aktuell ist wie damals. Hinter Abk\u00fcrzunge wie SOLID, KISS und DRY verbergen sich wichtige Konzepte die bis heute sehr wichtig sind f\u00fcr jeden Entwickler - und eben diese wollen wir gemeinsam erkl\u00e4ren. Gemeinsam verfolgen wir das Ziel des Clean Code: Die Steigerung der Code-Qualit\u00e4t welche in der Praxis vorrangig durch empirische Metriken w\u00e4hrend eines Code Reviews gemessen werden kann:","title":"Einf\u00fchrung"},{"location":"module-1/introduction/#einleitung","text":"\"Any fool can write code that a computer can understand. Good programmers write code that humans can understand.\" \u2013 Martin Fowler Clean Code beschreibt die Art und Weise Code so zu schreiben, dass dieser nicht nur seine eigentliche Funktionalit\u00e4t erf\u00fcllt, sondern gleichzeitig auch lesbar, wartbar und erweiterbar ist. Die gesamte Disziplin des \"Clean Code\" basiert hierbar auf dem ebenfalls \"Clean Code\" genannten Buch von Robert Martin (\"Uncle Bob\") - welches eines der wichtigsten B\u00fccher der gesamten IT-Geschichte darstellt und heute noch genauso aktuell ist wie damals. Hinter Abk\u00fcrzunge wie SOLID, KISS und DRY verbergen sich wichtige Konzepte die bis heute sehr wichtig sind f\u00fcr jeden Entwickler - und eben diese wollen wir gemeinsam erkl\u00e4ren. Gemeinsam verfolgen wir das Ziel des Clean Code: Die Steigerung der Code-Qualit\u00e4t welche in der Praxis vorrangig durch empirische Metriken w\u00e4hrend eines Code Reviews gemessen werden kann:","title":"Einleitung"},{"location":"module-1/naming/","text":"Warum Namen wichtig sind Das Ausw\u00e4hlen von Namen f\u00fcr Funktionen, Klassen und Variablen wirkt auf den ersten Blick unwichtig, ist in der Praxis jedoch eines der wichtigsten Momente im Entwicklungsprozess. He who shall be named Indem wir Funktionen, Klassen und Variablen ihre Namen geben, erreichen wir zwei wichtige Dinge: Wir definieren ihre Aufgabe und wir begrenzen ihren Scope Wir geben dem Leser vom Code Informationen \u00fcber das was er gerade liest Beim Vergeben von Namen m\u00fcssen wir also darauf achten, dass schon durch die Namen klar wird worum es sich handelt. Als Leitfaden k\u00f6nnen wir stets dar\u00fcber nachdenken ob ein Leser unseres Codes die Funktionalit\u00e4t von einem Objekt verstehen w\u00fcrde OHNE sich zus\u00e4tzliche Kommentare durchlesen zu m\u00fcssen. Folgende Regeln sollten f\u00fcr Namen im \"Clean Code\" Style erf\u00fcllt sein: Der Name ist lesbar & aussprechbar ( dysUntRetrmnt VS daysUntilRetirement ) Die Intention/Absicht ist klar( int mc VS int monthlyCosts ) Klassen und Objekte haben ein Nomen oder Nomen-Phrase als Namen (User, ErrorLogger) Methoden und Funktionen haben Verben oder Verb-Phrasen als Namen ( retrieveUserFromDatabase() ) TypInformationen sind nicht notwendig (firstNameString VS firstName)","title":"Namen"},{"location":"module-1/naming/#warum-namen-wichtig-sind","text":"Das Ausw\u00e4hlen von Namen f\u00fcr Funktionen, Klassen und Variablen wirkt auf den ersten Blick unwichtig, ist in der Praxis jedoch eines der wichtigsten Momente im Entwicklungsprozess.","title":"Warum Namen wichtig sind"},{"location":"module-1/naming/#he-who-shall-be-named","text":"Indem wir Funktionen, Klassen und Variablen ihre Namen geben, erreichen wir zwei wichtige Dinge: Wir definieren ihre Aufgabe und wir begrenzen ihren Scope Wir geben dem Leser vom Code Informationen \u00fcber das was er gerade liest Beim Vergeben von Namen m\u00fcssen wir also darauf achten, dass schon durch die Namen klar wird worum es sich handelt. Als Leitfaden k\u00f6nnen wir stets dar\u00fcber nachdenken ob ein Leser unseres Codes die Funktionalit\u00e4t von einem Objekt verstehen w\u00fcrde OHNE sich zus\u00e4tzliche Kommentare durchlesen zu m\u00fcssen. Folgende Regeln sollten f\u00fcr Namen im \"Clean Code\" Style erf\u00fcllt sein: Der Name ist lesbar & aussprechbar ( dysUntRetrmnt VS daysUntilRetirement ) Die Intention/Absicht ist klar( int mc VS int monthlyCosts ) Klassen und Objekte haben ein Nomen oder Nomen-Phrase als Namen (User, ErrorLogger) Methoden und Funktionen haben Verben oder Verb-Phrasen als Namen ( retrieveUserFromDatabase() ) TypInformationen sind nicht notwendig (firstNameString VS firstName)","title":"He who shall be named"},{"location":"module-1/structure/","text":"Wie sieht guter Code aus? Der Code ist nicht zu gro\u00df Funktionen und Klassen sollten m\u00f6glichst klein gehalten werden, damit sie einfacher zu lesen sind und damit sie nicht zu viel auf einmal tun. Der Code folgt den Konventionen Jede Programmiersprache und/oder jede Organisation folgt in der Regel einer Konvention wie Code strukturiert und aufgebaut sein sollte. Code der diesen Konventionen folgt ist einfacher zu lesen und schneller zu verstehen von Entwicklern die diese Konvention schon gew\u00f6hnt sind. Zudem sind in den Konventionen oft \"Tricks\" versteckt, welche unter bestimmten Umst\u00e4nden Fehler verhindern k\u00f6nnen. Google beispielsweise ver\u00f6ffentlicht sehr gute Styleguides: Google Java Styleguide Google Python Styleguide Der Code Enth\u00e4lt keine/kaum Duplikate Duplikate / der gleiche Code mehrfach in der Applikation f\u00fchrt oft zu Problemen, da sich der Entwickler immer daran erinnern muss dass er eine \u00c4nderung an einer Stelle auch an allen anderen Stellen nachholen muss. Dies wird bei wachsender Code-Gr\u00f6\u00dfe zu einem immer schwierigeren Problem Der Code beinhaltet Whitespaces f\u00fcr die Lesbarkeit Dicht aneinander geschriebener Code ohne jegliche Leerzeilen etc. ist f\u00fcr Menschen sehr schwer zu lesen. Gelegentliche Leerzeilen und Leerzeichen helfen. Der Code ist hierbei stehts konsistent! Der Code ist richtig einger\u00fcckt (Indentation) Richtiges Einr\u00fccken vom Code steigert die Lesbarkeit ungemein - und w\u00e4hrend es in Programmiersprachen wie Java \"nur\" der Lesbarkeit dient, wirkt sich das Einr\u00fccken vom Code in Sprachen wie Python sogar auf die gesamte Funktionalit\u00e4t aus! ... aber nicht zu oft einger\u00fcckt Ist ein Code sehr oft einger\u00fcckt, weil es viele IF Bedingungen gibt o\u00c4, so ist dies nicht nur schwierig zu lesen sondern auch mental sehr schwierig nachzuvollziehen. Eine Technik die sich in der Praxis gut bew\u00e4hrt hat um komplexe IF Szenarios zu vereinfachen ist das \"return early pattern\" - welches im Modul 2 genauer erkl\u00e4rt wird Der Code beinhaltet keine Magic Numbers Magic Numbers beschreiben Zahlen oder Werte im Code, die f\u00fcr einen Leser nicht direkt offensichtlich sind. Magic Numbers sollten mit der Hilfe von Konstanten oder \u00e4hnlichen Konstrukten weiter erkl\u00e4rt werden if(age >= 20) { executeCode(); } Besser: public static final int LEGAL_DRINKING_AGE_IN_JAPAN = 20; (...) if( age >= LEGAL_DRINKING_AGE_IN_JAPAN) { executeCode(); } Der Code kapselt komplexe Logik Komplexe Logik (z.B. gro\u00dfe IF Abfragen) k\u00f6nnen sehr schwierig zu lesen und zu verstehen sein, wodurch sie auch den Code um sie herum beeinflussen kann und schwieriger zu supporten macht. Um dies etwas zu verbessern sollte komplexe Logik via \"Zwischen-Variablen\" oder am besten gleich in dedizierte Funktionen gekapselt werden. Nicht gut: if ( employee.age > 55 && employee.yearsEmplyed > 10 && employee.isRetired ) { // do something } Besser: bool eligibleForPension = employee.age > minRetirementAge && employee.yearEmployed > minPensionEmploymentYears && emplyee.isRetired ; Noch besser: private boolean isEligbleForPension(Employee employee) { return employee.age > minRetirementAge && employee.yearEmployed > minPensionEmploymentYears && emplyee.isRetired; } (...) if( isEligbleForPension(employee) ) { // do something }","title":"Code-Struktur"},{"location":"module-1/structure/#wie-sieht-guter-code-aus","text":"","title":"Wie sieht guter Code aus?"},{"location":"module-1/structure/#der-code-ist-nicht-zu-gro","text":"Funktionen und Klassen sollten m\u00f6glichst klein gehalten werden, damit sie einfacher zu lesen sind und damit sie nicht zu viel auf einmal tun.","title":"Der Code ist nicht zu gro\u00df"},{"location":"module-1/structure/#der-code-folgt-den-konventionen","text":"Jede Programmiersprache und/oder jede Organisation folgt in der Regel einer Konvention wie Code strukturiert und aufgebaut sein sollte. Code der diesen Konventionen folgt ist einfacher zu lesen und schneller zu verstehen von Entwicklern die diese Konvention schon gew\u00f6hnt sind. Zudem sind in den Konventionen oft \"Tricks\" versteckt, welche unter bestimmten Umst\u00e4nden Fehler verhindern k\u00f6nnen. Google beispielsweise ver\u00f6ffentlicht sehr gute Styleguides: Google Java Styleguide Google Python Styleguide","title":"Der Code folgt den Konventionen"},{"location":"module-1/structure/#der-code-enthalt-keinekaum-duplikate","text":"Duplikate / der gleiche Code mehrfach in der Applikation f\u00fchrt oft zu Problemen, da sich der Entwickler immer daran erinnern muss dass er eine \u00c4nderung an einer Stelle auch an allen anderen Stellen nachholen muss. Dies wird bei wachsender Code-Gr\u00f6\u00dfe zu einem immer schwierigeren Problem","title":"Der Code Enth\u00e4lt keine/kaum Duplikate"},{"location":"module-1/structure/#der-code-beinhaltet-whitespaces-fur-die-lesbarkeit","text":"Dicht aneinander geschriebener Code ohne jegliche Leerzeilen etc. ist f\u00fcr Menschen sehr schwer zu lesen. Gelegentliche Leerzeilen und Leerzeichen helfen. Der Code ist hierbei stehts konsistent!","title":"Der Code beinhaltet Whitespaces f\u00fcr die Lesbarkeit"},{"location":"module-1/structure/#der-code-ist-richtig-eingeruckt-indentation","text":"Richtiges Einr\u00fccken vom Code steigert die Lesbarkeit ungemein - und w\u00e4hrend es in Programmiersprachen wie Java \"nur\" der Lesbarkeit dient, wirkt sich das Einr\u00fccken vom Code in Sprachen wie Python sogar auf die gesamte Funktionalit\u00e4t aus!","title":"Der Code ist richtig einger\u00fcckt (Indentation)"},{"location":"module-1/structure/#aber-nicht-zu-oft-eingeruckt","text":"Ist ein Code sehr oft einger\u00fcckt, weil es viele IF Bedingungen gibt o\u00c4, so ist dies nicht nur schwierig zu lesen sondern auch mental sehr schwierig nachzuvollziehen. Eine Technik die sich in der Praxis gut bew\u00e4hrt hat um komplexe IF Szenarios zu vereinfachen ist das \"return early pattern\" - welches im Modul 2 genauer erkl\u00e4rt wird","title":"... aber nicht zu oft einger\u00fcckt"},{"location":"module-1/structure/#der-code-beinhaltet-keine-magic-numbers","text":"Magic Numbers beschreiben Zahlen oder Werte im Code, die f\u00fcr einen Leser nicht direkt offensichtlich sind. Magic Numbers sollten mit der Hilfe von Konstanten oder \u00e4hnlichen Konstrukten weiter erkl\u00e4rt werden if(age >= 20) { executeCode(); } Besser: public static final int LEGAL_DRINKING_AGE_IN_JAPAN = 20; (...) if( age >= LEGAL_DRINKING_AGE_IN_JAPAN) { executeCode(); }","title":"Der Code beinhaltet keine Magic Numbers"},{"location":"module-1/structure/#der-code-kapselt-komplexe-logik","text":"Komplexe Logik (z.B. gro\u00dfe IF Abfragen) k\u00f6nnen sehr schwierig zu lesen und zu verstehen sein, wodurch sie auch den Code um sie herum beeinflussen kann und schwieriger zu supporten macht. Um dies etwas zu verbessern sollte komplexe Logik via \"Zwischen-Variablen\" oder am besten gleich in dedizierte Funktionen gekapselt werden. Nicht gut: if ( employee.age > 55 && employee.yearsEmplyed > 10 && employee.isRetired ) { // do something } Besser: bool eligibleForPension = employee.age > minRetirementAge && employee.yearEmployed > minPensionEmploymentYears && emplyee.isRetired ; Noch besser: private boolean isEligbleForPension(Employee employee) { return employee.age > minRetirementAge && employee.yearEmployed > minPensionEmploymentYears && emplyee.isRetired; } (...) if( isEligbleForPension(employee) ) { // do something }","title":"Der Code kapselt komplexe Logik"},{"location":"module-2/automated-formatters/","text":"Prettier, Husky, ...","title":"Automated formatters"},{"location":"module-2/dependency-injection/","text":"Spring...","title":"Dependency injection"},{"location":"module-2/exception-handling/","text":"Fehlerbehandlung Einleitung Das Auftreten und Behandeln von Fehlern geh\u00f6rt zum Alltag jeder Applikation und zur t\u00e4glichen Arbeit eines jeden Entwicklers. Ob ein Fehler auftritt weil unser Code selbst diesen verursacht hat oder wir von einem externen System oder Modul abh\u00e4ngen und dieses widerum einen Fehlerzustand festgestellt hat ist hierbei nicht wichtig - wichtig ist nur, dass wir als Entwickler auf diesen Umstand reagieren m\u00fcssen Unterscheidung der Arten von Fehlern Beim Schreiben von Code zur Behandlung von Zust\u00e4nden die einen Fehler darstellen ist es zuerst am wichtigsten zu identifizieren ob wir selbst mit unserem Code diesen Zustand behandeln/l\u00f6sen k\u00f6nnen oder nicht. K\u00f6nnen wir den Fehler behandeln, l\u00f6sen oder umgehen - so ist es im Zweifel nur eine weitere Funktion oder ein weiteres Modul welches wir entwickeln m\u00fcssen um das Problem zu l\u00f6sen und einen \"normalen\" Zustand wieder herzustellen. K\u00f6nnen wir mit unserem Code den Fehler jedoch nicht l\u00f6sen (etwa, weil er ein Feedback vom Nutzer braucht, unser Code aber ein Java-Backend-System ohne direkten Zugriff zum User ist), so m\u00fcssen wir auf sogenannte Exceptions zur\u00fcckgreifen. Was sind Exceptions Exceptions sind als Paradigma in fast allen modernen Programmiersprachen vorhanden und beschreiben in der Regel gleichzeitig eine Ver\u00e4nderung des Kontrollflusses (also der Code der als n\u00e4chstes ausgef\u00fchrt wird) als auch ein Objekt mit Meta-Informationen zum aufgetretenen Fehler. Exceptions haben sich in der Praxis als besseres Paradigma als \"Return Codes\" herausgestellt, welche vor allem in fr\u00fcheren Programmiersprachen- und umgebungen sehr verbreitet waren. Return Codes haben den Nachteil, dass sie sehr viel Interpretation durch den Empf\u00e4nger des Return Codes ben\u00f6tigen und meistens sehr wenige dazugeh\u00f6rige Meta Informationen zur Verf\u00fcgung stellen, welche zur L\u00f6sung des Problems wom\u00f6glich sinnvoll w\u00e4ren. Wie nutze ich Exceptions Jede Programmiersprache hat zum Thema Exceptions ihren eigenen Syntax und Konzepte - wobei sich das Grundparadigma kaum unterscheidet. Betrachtet werden k\u00f6nnen immer 2 Szenarien: Szenario 1 - Werfen von Exceptions Erkennt unser Code einen Fehler den wir selbst nicht behandeln k\u00f6nnen, so wird das Werfen einer Exception sinnvoll. Wir erstellen hierbei ein typisiertes Exception-Objekt welches wir mit Informationen f\u00fcllen die dem \"Empf\u00e4nger\" dieses Objekts ggf. n\u00fctzlich sind um den Fehler behandeln zu k\u00f6nnen. Es ist hierbei wichtig dass wir sinnvolle Informationen und Exception-Typen w\u00e4hlen, um dem Empf\u00e4nger unserer Exception die beste Chance zu geben das Problem zu l\u00f6sen oder zu behandeln. if( somethingBadHappened) { throw new MyException(\"Dieser String\"); } Der Programmfluss wird hierbei beim Werfen der Exception unterbrochen, \"unser\" Code wird nicht weiter ausgef\u00fchrt sondern die Exception wandert in der Funktions-Hierarchie weiter nach oben bis es einen korrespondierenden Handler/Catch-Block erreicht. Gibt es in der gesamten Funktions-Hierarchie keinen passenden Exeption-Handler, so wird in der Regel die gesamte Applikation beendet. Szenario 2 - Fangen von Exceptions Haben wir Code oder Funktionen aufgerufen die unter Umst\u00e4nden Exceptions werfen, so liegt es an uns diese Exceptions zu \"fangen\" wenn wir sie behandeln k\u00f6nnen . Ist unser Code aus irgendwelchen Gr\u00fcnden nicht in der Lage die Exception zu behandeln, so sollten wir sie gar nicht erst fangen um einem anderen Modul weiter \"oben\" in der Hierarchie die M\u00f6glichkeit zu geben diese Exception zu behandeln. In der Java-Welt besteht ein Exception-Handling aus 3 Code-Bl\u00f6cken die zueinander geh\u00f6ren. Try: dies ist der Code Block, in dem wir Exceptions erwarten und bei deren Auftreten wir reagieren wollen Catch: in 0-n Catch-Bl\u00f6cken \"fangen\" und behandeln wir m\u00f6glicherweise auftretende Exceptions f\u00fcr jeweils 1 bestimmten Typ Finally: dieser Block beschreibt Code der definitiv ausgef\u00fchrt werden soll, egal ob eine Exception aufgetreten ist oder nicht try { callMyFunction(); } catch (MyException e) { displayErrorToUser(e.getMessage()); setErrorState(true); } finally { System.out.println(\"The function has finished\"); } Wie designe ich Exceptions Die meisten Programmiersprachen beinhalten selbst schon eine eigene Hierarchie von Exception-Typen, welche ihrerseits diverse Fehlerszenarien beschreiben. Es ist sinnvoll diese zu nutzen und ggf. um eigene Typen zu erweitern, wobei sich hier oft die Vorteile der Abstraktion zeigen. Wie funktioniert es in Java? Java unterscheidet grunds\u00e4tzlich zwischen Exceptions und Errors, wobei beide Arten (und ihre Unterarten) das Interface \"Throwable\" implementieren. Exceptions in der Java-Welt stellen Fehler und Zust\u00e4nde dar, von denen eigentlich zu erwarten ist dass eine Applikation diese auf irgendeine Weise behandelt und/oder weitergibt. Errors auf der anderen Seite stellen Zust\u00e4nde dar \u00fcber die die Applikation zwar informiert wird aber welche dann in der Regel nicht behandelt werden (k\u00f6nnen). OutOfMemoryError oder StackOverflowError beispielsweise sind 2 Fehlertypen bei denen die Applikation nicht weiter reagieren kann - da ihr Auftreten zur Terminierung der Applikation f\u00fchrt. Wann sollte ich keine Exceptions nutzen? Exceptions sollten vor allem in den Momenten nicht genutzt werden, wo die Applikation sich eigentlich noch in einem normalen Zustand und Fluss befindet. Dies hat vor allem zwei Gr\u00fcnde: + Das Nachverfolgen von einem durch Exceptions kontrollierten Programmfluss ist f\u00fcr einen Entwickler relaltiv schwierig + Exceptions sind aus Performanceperspektive relativ \"teure\" Operationen (mindestens in Java) und k\u00f6nnten in performancekritischen Code zu Verlusten f\u00fchren.","title":"Fehlerbehandlung"},{"location":"module-2/exception-handling/#fehlerbehandlung","text":"","title":"Fehlerbehandlung"},{"location":"module-2/exception-handling/#einleitung","text":"Das Auftreten und Behandeln von Fehlern geh\u00f6rt zum Alltag jeder Applikation und zur t\u00e4glichen Arbeit eines jeden Entwicklers. Ob ein Fehler auftritt weil unser Code selbst diesen verursacht hat oder wir von einem externen System oder Modul abh\u00e4ngen und dieses widerum einen Fehlerzustand festgestellt hat ist hierbei nicht wichtig - wichtig ist nur, dass wir als Entwickler auf diesen Umstand reagieren m\u00fcssen","title":"Einleitung"},{"location":"module-2/exception-handling/#unterscheidung-der-arten-von-fehlern","text":"Beim Schreiben von Code zur Behandlung von Zust\u00e4nden die einen Fehler darstellen ist es zuerst am wichtigsten zu identifizieren ob wir selbst mit unserem Code diesen Zustand behandeln/l\u00f6sen k\u00f6nnen oder nicht. K\u00f6nnen wir den Fehler behandeln, l\u00f6sen oder umgehen - so ist es im Zweifel nur eine weitere Funktion oder ein weiteres Modul welches wir entwickeln m\u00fcssen um das Problem zu l\u00f6sen und einen \"normalen\" Zustand wieder herzustellen. K\u00f6nnen wir mit unserem Code den Fehler jedoch nicht l\u00f6sen (etwa, weil er ein Feedback vom Nutzer braucht, unser Code aber ein Java-Backend-System ohne direkten Zugriff zum User ist), so m\u00fcssen wir auf sogenannte Exceptions zur\u00fcckgreifen.","title":"Unterscheidung der Arten von Fehlern"},{"location":"module-2/exception-handling/#was-sind-exceptions","text":"Exceptions sind als Paradigma in fast allen modernen Programmiersprachen vorhanden und beschreiben in der Regel gleichzeitig eine Ver\u00e4nderung des Kontrollflusses (also der Code der als n\u00e4chstes ausgef\u00fchrt wird) als auch ein Objekt mit Meta-Informationen zum aufgetretenen Fehler. Exceptions haben sich in der Praxis als besseres Paradigma als \"Return Codes\" herausgestellt, welche vor allem in fr\u00fcheren Programmiersprachen- und umgebungen sehr verbreitet waren. Return Codes haben den Nachteil, dass sie sehr viel Interpretation durch den Empf\u00e4nger des Return Codes ben\u00f6tigen und meistens sehr wenige dazugeh\u00f6rige Meta Informationen zur Verf\u00fcgung stellen, welche zur L\u00f6sung des Problems wom\u00f6glich sinnvoll w\u00e4ren.","title":"Was sind Exceptions"},{"location":"module-2/exception-handling/#wie-nutze-ich-exceptions","text":"Jede Programmiersprache hat zum Thema Exceptions ihren eigenen Syntax und Konzepte - wobei sich das Grundparadigma kaum unterscheidet. Betrachtet werden k\u00f6nnen immer 2 Szenarien:","title":"Wie nutze ich Exceptions"},{"location":"module-2/exception-handling/#szenario-1-werfen-von-exceptions","text":"Erkennt unser Code einen Fehler den wir selbst nicht behandeln k\u00f6nnen, so wird das Werfen einer Exception sinnvoll. Wir erstellen hierbei ein typisiertes Exception-Objekt welches wir mit Informationen f\u00fcllen die dem \"Empf\u00e4nger\" dieses Objekts ggf. n\u00fctzlich sind um den Fehler behandeln zu k\u00f6nnen. Es ist hierbei wichtig dass wir sinnvolle Informationen und Exception-Typen w\u00e4hlen, um dem Empf\u00e4nger unserer Exception die beste Chance zu geben das Problem zu l\u00f6sen oder zu behandeln. if( somethingBadHappened) { throw new MyException(\"Dieser String\"); } Der Programmfluss wird hierbei beim Werfen der Exception unterbrochen, \"unser\" Code wird nicht weiter ausgef\u00fchrt sondern die Exception wandert in der Funktions-Hierarchie weiter nach oben bis es einen korrespondierenden Handler/Catch-Block erreicht. Gibt es in der gesamten Funktions-Hierarchie keinen passenden Exeption-Handler, so wird in der Regel die gesamte Applikation beendet.","title":"Szenario 1 - Werfen von Exceptions"},{"location":"module-2/exception-handling/#szenario-2-fangen-von-exceptions","text":"Haben wir Code oder Funktionen aufgerufen die unter Umst\u00e4nden Exceptions werfen, so liegt es an uns diese Exceptions zu \"fangen\" wenn wir sie behandeln k\u00f6nnen . Ist unser Code aus irgendwelchen Gr\u00fcnden nicht in der Lage die Exception zu behandeln, so sollten wir sie gar nicht erst fangen um einem anderen Modul weiter \"oben\" in der Hierarchie die M\u00f6glichkeit zu geben diese Exception zu behandeln. In der Java-Welt besteht ein Exception-Handling aus 3 Code-Bl\u00f6cken die zueinander geh\u00f6ren. Try: dies ist der Code Block, in dem wir Exceptions erwarten und bei deren Auftreten wir reagieren wollen Catch: in 0-n Catch-Bl\u00f6cken \"fangen\" und behandeln wir m\u00f6glicherweise auftretende Exceptions f\u00fcr jeweils 1 bestimmten Typ Finally: dieser Block beschreibt Code der definitiv ausgef\u00fchrt werden soll, egal ob eine Exception aufgetreten ist oder nicht try { callMyFunction(); } catch (MyException e) { displayErrorToUser(e.getMessage()); setErrorState(true); } finally { System.out.println(\"The function has finished\"); }","title":"Szenario 2 - Fangen von Exceptions"},{"location":"module-2/exception-handling/#wie-designe-ich-exceptions","text":"Die meisten Programmiersprachen beinhalten selbst schon eine eigene Hierarchie von Exception-Typen, welche ihrerseits diverse Fehlerszenarien beschreiben. Es ist sinnvoll diese zu nutzen und ggf. um eigene Typen zu erweitern, wobei sich hier oft die Vorteile der Abstraktion zeigen.","title":"Wie designe ich Exceptions"},{"location":"module-2/exception-handling/#wie-funktioniert-es-in-java","text":"Java unterscheidet grunds\u00e4tzlich zwischen Exceptions und Errors, wobei beide Arten (und ihre Unterarten) das Interface \"Throwable\" implementieren. Exceptions in der Java-Welt stellen Fehler und Zust\u00e4nde dar, von denen eigentlich zu erwarten ist dass eine Applikation diese auf irgendeine Weise behandelt und/oder weitergibt. Errors auf der anderen Seite stellen Zust\u00e4nde dar \u00fcber die die Applikation zwar informiert wird aber welche dann in der Regel nicht behandelt werden (k\u00f6nnen). OutOfMemoryError oder StackOverflowError beispielsweise sind 2 Fehlertypen bei denen die Applikation nicht weiter reagieren kann - da ihr Auftreten zur Terminierung der Applikation f\u00fchrt.","title":"Wie funktioniert es in Java?"},{"location":"module-2/exception-handling/#wann-sollte-ich-keine-exceptions-nutzen","text":"Exceptions sollten vor allem in den Momenten nicht genutzt werden, wo die Applikation sich eigentlich noch in einem normalen Zustand und Fluss befindet. Dies hat vor allem zwei Gr\u00fcnde: + Das Nachverfolgen von einem durch Exceptions kontrollierten Programmfluss ist f\u00fcr einen Entwickler relaltiv schwierig + Exceptions sind aus Performanceperspektive relativ \"teure\" Operationen (mindestens in Java) und k\u00f6nnten in performancekritischen Code zu Verlusten f\u00fchren.","title":"Wann sollte ich keine Exceptions nutzen?"},{"location":"module-2/exercise/","text":"Aufgaben Aufgabe 1 Eure Aufgabe ist das Umschreiben dieser Funktion anhand der bisher gelernten Konzepte von Clean Code. Euer Ziel ist die Verbesserung der Lesbarkeit und Wartbarkeit des Codes, zusammen mit allen weiteren Optimierungen die m\u00f6glich w\u00e4ren. Was w\u00fcrdet ihr dem Autoren dieser Funktion sagen, was er/sie n\u00e4chstes Mal besser machen kann? public void onChangeSelectedChart(ClickEvent event, int: number) { if (event.checked != null) { if (event.checked == true) { if (typeChart == chartTypes.lineChart) { setIsLineChecked(true); setIsStackedChartChecked(false); rootStore.appState.setActiveChartType(chartTypes.lineChart); } else { setIsStackedChartChecked(true); setIsLineChecked(false); rootStore.appState.setActiveChartType(chartTypes.stackedChart); } } else { if (typeChart == chartTypes.lineChart) { setIsLineChecked(false); } else if (typeChart === chartTypes.stackedChart) { setIsStackedChartChecked(false); } } } }; Aufgabe 2 Was w\u00fcrdest du bei diesem Code optimieren? Bitte begr\u00fcnde deine L\u00f6sung public void createSavegame(String gameState, String filename) { try { BufferedWriter writer = new BufferedWriter(new FileWriter(fileName)); writer.write(str); writer.close(); } catch (IOException e) {} } public void doOtherStuff() { try { callMyApi(); } catch(StackOverflowError e) { // retry logic doOtherStuff(); } }","title":"Aufgaben"},{"location":"module-2/exercise/#aufgaben","text":"","title":"Aufgaben"},{"location":"module-2/exercise/#aufgabe-1","text":"Eure Aufgabe ist das Umschreiben dieser Funktion anhand der bisher gelernten Konzepte von Clean Code. Euer Ziel ist die Verbesserung der Lesbarkeit und Wartbarkeit des Codes, zusammen mit allen weiteren Optimierungen die m\u00f6glich w\u00e4ren. Was w\u00fcrdet ihr dem Autoren dieser Funktion sagen, was er/sie n\u00e4chstes Mal besser machen kann? public void onChangeSelectedChart(ClickEvent event, int: number) { if (event.checked != null) { if (event.checked == true) { if (typeChart == chartTypes.lineChart) { setIsLineChecked(true); setIsStackedChartChecked(false); rootStore.appState.setActiveChartType(chartTypes.lineChart); } else { setIsStackedChartChecked(true); setIsLineChecked(false); rootStore.appState.setActiveChartType(chartTypes.stackedChart); } } else { if (typeChart == chartTypes.lineChart) { setIsLineChecked(false); } else if (typeChart === chartTypes.stackedChart) { setIsStackedChartChecked(false); } } } };","title":"Aufgabe 1"},{"location":"module-2/exercise/#aufgabe-2","text":"Was w\u00fcrdest du bei diesem Code optimieren? Bitte begr\u00fcnde deine L\u00f6sung public void createSavegame(String gameState, String filename) { try { BufferedWriter writer = new BufferedWriter(new FileWriter(fileName)); writer.write(str); writer.close(); } catch (IOException e) {} } public void doOtherStuff() { try { callMyApi(); } catch(StackOverflowError e) { // retry logic doOtherStuff(); } }","title":"Aufgabe 2"},{"location":"module-2/if-inversion/","text":"If-Inversion Eine in der Praxis oft angewandte Strategie f\u00fcr die bessere Lesbarkeit von Code ist die sogenannte \"If-Inversion\", welche unter anderem auch als \"early return Stragie\", \"guard clauses\" und diverse andere Namen bekannt ist. Unabh\u00e4ngig vom Namen und den teilweise auch minimal anderen Zielen dieser verschiedenen Stragien verhalten sich diese jedoch alle im Grunde gleich: Ein Beispiel zur Veranschaulichung Betrachten wir den folgenden recht komplexen Code: public String returnStuff(SomeObject argument1, SomeObject argument2) { if (argument1.isValid()) { if (argument2.isValid()) { SomeObject otherVal1 = doSomeStuff(argument1, argument2) if (otherVal1.isValid()) { SomeObject otherVal2 = doAnotherStuff(otherVal1) if (otherVal2.isValid()) { return \"Stuff\"; } else { throw new Exception(); } } else { throw new Exception(); } } else { throw new Exception(); } } else { throw new Exception(); } } Anwendung der If-Inversion Drehen wir nun aber den Code um und behandeln die F\u00e4lle bei denen wir \"nichts machen k\u00f6nnen\" zuerst, so sehen wir wie ganz automatisch die Menge der geschachtelten Ausdr\u00fccke immer weiter abnimmt. Wir k\u00f6nnen nach und nach verschiedene Fehler-Szenarien abfangen und hierzu passende L\u00f6sungen (Return-Werte, Exceptions oder sonstige Behandlungen) ausf\u00fchren, ohne auf den restlichen Code Auswirkungen zu haben. Der Code wird hierdurch deutlich klarer und von einem Leser deutlich einfacher zu lesen. public String returnStuff(SomeObject argument1, SomeObject argument2){ if (!argument1.isValid()) { throw new Exception(); } if (!argument2.isValid()) { throw new Exception(); } SomeObject otherVal1 = doSomeStuff(argument1, argument2); if (!otherVal1.isValid()) { throw new Exception(); } SomeObject otherVal2 = doAnotherStuff(otherVal1); if (!otherVal2.isValid()) { throw new Exception(); } return \"Stuff\"; } https://medium.com/swlh/return-early-pattern-3d18a41bba8","title":"If-Inversion"},{"location":"module-2/if-inversion/#if-inversion","text":"Eine in der Praxis oft angewandte Strategie f\u00fcr die bessere Lesbarkeit von Code ist die sogenannte \"If-Inversion\", welche unter anderem auch als \"early return Stragie\", \"guard clauses\" und diverse andere Namen bekannt ist. Unabh\u00e4ngig vom Namen und den teilweise auch minimal anderen Zielen dieser verschiedenen Stragien verhalten sich diese jedoch alle im Grunde gleich:","title":"If-Inversion"},{"location":"module-2/if-inversion/#ein-beispiel-zur-veranschaulichung","text":"Betrachten wir den folgenden recht komplexen Code: public String returnStuff(SomeObject argument1, SomeObject argument2) { if (argument1.isValid()) { if (argument2.isValid()) { SomeObject otherVal1 = doSomeStuff(argument1, argument2) if (otherVal1.isValid()) { SomeObject otherVal2 = doAnotherStuff(otherVal1) if (otherVal2.isValid()) { return \"Stuff\"; } else { throw new Exception(); } } else { throw new Exception(); } } else { throw new Exception(); } } else { throw new Exception(); } }","title":"Ein Beispiel zur Veranschaulichung"},{"location":"module-2/if-inversion/#anwendung-der-if-inversion","text":"Drehen wir nun aber den Code um und behandeln die F\u00e4lle bei denen wir \"nichts machen k\u00f6nnen\" zuerst, so sehen wir wie ganz automatisch die Menge der geschachtelten Ausdr\u00fccke immer weiter abnimmt. Wir k\u00f6nnen nach und nach verschiedene Fehler-Szenarien abfangen und hierzu passende L\u00f6sungen (Return-Werte, Exceptions oder sonstige Behandlungen) ausf\u00fchren, ohne auf den restlichen Code Auswirkungen zu haben. Der Code wird hierdurch deutlich klarer und von einem Leser deutlich einfacher zu lesen. public String returnStuff(SomeObject argument1, SomeObject argument2){ if (!argument1.isValid()) { throw new Exception(); } if (!argument2.isValid()) { throw new Exception(); } SomeObject otherVal1 = doSomeStuff(argument1, argument2); if (!otherVal1.isValid()) { throw new Exception(); } SomeObject otherVal2 = doAnotherStuff(otherVal1); if (!otherVal2.isValid()) { throw new Exception(); } return \"Stuff\"; } https://medium.com/swlh/return-early-pattern-3d18a41bba8","title":"Anwendung der If-Inversion"},{"location":"module-2/refactoring/","text":"","title":"Refactoring"},{"location":"module-2/single-responsibility-principle/","text":"Single-Responsibility Principle Code-Module die zu viele Dinge auf einmal tut wird \u00fcber kurz oder lang sehr schwierig zu warten und zu lesen. In der Praxis hat sich daher das \"Single-Responsibility Principle\" (SRP) etabliert. Dieses wurde von Robert C. Martin in der Form seines Mantras \"Eine Klasse sollte nur einen Grund sich zu \u00e4ndern haben\" (A class should have only one reason to change). Dies bedeutet, dass jede Klasse (und de facto auch jede Funktion) exakt 1 Funktion haben sollte. Stellt sich irgendwann heraus, dass eine Klasse beginnt mehr Funktionen zu implementieren, so sollten diese in eine neue Klasse ausgelagert werden. Ein Beispiel Was sagt ihr zu diesem Beispiel? public class UserService { public void registerUser(User user) { final String emailSender = \"myemail@yahoo.com\"; final String emailPassword = \"mypassword\"; final String toEmail = user.getEmail(); Properties props = new Properties(); props.put(\"mail.smtp.host\", \"smtp.gmail.com\"); // SMTP Host props.put(\"mail.smtp.port\", \"587\"); // TLS Port props.put(\"mail.smtp.auth\", \"true\"); // enable authentication props.put(\"mail.smtp.starttls.enable\", \"true\"); // enable STARTTLS // create Authenticator object to pass in Session.getInstance argument Authenticator auth = new Authenticator() { // override the getPasswordAuthentication method protected PasswordAuthentication getPasswordAuthentication() { return new PasswordAuthentication(emailSender, emailPassword); } }; Session session = Session.getInstance(props, auth); sendEmail(session, toEmail, \"User registered\", \"A user was registered\"); } private void sendEmail(Session session, String toEmail, String subject, String body) { try { MimeMessage msg = new MimeMessage(session); msg.addHeader(\"Content-type\", \"text/HTML; charset=UTF-8\"); // Insert email preparation code here Transport.send(msg); System.out.println(\"EMail Sent Successfully!!\"); } catch (Exception e) { e.printStackTrace(); } } } Cohesion VS Coupling Im Rahmen des SRP wird oft \u00fcber den Vergleich zwischen Cohesion und (Loose) Coupling gesprochen. Cohesion beschreibt den Umstand, dass Code der logisch und technisch zusammen geh\u00f6rt auch in der gleichen Klasse/im gleichen Modul sein sollte. Das angestrebte \"Loose Coupling\" widerum beschreibt das logische Gegenteil hiervon: Code der nicht direkt zusammengeh\u00f6rt sollte in verschiede Klassen/Module aufgeteilt sein und hierbei alleine lauff\u00e4hig sein! Funktioniert eine Klasse/Modul nur zusammen mit einer/m anderen Klasse/Modul, so sind diese nicht \"loosely coupled\". Ein Moment zum Nachdenken Die Herausforderung beim Anwenden des SRP ist, dass jeder Entwickler seine eigene Interpretation und seine eigene Meinung haben wird, was genau die eigetliche Aufgabe eines jeden Moduls sein soll. Die Entscheidung, ob eine neue Funktionalit\u00e4t noch Teil eines Moduls sein sollte oder besser in ein neues Modul geh\u00f6rt, ist daher oft nicht klar zu beantworten. Es ist daher wichtig, dass jeder Entwickler sorgf\u00e4ltig dar\u00fcber nachdenkt, wie er seinen Code strukturiert - und stets auch andere Entwickler und deren Anspr\u00fcche im Hinterkopf beh\u00e4lt.","title":"Single-Responsibility Principle"},{"location":"module-2/single-responsibility-principle/#single-responsibility-principle","text":"Code-Module die zu viele Dinge auf einmal tut wird \u00fcber kurz oder lang sehr schwierig zu warten und zu lesen. In der Praxis hat sich daher das \"Single-Responsibility Principle\" (SRP) etabliert. Dieses wurde von Robert C. Martin in der Form seines Mantras \"Eine Klasse sollte nur einen Grund sich zu \u00e4ndern haben\" (A class should have only one reason to change). Dies bedeutet, dass jede Klasse (und de facto auch jede Funktion) exakt 1 Funktion haben sollte. Stellt sich irgendwann heraus, dass eine Klasse beginnt mehr Funktionen zu implementieren, so sollten diese in eine neue Klasse ausgelagert werden.","title":"Single-Responsibility Principle"},{"location":"module-2/single-responsibility-principle/#ein-beispiel","text":"Was sagt ihr zu diesem Beispiel? public class UserService { public void registerUser(User user) { final String emailSender = \"myemail@yahoo.com\"; final String emailPassword = \"mypassword\"; final String toEmail = user.getEmail(); Properties props = new Properties(); props.put(\"mail.smtp.host\", \"smtp.gmail.com\"); // SMTP Host props.put(\"mail.smtp.port\", \"587\"); // TLS Port props.put(\"mail.smtp.auth\", \"true\"); // enable authentication props.put(\"mail.smtp.starttls.enable\", \"true\"); // enable STARTTLS // create Authenticator object to pass in Session.getInstance argument Authenticator auth = new Authenticator() { // override the getPasswordAuthentication method protected PasswordAuthentication getPasswordAuthentication() { return new PasswordAuthentication(emailSender, emailPassword); } }; Session session = Session.getInstance(props, auth); sendEmail(session, toEmail, \"User registered\", \"A user was registered\"); } private void sendEmail(Session session, String toEmail, String subject, String body) { try { MimeMessage msg = new MimeMessage(session); msg.addHeader(\"Content-type\", \"text/HTML; charset=UTF-8\"); // Insert email preparation code here Transport.send(msg); System.out.println(\"EMail Sent Successfully!!\"); } catch (Exception e) { e.printStackTrace(); } } }","title":"Ein Beispiel"},{"location":"module-2/single-responsibility-principle/#cohesion-vs-coupling","text":"Im Rahmen des SRP wird oft \u00fcber den Vergleich zwischen Cohesion und (Loose) Coupling gesprochen. Cohesion beschreibt den Umstand, dass Code der logisch und technisch zusammen geh\u00f6rt auch in der gleichen Klasse/im gleichen Modul sein sollte. Das angestrebte \"Loose Coupling\" widerum beschreibt das logische Gegenteil hiervon: Code der nicht direkt zusammengeh\u00f6rt sollte in verschiede Klassen/Module aufgeteilt sein und hierbei alleine lauff\u00e4hig sein! Funktioniert eine Klasse/Modul nur zusammen mit einer/m anderen Klasse/Modul, so sind diese nicht \"loosely coupled\".","title":"Cohesion VS Coupling"},{"location":"module-2/single-responsibility-principle/#ein-moment-zum-nachdenken","text":"Die Herausforderung beim Anwenden des SRP ist, dass jeder Entwickler seine eigene Interpretation und seine eigene Meinung haben wird, was genau die eigetliche Aufgabe eines jeden Moduls sein soll. Die Entscheidung, ob eine neue Funktionalit\u00e4t noch Teil eines Moduls sein sollte oder besser in ein neues Modul geh\u00f6rt, ist daher oft nicht klar zu beantworten. Es ist daher wichtig, dass jeder Entwickler sorgf\u00e4ltig dar\u00fcber nachdenkt, wie er seinen Code strukturiert - und stets auch andere Entwickler und deren Anspr\u00fcche im Hinterkopf beh\u00e4lt.","title":"Ein Moment zum Nachdenken"},{"location":"module-2/solutions/","text":"L\u00f6sungen zu den Aufgaben von Modul 2 (1) IF Inversion if (null == event || null == event.checked) return; const isActive: boolean = event.checked; const isLineChart: boolean = typeChart === chartTypes.lineChart; const activeChartType: string = isLineChart ? chartTypes.lineChart : chartTypes.stackedChart; if (isActive) { setIsLineChecked(isLineChart); setIsStackedChartChecked(!isLineChart); rootStore.appState.setActiveChartType(activeChartType); } else { isLineChart ? setIsLineChecked(isActive) : setIsStackedChartChecked(isActive); }","title":"L\u00f6sungen zu den Aufgaben von Modul 2"},{"location":"module-2/solutions/#losungen-zu-den-aufgaben-von-modul-2","text":"","title":"L\u00f6sungen zu den Aufgaben von Modul 2"},{"location":"module-2/solutions/#1-if-inversion","text":"if (null == event || null == event.checked) return; const isActive: boolean = event.checked; const isLineChart: boolean = typeChart === chartTypes.lineChart; const activeChartType: string = isLineChart ? chartTypes.lineChart : chartTypes.stackedChart; if (isActive) { setIsLineChecked(isLineChart); setIsStackedChartChecked(!isLineChart); rootStore.appState.setActiveChartType(activeChartType); } else { isLineChart ? setIsLineChecked(isActive) : setIsStackedChartChecked(isActive); }","title":"(1) IF Inversion"},{"location":"module-2/testability/","text":"Testbarkeit","title":"Testbarkeit"},{"location":"module-2/testability/#testbarkeit","text":"","title":"Testbarkeit"},{"location":"module-4/introduction/","text":"Eine Exkursion in die Java-Welt Coming soon :)","title":"Eine Exkursion in die Java-Welt"},{"location":"module-4/introduction/#eine-exkursion-in-die-java-welt","text":"Coming soon :)","title":"Eine Exkursion in die Java-Welt"}]}